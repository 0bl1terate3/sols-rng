<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roll UI</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <!-- Base fonts (essential for UI) -->
    <link href="https://fonts.googleapis.com/css2?family=Sarpanch:wght@400;500;600;700;800;900&display=swap"
        rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+TC:wght@300;400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"
        referrerpolicy="no-referrer">
    <!-- Dynamic font loader for aura fonts -->
    <script>
        // This script dynamically loads all fonts used in AURAS array
        // Splits into batches to avoid URL length limits
        function loadAuraFonts() {
            if (window.__auraFontsLoaded) return;
            if (typeof AURAS === 'undefined') {
                const retries = (window.__auraFontsLoadRetries || 0) + 1;
                window.__auraFontsLoadRetries = retries;
                if (retries <= 20) {
                    setTimeout(loadAuraFonts, 150);
                } else {
                    console.warn('AURAS not available; skipping aura font preload');
                }
                return;
            }

            // Extract unique font families from AURAS
            const fonts = new Set();
            AURAS.forEach(aura => {
                if (aura.fontFamily) {
                    // Parse font family: "'Font Name', fallback" -> "Font Name"
                    const match = aura.fontFamily.match(/'([^']+)'/);
                    if (match && match[1]) {
                        fonts.add(match[1]);
                    }
                }
            });

            // Remove system fonts that aren't from Google Fonts
            const systemFonts = ['sans-serif', 'serif', 'monospace', 'cursive', 'fantasy'];
            systemFonts.forEach(f => fonts.delete(f));

            const fontArray = Array.from(fonts);
            if (fontArray.length === 0) return;

            // Split into batches of 50 fonts each to avoid URL length limits
            const batchSize = 50;
            const batches = [];
            for (let i = 0; i < fontArray.length; i += batchSize) {
                batches.push(fontArray.slice(i, i + batchSize));
            }

            // Load each batch as a separate stylesheet
            batches.forEach((batch, index) => {
                const fontFamilies = batch
                    .map(f => 'family=' + f.replace(/ /g, '+'))
                    .join('&');

                const link = document.createElement('link');
                link.rel = 'stylesheet';
                link.href = 'https://fonts.googleapis.com/css2?' + fontFamilies + '&display=swap';
                document.head.appendChild(link);
            });

            window.__auraFontsLoaded = true;
            console.log(`Loaded ${fonts.size} fonts from AURAS in ${batches.length} batches`);
        }

        function scheduleAuraFontLoad() {
            if (window.__auraFontsLoadScheduled) return;
            window.__auraFontsLoadScheduled = true;
            if ('requestIdleCallback' in window) {
                requestIdleCallback(() => loadAuraFonts(), { timeout: 3000 });
            } else {
                setTimeout(loadAuraFonts, 1200);
            }
        }

        // Defer font loading to avoid startup stutter
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', scheduleAuraFontLoad);
        } else {
            scheduleAuraFontLoad();
        }
    </script>
    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
      }
    }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.4/howler.min.js"></script>

    <!-- Game Data & Logic -->
    <script src="performance.js"></script>
    <script src="auras.js"></script>
    <script src="potions.js"></script>
    <script src="gears.js"></script>
    <script src="achievements.js"></script>
    <script src="cutscenes.js"></script>

    <!-- Biome Effects -->
    <script src="sakura.js"></script>
    <script src="deepsea.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Sarpanch', sans-serif;
            margin: 0;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden;
            color: #ffffff;
        }

        /* === PERFORMANCE OPTIMIZATIONS === */
        /* GPU acceleration for animated elements */
        .raindrop,
        .snowflake,
        .dust-particle,
        .dust-streak,
        .wind-streak,
        .sand-cloud,
        .sakura-petal,
        .ink-drip {
            will-change: transform, opacity;
            transform: translateZ(0);
            contain: layout style paint;
        }

        /* Contain expensive repaints */
        #weather-container,
        #biome-overlay,
        #video-cutscene-overlay {
            contain: strict;
        }

        /* Reduce paint complexity for overlays */
        .dim-overlay,
        .menu-overlay {
            contain: layout paint;
        }

        /* Ambient Background - REMOVED to show 3D Grid */
        /* body::before { content: ''; ... } */

        /* Perspective Grid Container */
        #perspective-grid-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: -2;
            background: #050510;
            /* Deep dark background */
        }

        /* The 3D Grid Floor */
        #perspective-grid {
            position: absolute;
            width: 200vw;
            /* Oversized to ensure coverage after rotation */
            height: 200vh;
            left: -50%;
            top: -50%;
            transform-origin: 50% 50%;
            transform: perspective(300px) rotateX(80deg) translateY(50px) translateZ(-50px);
            background-image:
                linear-gradient(to right, rgba(255, 255, 255, 0.15) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(255, 255, 255, 0.15) 1px, transparent 1px);
            background-size: 60px 60px;
            /* Larger grid squares */
            pointer-events: none;
        }

        /* Horizon Fog / Fade */
        #perspective-grid::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, #050510 0%, transparent 60%);
            pointer-events: none;
        }

        /* Day/Night Lighting Overlay */
        #lighting-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000022;
            /* Deep blue night tint */
            opacity: 0;
            /* Default to Day (invisible) */
            pointer-events: none;
            z-index: -1;
            /* Above grid, below content */
            transition: opacity 3s ease-in-out;
            mix-blend-mode: multiply;
            /* Better blending with grid */
        }

        .main-container {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: center;
            padding-bottom: 60px;
            z-index: 10;
        }

        /* Central Roll Overlay */
        .roll-overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -60%) translateZ(0);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease, transform 0.5s cubic-bezier(0.16, 1, 0.3, 1);
            z-index: 200000;
            /* Above all cutscenes and flashes */
            width: 100%;
        }

        .roll-overlay.active {
            opacity: 1;
            transform: translate(-50%, -50%);
        }

        .overlay-name {
            font-size: 72px;
            font-weight: 500;
            letter-spacing: 2px;
            margin-bottom: 10px;
            transition: transform 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            will-change: transform, opacity;
            transform: translateZ(0);
        }

        /* Class applied when using gradient text */
        .overlay-name.has-gradient {
            background-clip: text !important;
            -webkit-background-clip: text !important;
            color: transparent !important;
            -webkit-text-fill-color: transparent !important;
            /* Note: text-shadow IS allowed here - it creates outlines around gradient text */
        }

        /* For gradient text with solid outline */
        .overlay-name.has-gradient-outline {
            background-clip: text !important;
            -webkit-background-clip: text !important;
            -webkit-text-fill-color: transparent !important;
            /* paint-order makes stroke paint first (behind), then fill (gradient) on top */
            paint-order: stroke fill;
            /* The stroke creates the outline */
            -webkit-text-stroke: var(--aura-stroke-width, 0) var(--aura-stroke-color, transparent);
        }

        /* Legacy: Support for outlines via pseudo-element (fallback) */
        .overlay-name[data-text] {
            position: relative;
        }

        .overlay-chance {
            font-size: 24px;
            font-weight: 800;
            color: #ffd700;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.4);
            will-change: transform, opacity;
            transform: translateZ(0);
        }

        .storage-full-popup {
            position: fixed;
            left: 50%;
            top: calc(50% + 125px);
            transform: translateX(-50%) translateY(8px);
            min-width: 380px;
            max-width: min(92vw, 560px);
            padding: 12px;
            background: rgba(6, 12, 22, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.25);
            box-shadow: 0 18px 42px rgba(0, 0, 0, 0.55);
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            z-index: 200100;
            pointer-events: auto;
            opacity: 0;
            transition: opacity 0.18s ease, transform 0.18s ease;
        }

        .storage-full-popup.active {
            display: flex;
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        .storage-full-title {
            font-size: 22px;
            font-weight: 700;
            letter-spacing: 0.5px;
            color: #ffcc66;
            text-shadow: 0 0 12px rgba(255, 204, 102, 0.35);
        }

        .storage-full-desc {
            text-align: center;
            font-size: 13px;
            line-height: 1.3;
            color: rgba(255, 255, 255, 0.9);
            max-width: 100%;
        }

        .storage-full-actions {
            width: 100%;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .storage-full-btn {
            height: 34px;
            border: 1px solid rgba(255, 255, 255, 0.35);
            background: rgba(18, 28, 42, 0.9);
            color: #fff;
            font-family: 'Sarpanch', sans-serif;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .storage-full-btn:hover {
            border-color: rgba(255, 255, 255, 0.6);
            background: rgba(34, 49, 69, 0.95);
        }

        .storage-full-btn.replace {
            color: #2ecc71;
            border-color: rgba(46, 204, 113, 0.55);
            background: rgba(22, 58, 39, 0.75);
        }

        .storage-full-btn.discard {
            color: #ff6b6b;
            border-color: rgba(255, 107, 107, 0.55);
            background: rgba(64, 25, 28, 0.75);
        }

        @media (max-width: 760px) {
            .storage-full-popup {
                min-width: 0;
                top: calc(50% + 105px);
                padding: 10px;
                gap: 8px;
            }

            .storage-full-title {
                font-size: 18px;
            }

            .storage-full-desc {
                font-size: 12px;
            }

            .storage-full-btn {
                height: 30px;
                font-size: 12px;
            }
        }

        /* Quick Cycle Animation - Smooth with GPU acceleration */
        @keyframes aura-spawn-down {
            0% {
                opacity: 0;
                transform: translateY(-40px) translateZ(0);
            }

            20% {
                opacity: 1;
                transform: translateY(0) translateZ(0);
            }

            80% {
                opacity: 1;
                transform: translateY(0) translateZ(0);
            }

            100% {
                opacity: 0;
                transform: translateY(40px) translateZ(0);
            }
        }

        /* Equinox Animation - Blinking/Pulsing effect */
        @keyframes EquinoxTransition {

            0%,
            5% {
                color: rgba(255, 255, 255, 1);
                -webkit-text-fill-color: rgba(255, 255, 255, 1);
            }

            10%,
            20% {
                color: rgba(255, 255, 255, 0);
                -webkit-text-fill-color: rgba(255, 255, 255, 0);
            }

            25%,
            30% {
                color: rgba(255, 255, 255, 1);
                -webkit-text-fill-color: rgba(255, 255, 255, 1);
            }

            35%,
            45% {
                color: rgba(255, 255, 255, 0);
                -webkit-text-fill-color: rgba(255, 255, 255, 0);
            }

            50%,
            55% {
                color: rgba(255, 255, 255, 1);
                -webkit-text-fill-color: rgba(255, 255, 255, 1);
            }

            60%,
            70% {
                color: rgba(255, 255, 255, 0);
                -webkit-text-fill-color: rgba(255, 255, 255, 0);
            }

            75%,
            80% {
                color: rgba(255, 255, 255, 1);
                -webkit-text-fill-color: rgba(255, 255, 255, 1);
            }

            85%,
            95% {
                color: rgba(255, 255, 255, 0);
                -webkit-text-fill-color: rgba(255, 255, 255, 0);
            }

            100% {
                color: rgba(255, 255, 255, 1);
                -webkit-text-fill-color: rgba(255, 255, 255, 1);
            }
        }

        @keyframes EquinoxPulse {

            0%,
            5% {
                transform: scale(0.95);
            }

            10% {
                transform: scale(1);
            }

            15%,
            20%,
            25%,
            30% {
                transform: scale(0.95);
            }

            35% {
                transform: scale(1);
            }

            40%,
            45%,
            50%,
            55% {
                transform: scale(0.95);
            }

            60% {
                transform: scale(1);
            }

            65%,
            70%,
            75%,
            80% {
                transform: scale(0.95);
            }

            85% {
                transform: scale(1);
            }

            90%,
            95%,
            100% {
                transform: scale(0.95);
            }
        }

        @keyframes EquinoxGradient {
            0% {
                background: linear-gradient(-3deg, black 50%, white 50%);
            }

            5% {
                background: linear-gradient(-3deg, black 50%, white 50%);
            }

            10% {
                background: linear-gradient(-3deg, black 50%, white 50%);
            }

            15% {
                background: linear-gradient(-3deg, black 50%, white 50%);
            }

            20% {
                background: linear-gradient(-3deg, black 50%, white 50%);
            }

            25% {
                background: linear-gradient(-3deg, white 50%, black 50%);
            }

            30% {
                background: linear-gradient(-3deg, white 50%, black 50%);
            }

            35% {
                background: linear-gradient(-3deg, white 50%, black 50%);
            }

            40% {
                background: linear-gradient(-3deg, white 50%, black 50%);
            }

            45% {
                background: linear-gradient(-3deg, white 50%, black 50%);
            }

            50% {
                background: linear-gradient(-3deg, black 50%, white 50%);
            }

            55% {
                background: linear-gradient(-3deg, black 50%, white 50%);
            }

            60% {
                background: linear-gradient(-3deg, black 50%, white 50%);
            }

            65% {
                background: linear-gradient(-3deg, black 50%, white 50%);
            }

            70% {
                background: linear-gradient(-3deg, black 50%, white 50%);
            }

            75% {
                background: linear-gradient(-3deg, white 50%, black 50%);
            }

            80% {
                background: linear-gradient(-3deg, white 50%, black 50%);
            }

            85% {
                background: linear-gradient(-3deg, white 50%, black 50%);
            }

            90% {
                background: linear-gradient(-3deg, white 50%, black 50%);
            }

            95% {
                background: linear-gradient(-3deg, white 50%, black 50%);
            }

            100% {
                background: linear-gradient(-3deg, white 50%, black 50%);
            }
        }

        @keyframes EquinoxMovement {
            0% {
                transform: translate(-1.25px, 0.5px) rotate(-2deg);
            }

            25% {
                transform: translate(-1.5px, -1px) rotate(0deg);
            }

            50% {
                transform: translate(1.25px, -0.5px) rotate(2deg);
            }

            75% {
                transform: translate(1.5px, 1px) rotate(0deg);
            }

            100% {
                transform: translate(-1.25px, 0.5px) rotate(-2deg);
            }
        }

        /* Shake Animation - for tornado, etc */
        @keyframes shake {

            0%,
            100% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-3px) rotate(-1deg);
            }

            50% {
                transform: translateX(3px) rotate(1deg);
            }

            75% {
                transform: translateX(-2px) rotate(-0.5deg);
            }
        }

        /* Pulse Slow Animation */
        @keyframes pulse-slow {

            0%,
            100% {
                transform: scale(1);
                opacity: 1;
            }

            50% {
                transform: scale(1.05);
                opacity: 0.9;
            }
        }

        /* Bright Flash Animation */
        @keyframes bright-flash {

            0%,
            100% {
                filter: brightness(1);
                text-shadow: 0 0 10px currentColor;
            }

            50% {
                filter: brightness(1.5);
                text-shadow: 0 0 30px currentColor, 0 0 60px currentColor;
            }
        }

        /* Black Hole Animation - for Gargantua */
        @keyframes black-hole {

            0%,
            100% {
                transform: scale(1);
                filter: brightness(1);
            }

            25% {
                transform: scale(0.98) rotate(-0.5deg);
                filter: brightness(0.9);
            }

            50% {
                transform: scale(1.02);
                filter: brightness(1.1);
            }

            75% {
                transform: scale(0.99) rotate(0.5deg);
                filter: brightness(0.95);
            }
        }

        /* White Hole Animation - for Gargantua : Whitehole (inverse of black hole) */
        @keyframes white-hole {

            0%,
            100% {
                transform: scale(1);
                filter: brightness(1.2) drop-shadow(0 0 15px rgba(255, 215, 0, 0.6));
            }

            25% {
                transform: scale(1.02) rotate(0.5deg);
                filter: brightness(1.3) drop-shadow(0 0 20px rgba(255, 215, 0, 0.8));
            }

            50% {
                transform: scale(0.98);
                filter: brightness(1.1) drop-shadow(0 0 10px rgba(255, 215, 0, 0.5));
            }

            75% {
                transform: scale(1.01) rotate(-0.5deg);
                filter: brightness(1.25) drop-shadow(0 0 18px rgba(255, 215, 0, 0.7));
            }
        }

        /* Equinox Wrapper and Layer Styling */
        .equinox-wrapper {
            display: inline-block;
            font-family: 'Noto Serif TC', serif;
            font-weight: bold;
            font-size: 110%;
            font-style: italic;
            text-transform: uppercase;
            animation: EquinoxMovement 2s linear infinite;
            letter-spacing: .35em;
            position: relative;
        }

        .equinox-gradient {
            position: absolute;
            animation: EquinoxGradient 1.25s linear infinite, EquinoxPulse 1.25s linear infinite;
            -webkit-background-clip: text !important;
            background-clip: text !important;
            -webkit-text-fill-color: transparent;
            -webkit-text-stroke: 0.4px white;
        }

        .equinox-transition {
            position: relative;
            animation: EquinoxTransition 1.25s linear infinite, EquinoxPulse 1.25s linear infinite;
            display: inline-block;
        }

        /* Abyssal Hunter Dual-Layer Styling */
        .abyssal-wrapper {
            font-weight: bold;
            font-family: 'Sarpanch', sans-serif;
            font-style: italic;
            display: inline-block;
            text-transform: uppercase;
            white-space: nowrap;
            position: relative;
        }

        .abyssal-outline {
            position: absolute;
            -webkit-background-clip: text !important;
            background-clip: text !important;
            -webkit-text-fill-color: transparent;
            -webkit-text-stroke: 0.11em transparent;
        }

        .abyssal-main {
            position: relative;
            -webkit-background-clip: text !important;
            background-clip: text !important;
            -webkit-text-fill-color: transparent;
        }

        /* Deep Sea Glow Animation - for bioluminescent effect */
        @keyframes deep-sea-glow {

            0%,
            100% {
                filter: brightness(1) drop-shadow(0 0 10px rgba(0, 255, 255, 0.5));
            }

            50% {
                filter: brightness(1.3) drop-shadow(0 0 20px rgba(0, 255, 255, 0.8));
            }
        }

        /* SOLSTICE Chromatic Aberration Styling - Opposite of Equinox */
        .solstice-wrapper {
            font-weight: bold;
            font-family: 'Noto Serif TC', serif;
            font-style: italic;
            display: inline-block;
            text-transform: uppercase;
            white-space: nowrap;
            position: relative;
            letter-spacing: 0.35em;
            font-size: 110%;
        }

        /* Red channel - shifted left */
        .solstice-red {
            position: absolute;
            color: #ff0000;
            animation: solstice-drift-left 2s ease-in-out infinite;
            opacity: 0.8;
            mix-blend-mode: screen;
        }

        /* Green channel - center */
        .solstice-green {
            position: absolute;
            color: #00ff00;
            animation: solstice-pulse 2s ease-in-out infinite;
            opacity: 0.8;
            mix-blend-mode: screen;
        }

        /* Blue channel - shifted right */
        .solstice-blue {
            position: relative;
            color: #0000ff;
            animation: solstice-drift-right 2s ease-in-out infinite;
            opacity: 0.8;
            mix-blend-mode: screen;
        }

        /* Chromatic aberration animations */
        @keyframes solstice-drift-left {

            0%,
            100% {
                transform: translateX(-2px);
                opacity: 0.8;
            }

            50% {
                transform: translateX(-4px);
                opacity: 0.6;
            }
        }

        @keyframes solstice-drift-right {

            0%,
            100% {
                transform: translateX(2px);
                opacity: 0.8;
            }

            50% {
                transform: translateX(4px);
                opacity: 0.6;
            }
        }

        @keyframes solstice-pulse {

            0%,
            100% {
                transform: scale(1);
                opacity: 0.8;
            }

            50% {
                transform: scale(1.02);
                opacity: 1;
            }
        }

        /* Roll Buttons Styling (Sol's-inspired) */
        .roll-buttons {
            --panel-top: rgba(20, 22, 27, 0.64);
            --panel-mid: rgba(10, 11, 15, 0.58);
            --panel-bottom: rgba(3, 4, 7, 0.52);
            --text: #eef7ff;
            --subtext: #ffea5f;
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .button {
            --bracket-color: #f4fbff;
            --bracket-thickness: 3px;
            --bracket-len: 13px;
            --bracket-inset-y: 0px;
            --bracket-inset-x: 0px;
            position: relative;
            height: 52px;
            border: 0;
            border-radius: 0;
            appearance: none;
            padding: 5px 12px 4px;
            margin: 0;
            color: var(--text);
            background:
                linear-gradient(180deg, rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0) 42%),
                linear-gradient(180deg, var(--panel-top), var(--panel-mid) 52%, var(--panel-bottom));
            font-family: 'Sarpanch', sans-serif;
            text-shadow: 0 2px 0 rgba(8, 29, 61, 0.9);
            cursor: pointer;
            pointer-events: auto;
            box-shadow:
                inset 0 1px 0 rgba(255, 255, 255, 0.16),
                inset 0 -3px 0 rgba(0, 0, 0, 0.45),
                0 6px 18px rgba(0, 0, 0, 0.32);
            transition: transform 120ms ease, filter 120ms ease;
            overflow: visible;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .button::before {
            content: "";
            position: absolute;
            top: var(--bracket-inset-y);
            right: var(--bracket-inset-x);
            bottom: var(--bracket-inset-y);
            left: var(--bracket-inset-x);
            pointer-events: none;
            background:
                linear-gradient(var(--bracket-color), var(--bracket-color)) left top / var(--bracket-len) var(--bracket-thickness) no-repeat,
                linear-gradient(var(--bracket-color), var(--bracket-color)) left top / var(--bracket-thickness) var(--bracket-len) no-repeat,
                linear-gradient(var(--bracket-color), var(--bracket-color)) right top / var(--bracket-len) var(--bracket-thickness) no-repeat,
                linear-gradient(var(--bracket-color), var(--bracket-color)) right top / var(--bracket-thickness) var(--bracket-len) no-repeat,
                linear-gradient(var(--bracket-color), var(--bracket-color)) left bottom / var(--bracket-len) var(--bracket-thickness) no-repeat,
                linear-gradient(var(--bracket-color), var(--bracket-color)) left bottom / var(--bracket-thickness) var(--bracket-len) no-repeat,
                linear-gradient(var(--bracket-color), var(--bracket-color)) right bottom / var(--bracket-len) var(--bracket-thickness) no-repeat,
                linear-gradient(var(--bracket-color), var(--bracket-color)) right bottom / var(--bracket-thickness) var(--bracket-len) no-repeat;
            opacity: 0.96;
            z-index: 2;
        }

        .button>span {
            position: relative;
            z-index: 3;
        }

        .button.disabled {
            cursor: default;
            pointer-events: none;
        }

        .button:hover:not(.disabled) {
            filter: brightness(1.06);
        }

        .button:active:not(.disabled) {
            transform: translateY(1px);
        }

        .button-left,
        .button-right {
            height: 44px;
            min-width: 150px;
            padding: 4px 10px 3px;
            --bracket-len: 11px;
        }

        .button-left>span,
        .button-right>span {
            font-size: clamp(13px, 1.08vw, 18px);
            line-height: 1;
            font-weight: 500;
            letter-spacing: 0.02em;
            white-space: nowrap;
            width: 100%;
            text-align: center;
        }

        .button-center {
            position: relative;
            height: 56px;
            min-width: 240px;
            padding: 5px 14px 4px;
            --bracket-len: 13px;
        }

        .button-center .roll-text {
            font-size: clamp(30px, 2.45vw, 42px);
            font-weight: 700;
            line-height: 0.84;
            transform: translateY(-1px);
            margin-bottom: 0;
        }

        .button-center .roll-count {
            position: absolute;
            left: 50%;
            bottom: -9px;
            transform: translateX(-50%);
            margin-top: 0;
            font-size: clamp(12px, 0.95vw, 16px);
            line-height: 1;
            font-weight: 500;
            color: var(--subtext);
            text-shadow: 0 1px 0 rgba(30, 22, 2, 0.85);
            white-space: nowrap;
            z-index: 3;
        }

        /* Progress/Cooldown */
        #roll-button .button-progress-fill {
            position: absolute;
            top: 0;
            left: 0;
            width: 0%;
            height: 100%;
            background: rgba(190, 200, 216, 0.3);
            z-index: 1;
            pointer-events: none;
        }

        #roll-button.cooldown-active .button-progress-fill {
            background: rgba(212, 220, 234, 0.42);
        }

        #auto-roll[aria-pressed="true"],
        #quick-roll[aria-pressed="true"] {
            background:
                linear-gradient(180deg, rgba(255, 255, 255, 0.14), rgba(255, 255, 255, 0.02) 36%),
                linear-gradient(180deg, rgba(28, 30, 37, 0.7), rgba(16, 18, 24, 0.66) 52%, rgba(6, 8, 12, 0.62));
        }

        #auto-roll[aria-pressed="false"],
        #quick-roll[aria-pressed="false"] {
            background:
                linear-gradient(180deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0) 38%),
                linear-gradient(180deg, rgba(20, 23, 30, 0.58), rgba(10, 12, 18, 0.56) 52%, rgba(3, 5, 9, 0.52));
        }

        .roll-buttons .corner {
            display: none;
        }

        @media (max-width: 930px) {
            .roll-buttons {
                flex-wrap: wrap;
                justify-content: center;
                gap: 10px;
            }

            .button {
                height: 48px;
                --bracket-len: 11px;
            }

            .button-left,
            .button-right {
                height: 42px;
                --bracket-len: 10px;
            }

            .button-center {
                order: 3;
                width: 100%;
                max-width: 420px;
                min-width: min(420px, 95vw);
                height: 52px;
                --bracket-len: 12px;
            }

            .button-center .roll-count {
                bottom: -8px;
            }
        }

        @media (max-width: 560px) {
            .roll-buttons {
                gap: 6px;
            }

            .button {
                height: 44px;
                padding: 6px 9px;
                --bracket-len: 9px;
            }

            .button-left,
            .button-right {
                height: 38px;
                padding: 4px 7px 3px;
                min-width: calc(50vw - 18px);
                --bracket-len: 8px;
            }

            .button-center {
                height: 46px;
                padding: 5px 10px 4px;
                min-width: calc(100vw - 20px);
                --bracket-len: 9px;
            }

            .button-center .roll-count {
                bottom: -7px;
            }

            .button-left>span,
            .button-right>span {
                font-size: clamp(12px, 3.5vw, 16px);
            }

            .button-center .roll-text {
                font-size: clamp(26px, 8vw, 32px);
            }
        }



        /* Bracket Corners */
        .corner {
            position: absolute;
            width: 10px;
            height: 10px;
            border-color: rgba(255, 255, 255, 0.6);
            border-style: solid;
            pointer-events: none;
            z-index: 5;
        }

        .corner.tl {
            top: 0;
            left: 0;
            border-width: 2px 0 0 2px;
        }

        .corner.tr {
            top: 0;
            right: 0;
            border-width: 2px 2px 0 0;
        }

        .corner.bl {
            bottom: 0;
            left: 0;
            border-width: 0 0 2px 2px;
        }

        .corner.br {
            bottom: 0;
            right: 0;
            border-width: 0 2px 2px 0;
        }

        .dim-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0);
            pointer-events: none;
            z-index: 50;
            transition: background 0.5s ease;
        }

        body.dimmed .dim-overlay {
            background: rgba(0, 0, 0, 0.7);
        }

        body.dimmed .main-container {
            filter: blur(4px);
            transition: filter 0.5s ease;
        }

        span {
            position: relative;
            z-index: 2;
        }

        /* Weather Effects */
        #weather-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            overflow: hidden;
        }

        .raindrop {
            position: absolute;
            width: 2px;
            height: 80px;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0), rgba(200, 210, 220, 0.5));
            top: -100px;
            transform: rotate(15deg);
            animation: rain-fall 0.6s linear infinite;
        }

        @keyframes rain-fall {
            to {
                transform: rotate(15deg) translateY(120vh);
            }
        }

        /* Wind Streaks */
        .wind-streak {
            position: absolute;
            height: 2px;
            background: linear-gradient(to right, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0.4), rgba(255, 255, 255, 0));
            left: -200px;
            animation: wind-blow linear infinite;
        }

        @keyframes wind-blow {
            to {
                transform: translateX(120vw);
            }
        }

        /* Snowflakes */
        .snowflake {
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            top: -20px;
            box-shadow: 0 0 6px rgba(255, 255, 255, 0.8);
            animation: snow-fall linear forwards;
        }

        @keyframes snow-fall {
            0% {
                transform: translateY(0) translateX(0);
                opacity: 0;
            }

            10% {
                opacity: 1;
            }

            100% {
                transform: translateY(110vh) translateX(20px);
                opacity: 0.8;
            }
        }

        /* LIMBO Ink Drips */
        .ink-drip {
            position: absolute;
            top: -180px;
            border-radius: 999px;
            background: linear-gradient(to bottom,
                    rgba(8, 8, 8, 0),
                    rgba(0, 0, 0, 0.92) 25%,
                    rgba(0, 0, 0, 1) 100%);
            box-shadow: 0 0 12px rgba(0, 0, 0, 0.5);
            animation: ink-drip-fall linear forwards;
        }

        @keyframes ink-drip-fall {
            0% {
                transform: translateY(0) scaleY(0.92);
                opacity: 0;
            }

            12% {
                opacity: 0.9;
            }

            100% {
                transform: translateY(130vh) scaleY(1.08);
                opacity: 0;
            }
        }

        /* Sandstorm Effects */
        .dust-streak {
            position: absolute;
            height: 3px;
            background: linear-gradient(to right,
                    rgba(210, 180, 140, 0),
                    rgba(210, 180, 140, 0.6),
                    rgba(210, 180, 140, 0.8),
                    rgba(210, 180, 140, 0.6),
                    rgba(210, 180, 140, 0));
            left: -300px;
            animation: dust-blow linear forwards;
            filter: blur(1px);
        }

        @keyframes dust-blow {
            to {
                transform: translateX(calc(100vw + 500px));
            }
        }

        .dust-particle {
            position: absolute;
            background: radial-gradient(circle, rgba(200, 170, 130, 0.8) 0%, rgba(180, 150, 100, 0) 70%);
            border-radius: 50%;
            animation: dust-float linear forwards;
            filter: blur(1px);
        }

        @keyframes dust-float {
            0% {
                transform: translateX(0) translateY(0) rotate(0deg);
            }

            100% {
                transform: translateX(calc(100vw + 100px)) translateY(20vh) rotate(360deg);
            }
        }

        .sand-cloud {
            position: absolute;
            background: radial-gradient(ellipse at center,
                    rgba(190, 160, 120, 0.4) 0%,
                    rgba(180, 150, 100, 0.2) 40%,
                    rgba(170, 140, 90, 0) 70%);
            border-radius: 50%;
            animation: cloud-drift linear forwards;
            filter: blur(8px);
        }

        @keyframes cloud-drift {
            0% {
                transform: translateX(-50%) scale(1);
                opacity: 0;
            }

            20% {
                opacity: 0.6;
            }

            100% {
                transform: translateX(calc(100vw + 300px)) scale(1.5);
                opacity: 0;
            }
        }

        /* Hell Biome Effects */
        #fire-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
        }

        .lava-glow {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 50%;
            background: linear-gradient(to top, rgba(255, 50, 0, 0.5) 0%, rgba(200, 30, 0, 0.25) 30%, transparent 100%);
            animation: lava-pulse 2s ease-in-out infinite;
            pointer-events: none;
            z-index: 1;
        }

        @keyframes lava-pulse {

            0%,
            100% {
                opacity: 0.7;
            }

            50% {
                opacity: 1;
            }
        }

        /* Biome Background Overlay */
        #biome-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
            opacity: 0;
            transition: opacity 1s ease, background 1s ease;
        }

        #biome-overlay.active {
            opacity: 1;
        }

        #biome-overlay.active {
            opacity: 1;
        }

        /* Left Sidebar & Button Styling */
        .left-sidebar {
            position: fixed;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 1000;
        }

        /* Reset absolute positioning for sidebar items */
        .left-sidebar .admin-btn,
        .left-sidebar .items-btn,
        .left-sidebar .storage-btn,
        .left-sidebar .inventory-btn,
        .left-sidebar .menu-btn {
            position: relative;
            top: auto;
            left: auto;
            right: auto;
            bottom: auto;
            transform: none;
            margin: 0;
        }

        /* Menu Button */
        .menu-btn {
            width: 45px;
            height: 45px;
            background: rgba(15, 25, 35, 0.7);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .menu-btn:hover {
            background: rgba(40, 50, 65, 0.9);
            transform: scale(1.05);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .left-sidebar .sidebar-icon {
            color: #ffffff;
            font-size: 20px;
            line-height: 1;
            pointer-events: none;
            text-shadow: 0 0 8px rgba(255, 255, 255, 0.45);
        }

        #menu-btn .sidebar-icon {
            font-size: 18px;
        }

        /* Admin Button Styling */
        .admin-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 80px;
            height: 30px;
            background: rgba(15, 25, 35, 0.7);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: #fff;
            font-family: 'Sarpanch', sans-serif;
            font-weight: 700;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            z-index: 1000;
        }

        .admin-btn:hover {
            background: rgba(40, 50, 65, 0.9);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .admin-btn .corner {
            border-color: rgba(255, 255, 255, 0.4);
        }

        /* Uniform Square Buttons */
        .items-btn,
        .storage-btn,
        .inventory-btn {
            width: 45px !important;
            height: 45px !important;
            min-width: 0 !important;
            /* Override potential min-width */
            padding: 0 !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            background: rgba(15, 25, 35, 0.7) !important;
            border: 1px solid rgba(255, 255, 255, 0.15) !important;
        }

        .items-btn:hover,
        .storage-btn:hover,
        .inventory-btn:hover {
            background: rgba(40, 50, 65, 0.9) !important;
            border-color: rgba(255, 255, 255, 0.3) !important;
        }




        /* Menu Panel - Black semi-transparent */
        .menu-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            width: 320px;
            background: rgba(10, 10, 20, 0.95);
            border-radius: 4px;
            /* Slightly rounded overall */
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.25s ease;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
        }

        .menu-panel.active {
            opacity: 1;
            visibility: visible;
            transform: translate(-50%, -50%) scale(1);
        }

        .menu-header {
            display: flex;
            justify-content: center;
            /* Centered title */
            align-items: center;
            padding: 10px;
            position: relative;
        }

        .menu-title {
            font-family: 'Faculty Glyphic', sans-serif;
            font-size: 24px;
            color: #ffffff;
            font-weight: 500;
            letter-spacing: 1px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        .menu-close {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.8);
            font-size: 20px;
            cursor: pointer;
            transition: color 0.2s;
        }

        .menu-close:hover {
            color: #ffffff;
        }

        .menu-items {
            padding: 8px 12px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .menu-item {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 45px;
            color: #ffffff;
            font-family: 'Sarpanch', sans-serif;
            font-size: 20px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
            background: none;
            border: none;
            overflow: visible;
            padding: 0 8px;
        }



        /* Watermark Icon - Large, Grey, Corner-filling */
        .menu-item-watermark {
            position: absolute;
            left: -8px;
            bottom: -8px;
            width: 50px;
            height: 50px;
            opacity: 0.25;
            pointer-events: none;
            display: flex;
            align-items: flex-end;
            justify-content: flex-start;
            font-size: 45px;
            z-index: 0;
            /* Force emojis to be grey flat shapes */
            filter: grayscale(100%) contrast(50%) brightness(150%);
            transform: none;
        }

        .menu-item.premium .menu-item-watermark {
            /* Premium icon also grey but maybe slightly brighter or different filter */
            filter: grayscale(100%) sepia(100%) hue-rotate(0deg) saturate(0%) brightness(150%);
        }

        .menu-item-text {
            z-index: 1;
            position: relative;
        }

        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            z-index: 999;
            opacity: 0;
            visibility: hidden;
            transition: all 0.25s ease;
        }

        .menu-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        /* Filter Panel Styling */
        .filter-panel {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1750;
            width: 550px;
            height: 600px;
            background: rgba(10, 15, 25, 0.98);
            backdrop-filter: blur(25px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 4px;
            box-shadow: 0 30px 100px rgba(0, 0, 0, 1);
            font-family: 'Staatliches', sans-serif;
            color: #fff;
            flex-direction: column;
        }

        .filter-panel.active {
            display: flex;
        }

        .filter-header {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 15px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
            position: relative;
        }

        .filter-title {
            font-size: 24px;
            font-weight: 600;
            letter-spacing: 1.5px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        .filter-close {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            font-size: 28px;
            cursor: pointer;
            transition: color 0.2s;
        }

        .filter-close:hover {
            color: #ff6b6b;
        }

        .filter-content {
            flex: 1;
            padding: 10px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .filter-content::-webkit-scrollbar {
            width: 6px;
        }

        .filter-content::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
        }

        .filter-content::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        .filter-row {
            background: rgba(20, 25, 35, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.05);
            padding: 10px 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: relative;
            transition: background 0.2s;
        }

        .filter-row:hover {
            background: rgba(40, 50, 65, 0.5);
        }

        .filter-row.disabled {
            opacity: 0.4;
        }

        .filter-aura-name {
            font-size: 16px;
            font-weight: 700;
            font-family: inherit;
            letter-spacing: 0.5px;
            flex: 1;
        }

        .filter-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .filter-status-btn {
            min-width: 90px;
            height: 32px;
            background: rgba(15, 25, 35, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.7);
            font-family: inherit;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .filter-icon-btn {
            width: 32px;
            height: 32px;
            background: rgba(15, 25, 35, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 16px;
        }

        .filter-row.skip .filter-status-btn,
        .filter-row.skip .filter-icon-btn {
            color: #ff6b6b;
            border-color: #ff6b6b;
            background: rgba(255, 107, 107, 0.15);
        }

        .filter-row.keep .filter-status-btn,
        .filter-row.keep .filter-icon-btn {
            color: #2ecc71;
            border-color: #2ecc71;
            background: rgba(46, 204, 113, 0.15);
        }

        /* Workshop/Items Button */
        .items-btn {
            position: absolute;
            top: 20px;
            left: 140px;
            background: rgba(15, 25, 35, 0.7);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: #fff;
            font-family: 'Sarpanch', sans-serif;
            font-size: 14px;
            font-weight: 600;
            padding: 8px 10px;
            min-width: 50px;
            cursor: pointer;
            z-index: 200;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .items-btn:hover {
            background: rgba(40, 50, 65, 0.9);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .items-btn .corner {
            border-color: rgba(255, 255, 255, 0.5);
        }

        /* Inventory Button - Left Side */
        .inventory-btn {
            position: absolute;
            top: 20px;
            left: 80px;
            background: rgba(15, 25, 35, 0.7);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: #fff;
            font-family: 'Sarpanch', sans-serif;
            font-size: 20px;
            font-weight: 600;
            padding: 0;
            width: 42px;
            height: 42px;
            cursor: pointer;
            z-index: 200;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .inventory-btn:hover {
            background: rgba(40, 50, 65, 0.9);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .inventory-btn .corner {
            border-color: rgba(255, 255, 255, 0.5);
        }

        /* Aura Storage Button */
        .storage-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(15, 25, 35, 0.7);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: #fff;
            font-family: 'Sarpanch', sans-serif;
            font-size: 18px;
            font-weight: 600;
            padding: 0;
            width: 42px;
            height: 42px;
            cursor: pointer;
            z-index: 200;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .storage-btn:hover {
            background: rgba(40, 50, 65, 0.9);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .storage-btn .corner {
            border-color: rgba(255, 255, 255, 0.5);
        }

        /* Active Buff Tray (Bottom Right) */
        .active-buffs-container {
            position: absolute;
            right: 20px;
            bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            justify-content: flex-end;
            align-items: flex-end;
            gap: 6px;
            max-width: min(58vw, 620px);
            pointer-events: auto;
            z-index: 1200;
        }

        .active-buff-tile {
            --buff-accent: #2ecc71;
            width: 54px;
            height: 54px;
            border: 1px solid var(--buff-accent);
            background:
                linear-gradient(180deg, rgba(255, 255, 255, 0.14), rgba(255, 255, 255, 0) 36%),
                linear-gradient(160deg, rgba(16, 18, 28, 0.94), rgba(6, 8, 14, 0.95));
            box-shadow:
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                inset 0 -2px 0 rgba(0, 0, 0, 0.45),
                0 0 12px rgba(0, 0, 0, 0.45),
                0 0 10px var(--buff-accent);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: visible;
            transition: transform 120ms ease, filter 120ms ease, border-color 120ms ease;
        }

        .active-buff-tile:hover {
            transform: translateY(-1px);
            filter: brightness(1.08);
        }

        .active-buff-tile::before {
            content: '';
            position: absolute;
            inset: 0;
            border: 1px solid rgba(255, 255, 255, 0.08);
            pointer-events: none;
        }

        .active-buff-icon {
            font-size: 24px;
            color: #ffffff;
            text-shadow: 0 0 10px var(--buff-accent);
            filter: drop-shadow(0 0 6px var(--buff-accent));
        }

        .active-buff-time {
            position: absolute;
            top: 2px;
            right: 3px;
            font-size: 11px;
            font-weight: 700;
            color: #dff5ff;
            line-height: 1;
            text-shadow: 0 0 6px rgba(0, 0, 0, 0.85);
        }

        .active-buff-stack {
            position: absolute;
            right: 3px;
            bottom: 2px;
            font-size: 16px;
            font-weight: 700;
            color: #ffffff;
            line-height: 1;
            text-shadow: 0 0 7px rgba(0, 0, 0, 0.9);
        }

        .active-buff-corner {
            width: 8px;
            height: 8px;
            border-color: var(--buff-accent) !important;
            opacity: 0.9;
        }

        .active-buff-tooltip {
            position: absolute;
            right: 0;
            bottom: calc(100% + 8px);
            min-width: 180px;
            max-width: 280px;
            padding: 8px 10px;
            border: 1px solid rgba(244, 251, 255, 0.32);
            background:
                linear-gradient(180deg, rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0.02) 34%),
                linear-gradient(180deg, rgba(20, 23, 30, 0.92), rgba(8, 10, 16, 0.94));
            color: #f2f8ff;
            box-shadow:
                inset 0 1px 0 rgba(255, 255, 255, 0.16),
                inset 0 -2px 0 rgba(0, 0, 0, 0.42),
                0 12px 28px rgba(0, 0, 0, 0.45);
            opacity: 0;
            transform: translateY(4px);
            transition: opacity 120ms ease, transform 120ms ease;
            pointer-events: none;
            z-index: 20;
        }

        .active-buff-tile:hover .active-buff-tooltip {
            opacity: 1;
            transform: translateY(0);
        }

        .active-buff-tooltip-title {
            font-size: 12px;
            font-weight: 700;
            color: #ffffff;
            line-height: 1.2;
            margin-bottom: 5px;
            text-shadow: 0 1px 0 rgba(8, 29, 61, 0.85);
        }

        .active-buff-tooltip-effect,
        .active-buff-tooltip-remaining {
            font-size: 11px;
            line-height: 1.25;
            color: rgba(228, 239, 252, 0.9);
            text-shadow: 0 1px 0 rgba(8, 29, 61, 0.65);
        }

        .active-buff-tooltip-remaining {
            margin-top: 3px;
            color: rgba(214, 230, 246, 0.75);
        }

        .active-buff-tile.one-time {
            --buff-accent: #cf6cff;
        }

        .active-buff-tile.one-time .active-buff-time {
            color: #f3dcff;
        }

        @media (max-width: 820px) {
            .active-buffs-container {
                right: 12px;
                bottom: 12px;
                max-width: min(66vw, 420px);
                gap: 5px;
            }

            .active-buff-tile {
                width: 46px;
                height: 46px;
            }

            .active-buff-icon {
                font-size: 20px;
            }

            .active-buff-time {
                font-size: 9px;
            }

            .active-buff-stack {
                font-size: 13px;
            }

            .active-buff-tooltip {
                min-width: 160px;
                max-width: 220px;
                padding: 7px 8px;
            }

            .active-buff-tooltip-title {
                font-size: 11px;
            }

            .active-buff-tooltip-effect,
            .active-buff-tooltip-remaining {
                font-size: 10px;
            }
        }

        @media (hover: none) {
            .active-buff-tooltip {
                display: none;
            }
        }

        /* Workshop Panel */
        .workshop-panel {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1800;
            width: 960px;
            height: 680px;
            background: rgba(8, 12, 20, 0.98);
            backdrop-filter: blur(30px);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 0;
            box-shadow: 0 40px 120px rgba(0, 0, 0, 0.9);
            font-family: 'Sarpanch', sans-serif;
            color: #fff;
            flex-direction: column;
        }

        .workshop-panel.active {
            display: flex;
        }

        .workshop-header {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 15px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.05);
            position: relative;
            background: rgba(0, 0, 0, 0.3);
        }

        .workshop-title {
            font-size: 26px;
            font-weight: 700;
            letter-spacing: 1px;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
        }

        .workshop-close {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            font-size: 32px;
            cursor: pointer;
            transition: color 0.2s;
        }

        .workshop-close:hover {
            color: #ff6b6b;
        }

        .workshop-tabs {
            display: flex;
            background: rgba(0, 0, 0, 0.25);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .workshop-tab {
            flex: 1;
            padding: 12px;
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.4);
            cursor: pointer;
            font-family: 'Sarpanch', sans-serif;
            font-size: 15px;
            font-weight: 600;
            transition: all 0.2s;
            border-bottom: 3px solid transparent;
        }

        .workshop-tab:hover {
            color: #fff;
            background: rgba(255, 255, 255, 0.03);
        }

        .workshop-tab.active {
            color: #4a9eff;
            border-bottom-color: #4a9eff;
            background: rgba(74, 158, 255, 0.08);
        }

        .workshop-search {
            padding: 12px 15px;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .workshop-search input {
            width: 100%;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #fff;
            padding: 8px 12px;
            font-family: 'Sarpanch', sans-serif;
            font-size: 14px;
            outline: none;
        }

        .workshop-search input::placeholder {
            color: rgba(255, 255, 255, 0.3);
        }

        .workshop-content {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .workshop-left {
            width: 320px;
            border-right: 2px solid rgba(255, 255, 255, 0.05);
            display: flex;
            flex-direction: column;
            background: rgba(0, 0, 0, 0.15);
        }

        .workshop-preview {
            height: 200px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.05);
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.2);
            position: relative;
        }

        .preview-placeholder {
            color: rgba(255, 255, 255, 0.3);
            font-size: 14px;
        }

        .workshop-craft-buttons {
            display: flex;
            gap: 10px;
            padding: 15px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.05);
        }

        .craft-btn,
        .auto-btn {
            flex: 1;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: #fff;
            font-family: 'Sarpanch', sans-serif;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .craft-btn:hover {
            background: rgba(46, 204, 113, 0.15);
            border-color: #2ecc71;
            color: #2ecc71;
        }

        .auto-btn:hover {
            background: rgba(255, 193, 7, 0.15);
            border-color: #ffc107;
            color: #ffc107;
        }

        .auto-btn.active {
            background: rgba(255, 193, 7, 0.25);
            border-color: #ffc107;
            color: #ffc107;
            box-shadow: 0 0 10px rgba(255, 193, 7, 0.3);
        }

        .craft-btn:disabled,
        .auto-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .workshop-materials {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .material-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            margin-bottom: 5px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .material-name {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.8);
        }

        .material-count {
            font-size: 13px;
            font-weight: 700;
        }

        .material-count.has {
            color: #2ecc71;
        }

        .material-count.missing {
            color: #ff6b6b;
        }

        .workshop-right {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .workshop-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .workshop-list-item {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            padding: 12px 15px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .workshop-list-item:hover {
            background: rgba(255, 255, 255, 0.06);
            border-color: rgba(74, 158, 255, 0.3);
        }

        .workshop-list-item.selected {
            background: rgba(74, 158, 255, 0.1);
            border-color: #4a9eff;
        }

        .workshop-list-item.crafted {
            opacity: 0.6;
        }

        .workshop-list-item.crafted::after {
            content: 'Already Crafted';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            font-weight: 900;
            color: rgba(255, 255, 255, 0.15);
            pointer-events: none;
            letter-spacing: 2px;
        }

        .item-tier {
            display: inline-block;
            padding: 2px 8px;
            background: rgba(100, 149, 237, 0.2);
            color: #6495ED;
            font-size: 11px;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .item-name {
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .item-desc {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
        }

        /* --- Inventory Panel --- */
        .inventory-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.95);
            width: 800px;
            height: 550px;
            background: rgba(10, 15, 25, 0.95);
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255, 255, 255, 0.1);
            z-index: 1500;
            display: none;
            flex-direction: column;
            font-family: 'Sarpanch', sans-serif;
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .inventory-panel.active {
            display: flex;
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }

        /* --- Aura Storage Panel --- */
        .aura-storage-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.95);
            width: 980px;
            height: min(640px, calc(100vh - 12px));
            max-width: calc(100vw - 40px);
            max-height: calc(100vh - 12px);
            background: rgba(10, 15, 25, 0.96);
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255, 255, 255, 0.1);
            z-index: 1550;
            display: none;
            flex-direction: column;
            font-family: 'Sarpanch', sans-serif;
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .aura-storage-panel.active {
            display: flex;
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }

        .aura-storage-header {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 12px 18px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.08);
            background: rgba(0, 0, 0, 0.35);
            position: relative;
        }

        .aura-storage-title {
            font-size: 42px;
            font-weight: 700;
            line-height: 1;
            letter-spacing: 1px;
            color: #fff;
            text-shadow: 0 0 16px rgba(255, 255, 255, 0.2);
        }

        .aura-storage-close {
            position: absolute;
            right: 16px;
            top: 50%;
            transform: translateY(-50%);
            border: none;
            background: none;
            color: rgba(255, 255, 255, 0.8);
            font-size: 42px;
            line-height: 1;
            cursor: pointer;
            transition: color 0.2s;
        }

        .aura-storage-close:hover {
            color: #ff6b6b;
        }

        .aura-storage-content {
            flex: 1;
            display: flex;
            overflow: hidden;
            padding: 10px;
            gap: 10px;
            min-height: 0;
        }

        .aura-storage-left {
            width: 280px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-height: 0;
            overflow: hidden;
        }

        .aura-storage-preview,
        .aura-storage-info,
        .aura-storage-actions,
        .aura-storage-upgrade {
            border: 1px solid rgba(255, 255, 255, 0.15);
            background: rgba(0, 0, 0, 0.25);
            padding: 10px;
            position: relative;
        }

        .aura-storage-preview,
        .aura-storage-actions,
        .aura-storage-upgrade {
            flex-shrink: 0;
        }

        .aura-storage-info {
            flex: 1 1 auto;
            min-height: 128px;
            overflow: hidden;
        }

        .aura-storage-preview-name {
            font-size: 26px;
            font-weight: 700;
            text-align: center;
            margin-bottom: 4px;
            word-break: break-word;
        }

        .aura-storage-preview-chance {
            text-align: center;
            color: rgba(255, 255, 255, 0.75);
            font-size: 13px;
        }

        .aura-storage-info-title {
            color: #ffffff;
            font-size: 20px;
            margin-bottom: 8px;
            line-height: 1.1;
        }

        .aura-storage-info-line {
            color: rgba(255, 255, 255, 0.86);
            font-size: 13px;
            margin-bottom: 3px;
            line-height: 1.15;
        }

        .aura-storage-action-btn,
        .aura-storage-upgrade-btn {
            width: 100%;
            height: 36px;
            margin-bottom: 6px;
            border: 1px solid rgba(255, 255, 255, 0.25);
            background: rgba(15, 25, 35, 0.65);
            color: #fff;
            font-family: 'Sarpanch', sans-serif;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .aura-storage-upgrade-btn {
            margin-bottom: 0;
        }

        .aura-storage-action-btn:last-child {
            margin-bottom: 0;
        }

        .aura-storage-action-btn:hover,
        .aura-storage-upgrade-btn:hover {
            background: rgba(40, 50, 65, 0.85);
            border-color: rgba(255, 255, 255, 0.45);
        }

        .aura-storage-action-btn.delete {
            color: #ff6b6b;
        }

        .aura-storage-action-btn.lock {
            color: #4a9eff;
        }

        .aura-storage-upgrade-title {
            text-align: center;
            font-size: 20px;
            margin-bottom: 6px;
            color: #f1c40f;
        }

        .aura-storage-upgrade-cost {
            text-align: center;
            font-size: 24px;
            color: #f1c40f;
            margin-bottom: 6px;
        }

        .aura-storage-right {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
            overflow: hidden;
            min-height: 0;
        }

        @media (max-height: 620px) {
            .aura-storage-title {
                font-size: 32px;
            }

            .aura-storage-preview-name {
                font-size: 20px;
            }

            .aura-storage-info {
                min-height: 112px;
            }

            .aura-storage-info-title {
                font-size: 18px;
                margin-bottom: 5px;
            }

            .aura-storage-info-line {
                font-size: 12px;
                margin-bottom: 2px;
            }

            .aura-storage-action-btn,
            .aura-storage-upgrade-btn {
                height: 32px;
                font-size: 18px;
            }
        }

        @media (max-height: 560px) {
            .aura-storage-panel {
                height: calc(100vh - 8px);
                max-height: calc(100vh - 8px);
            }

            .aura-storage-header {
                padding: 8px 14px;
            }

            .aura-storage-title {
                font-size: 28px;
            }

            .aura-storage-close {
                font-size: 34px;
            }

            .aura-storage-content {
                padding: 8px;
                gap: 8px;
            }

            .aura-storage-left {
                width: 250px;
                gap: 6px;
            }

            .aura-storage-preview,
            .aura-storage-info,
            .aura-storage-actions,
            .aura-storage-upgrade {
                padding: 8px;
            }

            .aura-storage-info {
                min-height: 96px;
            }

            .aura-storage-preview-name {
                font-size: 18px;
                margin-bottom: 2px;
            }

            .aura-storage-preview-chance {
                font-size: 12px;
            }

            .aura-storage-info-title {
                font-size: 15px;
                margin-bottom: 3px;
            }

            .aura-storage-info-line {
                font-size: 10px;
                margin-bottom: 1px;
                line-height: 1.1;
            }

            .aura-storage-action-btn,
            .aura-storage-upgrade-btn {
                height: 28px;
                margin-bottom: 4px;
                font-size: 16px;
            }

            .aura-storage-upgrade-title {
                font-size: 17px;
                margin-bottom: 2px;
            }

            .aura-storage-upgrade-cost {
                font-size: 20px;
                margin-bottom: 4px;
            }

            .aura-storage-tab,
            .aura-storage-search {
                height: 30px;
                font-size: 12px;
            }

            .aura-storage-grid {
                gap: 6px;
                grid-auto-rows: 54px;
            }

            .aura-storage-item {
                height: 54px;
            }
        }

        .aura-storage-tabs {
            display: flex;
            gap: 8px;
        }

        .aura-storage-tab {
            flex: 1;
            height: 34px;
            border: 1px solid rgba(255, 255, 255, 0.25);
            background: rgba(0, 0, 0, 0.25);
            color: rgba(255, 255, 255, 0.65);
            font-family: 'Sarpanch', sans-serif;
            cursor: pointer;
        }

        .aura-storage-tab.active {
            color: #fff;
            border-color: rgba(74, 158, 255, 0.65);
            background: rgba(74, 158, 255, 0.15);
        }

        .aura-storage-search {
            width: 100%;
            height: 34px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.25);
            color: #fff;
            padding: 0 10px;
            font-family: 'Sarpanch', sans-serif;
            outline: none;
        }

        .aura-storage-grid {
            flex: 1;
            overflow-y: auto;
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            grid-auto-rows: 66px;
            align-content: start;
            gap: 8px;
            padding: 4px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            background: rgba(0, 0, 0, 0.2);
        }

        .aura-storage-item {
            height: 66px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.35);
            cursor: pointer;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: 11px;
            padding: 4px;
            overflow: hidden;
            transition: all 0.15s ease;
        }

        .aura-storage-item:hover {
            transform: translateY(-1px);
            border-color: rgba(255, 255, 255, 0.45);
        }

        .aura-storage-item.selected {
            border-color: #00d4ff;
            box-shadow: 0 0 0 1px rgba(0, 212, 255, 0.4) inset;
        }

        .aura-storage-item.locked::after {
            content: 'L';
            position: absolute;
            top: 2px;
            right: 4px;
            font-size: 13px;
        }

        .aura-storage-item-name {
            font-size: 12px;
            font-weight: 700;
            line-height: 1.15;
            max-height: 2.4em;
            overflow: hidden;
        }

        .aura-storage-item-chance {
            position: absolute;
            left: 3px;
            bottom: 2px;
            font-size: 9px;
            color: rgba(255, 255, 255, 0.8);
            letter-spacing: 0.2px;
        }

        .aura-storage-empty {
            grid-column: 1 / -1;
            color: rgba(255, 255, 255, 0.5);
            text-align: center;
            align-self: center;
            justify-self: center;
            font-size: 14px;
            padding: 20px;
        }

        .aura-storage-action-btn:disabled,
        .aura-storage-upgrade-btn:disabled {
            opacity: 0.45;
            cursor: not-allowed;
        }

        .inventory-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
            background: rgba(0, 0, 0, 0.3);
        }

        .inventory-title {
            font-size: 24px;
            font-weight: 700;
            color: #fff;
        }

        .inventory-close {
            background: none;
            border: none;
            color: #fff;
            font-size: 28px;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .inventory-close:hover {
            opacity: 1;
        }

        .inventory-tabs {
            display: flex;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
        }

        .inventory-tab {
            flex: 1;
            padding: 12px;
            background: rgba(255, 255, 255, 0.03);
            border: none;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.5);
            font-family: 'Sarpanch', sans-serif;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .inventory-tab:last-child {
            border-right: none;
        }

        .inventory-tab.active {
            background: rgba(255, 255, 255, 0.08);
            color: #fff;
        }

        .inventory-content {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .inventory-left {
            width: 200px;
            border-right: 2px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
        }

        .character-preview {
            width: 100%;
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 15px;
            position: relative;
        }

        .character-preview::before {
            content: '@';
            font-size: 60px;
            color: rgba(255, 255, 255, 0.3);
        }

        .equipped-slots {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .equipped-slot {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.15);
            padding: 12px;
            position: relative;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 96px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .equipped-slot .corner {
            width: 8px;
            height: 8px;
        }

        .equipped-slot:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .equipped-slot-label {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.4);
            margin-bottom: 4px;
        }

        .equipped-slot-name {
            font-size: 12px;
            font-weight: 600;
            color: #fff;
        }

        .equipped-slot-effects {
            margin-top: 6px;
            font-size: 10px;
            line-height: 1.25;
            color: rgba(255, 255, 255, 0.82);
            white-space: normal;
            word-break: break-word;
        }

        .equipped-slot-desc {
            margin-top: 5px;
            font-size: 9px;
            line-height: 1.25;
            color: rgba(255, 255, 255, 0.55);
            white-space: normal;
            word-break: break-word;
        }

        .equipped-slot.empty .equipped-slot-name {
            color: rgba(255, 255, 255, 0.3);
        }

        .equipped-slot.empty .equipped-slot-effects,
        .equipped-slot.empty .equipped-slot-desc {
            color: rgba(255, 255, 255, 0.3);
        }

        .inventory-right {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .inventory-search {
            padding: 10px 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .inventory-search input {
            width: 100%;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #fff;
            padding: 8px 12px;
            font-family: 'Sarpanch', sans-serif;
            font-size: 14px;
            outline: none;
        }

        .inventory-search input::placeholder {
            color: rgba(255, 255, 255, 0.3);
        }

        .inventory-gear-list {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }

        .gear-section-title {
            font-size: 16px;
            font-weight: 700;
            color: #fff;
            margin-bottom: 10px;
            text-align: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .gear-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
            margin-bottom: 20px;
        }

        .gear-item {
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.15);
            position: relative;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 8px;
            text-align: center;
        }

        .gear-item .corner {
            width: 6px;
            height: 6px;
        }

        .gear-item:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(74, 158, 255, 0.5);
        }

        .gear-item.equipped {
            background: rgba(46, 204, 113, 0.15);
            border-color: #2ecc71;
        }

        .gear-item-name {
            font-size: 10px;
            font-weight: 600;
            margin-bottom: 4px;
            line-height: 1.2;
        }

        .gear-item-count {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
        }

        .inventory-btn {
            position: fixed;
            bottom: 180px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: rgba(10, 15, 25, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.15);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Sarpanch', sans-serif;
            font-size: 20px;
            color: #fff;
            transition: all 0.2s;
            z-index: 100;
        }

        .inventory-btn:hover {
            background: rgba(74, 158, 255, 0.15);
            border-color: #4a9eff;
        }

        /* --- UI Component Styles --- */

        /* Game Info HUD */
        .game-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-family: 'Sarpanch', sans-serif;
            z-index: 20;
            display: flex;
            flex-direction: column;
            gap: 2px;
            pointer-events: none;
        }

        .version {
            font-size: 16px;
            color: rgba(255, 255, 255, 0.5);
            font-weight: 500;
        }

        .biome {
            font-size: 20px;
            color: rgba(100, 149, 237, 0.6);
            font-weight: 600;
        }

        .time {
            font-size: 22px;
            color: rgba(255, 215, 0, 0.6);
            font-weight: 700;
        }

        /* Aura Log Panel */
        .aura-log-panel {
            width: 350px;
            max-height: 250px;
            background: rgba(10, 15, 25, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            font-family: 'Sarpanch', sans-serif;
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
        }

        .aura-log-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px 8px 0 0;
        }

        .aura-log-title {
            font-size: 14px;
            color: #7efff5;
            font-weight: 600;
        }

        .aura-log-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .aura-log-controls select {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: #fff;
            padding: 4px 8px;
            font-size: 11px;
            font-family: 'Sarpanch', sans-serif;
            cursor: pointer;
        }

        .aura-log-toggle {
            background: none;
            border: none;
            color: #888;
            font-size: 16px;
            cursor: pointer;
            padding: 0 5px;
        }

        .aura-log-toggle:hover {
            color: #fff;
        }

        .aura-log-content {
            max-height: 220px;
            overflow-y: auto;
            padding: 8px 12px;
            font-size: 12px;
        }

        .aura-log-content.collapsed {
            display: none;
        }

        .aura-log-username-row {
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.05);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .aura-log-username-row input {
            width: 100%;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #00ffaa;
            padding: 4px 8px;
            font-size: 11px;
            font-family: 'Sarpanch', sans-serif;
            border-radius: 4px;
        }

        .aura-log-username-row input:focus {
            outline: none;
            border-color: #00ffaa;
            background: rgba(0, 0, 0, 0.5);
        }

        .aura-log-options-row {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 6px 12px;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .aura-log-checkbox {
            display: flex;
            align-items: center;
            gap: 4px;
            cursor: pointer;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.6);
        }

        .aura-log-checkbox input {
            width: 12px;
            height: 12px;
            cursor: pointer;
        }

        .aura-log-checkbox:hover span {
            color: #fff;
        }

        .aura-log-clear-btn {
            margin-left: auto;
            background: rgba(255, 0, 0, 0.2);
            border: 1px solid rgba(255, 0, 0, 0.3);
            border-radius: 4px;
            padding: 2px 8px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .aura-log-clear-btn:hover {
            background: rgba(255, 0, 0, 0.4);
            border-color: rgba(255, 0, 0, 0.6);
        }

        .aura-log-stats-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 12px;
            background: rgba(0, 0, 0, 0.15);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
        }

        .aura-log-stat strong {
            color: #00d4ff;
        }

        .aura-log-entry {
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            line-height: 1.4;
        }

        .aura-log-entry:last-child {
            border-bottom: none;
        }

        .aura-log-player {
            color: #00ffaa;
        }

        .aura-log-action {
            color: #aaa;
        }

        .aura-log-aura {
            font-weight: 600;
        }

        .aura-log-chance {
            font-weight: 600;
        }

        /* Aura log rarity colors */
        .aura-log-rarity-blue {
            color: #00d4ff;
        }

        .aura-log-rarity-purple {
            color: #a855f7;
        }

        .aura-log-rarity-darkblue {
            color: #4169e1;
        }

        .aura-log-rarity-magenta {
            color: #ff00ff;
        }

        .aura-log-rarity-transcendent {
            color: #ffd700;
            text-shadow: 0 0 10px #ffd700;
            font-weight: 700;
        }

        .aura-log-rarity-common {
            color: rgba(255, 255, 255, 0.7);
        }

        /* Admin Panel */
        .admin-panel {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1600;
            min-width: 600px;
            max-width: 90vw;
            font-family: 'Sarpanch', sans-serif;
        }

        .admin-panel.active {
            display: block;
        }

        .admin-panel-inner {
            background: rgba(10, 15, 25, 0.98);
            backdrop-filter: blur(25px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            box-shadow: 0 30px 80px rgba(0, 0, 0, 0.9);
        }

        .admin-panel-inner.chromatic-crusher-rgb {
            border-color: rgba(255, 255, 255, 0.45);
            box-shadow:
                0 30px 80px rgba(0, 0, 0, 0.9),
                0 0 26px rgba(255, 0, 128, 0.28),
                0 0 34px rgba(0, 180, 255, 0.24);
            animation: chromatic-admin-hueshift 0.32s linear infinite;
        }

        .admin-panel-inner.chromatic-crusher-rgb .admin-header {
            border-bottom-color: rgba(255, 255, 255, 0.22);
            box-shadow: inset 0 -1px 0 rgba(255, 255, 255, 0.08);
        }

        .admin-title.chromatic-crusher-rgb-text {
            color: #fff;
            text-shadow:
                0 0 10px rgba(255, 0, 120, 0.8),
                0 0 14px rgba(0, 200, 255, 0.8),
                0 0 18px rgba(120, 255, 120, 0.6);
            animation: chromatic-admin-title-flicker 0.22s steps(2, end) infinite;
        }

        @keyframes chromatic-admin-hueshift {
            0% { filter: saturate(1.7) hue-rotate(0deg); }
            100% { filter: saturate(1.7) hue-rotate(360deg); }
        }

        @keyframes chromatic-admin-title-flicker {
            0%, 100% { opacity: 0.86; }
            50% { opacity: 1; }
        }

        .admin-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .admin-title {
            font-size: 18px;
            font-weight: 600;
            color: #6495ED;
            letter-spacing: 1px;
        }

        /* Tabs styling */
        .admin-tabs {
            display: flex;
            background: rgba(0, 0, 0, 0.2);
        }

        .admin-tab {
            flex: 1;
            padding: 10px 6px;
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.4);
            cursor: pointer;
            font-family: 'Sarpanch', sans-serif;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: all 0.2s;
            border-bottom: 2px solid transparent;
        }

        .admin-tab:hover {
            color: #fff;
            background: rgba(255, 255, 255, 0.05);
        }

        .admin-tab.active {
            color: #6495ED;
            border-bottom-color: #6495ED;
            background: rgba(100, 149, 237, 0.1);
        }

        /* Tab-specific active colors */
        .admin-tab[data-tab="items"].active {
            color: #2ecc71;
            border-bottom-color: #2ecc71;
            background: rgba(46, 204, 113, 0.1);
        }

        .admin-tab[data-tab="player"].active {
            color: #9b59b6;
            border-bottom-color: #9b59b6;
            background: rgba(155, 89, 182, 0.1);
        }

        .admin-tab[data-tab="testing"].active {
            color: #e74c3c;
            border-bottom-color: #e74c3c;
            background: rgba(231, 76, 60, 0.1);
        }

        .admin-tab[data-tab="danger"].active {
            color: #ff6b6b;
            border-bottom-color: #ff6b6b;
            background: rgba(255, 107, 107, 0.15);
        }

        .admin-tab[data-tab="danger"] {
            color: rgba(255, 107, 107, 0.6);
        }

        .admin-tab[data-tab="danger"]:hover {
            color: #ff6b6b;
            background: rgba(255, 107, 107, 0.1);
        }

        /* Admin Panel Sections */
        .admin-section {
            padding: 15px 20px;
            max-height: 70vh;
            overflow-y: auto;
        }

        .admin-section-title {
            font-size: 14px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 15px;
            text-align: center;
        }

        /* Biome Grid */
        .biome-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .biome-btn {
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            font-family: 'Sarpanch', sans-serif;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .biome-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-1px);
        }

        .biome-btn.active {
            border-width: 2px;
        }

        /* Biome-specific colors */
        .biome-btn[data-biome="NORMAL"] {
            color: #6495ED;
            border-color: #6495ED;
        }

        .biome-btn[data-biome="NORMAL"].active {
            background: rgba(100, 149, 237, 0.2);
        }

        .biome-btn[data-biome="WINDY"] {
            color: #dff9fb;
            border-color: #dff9fb;
        }

        .biome-btn[data-biome="WINDY"].active {
            background: rgba(223, 249, 251, 0.2);
        }

        .biome-btn[data-biome="SNOWY"] {
            color: #b8c5d0;
            border-color: #b8c5d0;
        }

        .biome-btn[data-biome="SNOWY"].active {
            background: rgba(184, 197, 208, 0.2);
        }

        .biome-btn[data-biome="RAINY"] {
            color: #3d5a6e;
            border-color: #74b9ff;
        }

        .biome-btn[data-biome="RAINY"].active {
            background: rgba(116, 185, 255, 0.2);
        }

        .biome-btn[data-biome="SANDSTORM"] {
            color: #c4a574;
            border-color: #c4a574;
        }

        .biome-btn[data-biome="SANDSTORM"].active {
            background: rgba(196, 165, 116, 0.2);
        }

        .biome-btn[data-biome="HELL"] {
            color: #ff4444;
            border-color: #ff4444;
        }

        .biome-btn[data-biome="HELL"].active {
            background: rgba(255, 68, 68, 0.2);
        }

        .biome-btn[data-biome="STARFALL"] {
            color: #7c6aef;
            border-color: #1a1a5e;
            background: linear-gradient(135deg, rgba(26, 26, 94, 0.3), rgba(124, 106, 239, 0.1));
        }

        .biome-btn[data-biome="STARFALL"].active {
            background: linear-gradient(135deg, rgba(26, 26, 94, 0.5), rgba(124, 106, 239, 0.3));
        }

        .biome-btn[data-biome="HEAVEN"] {
            color: #f5d742;
            border-color: #daa520;
            background: linear-gradient(135deg, rgba(245, 230, 211, 0.2), rgba(255, 215, 0, 0.1));
        }

        .biome-btn[data-biome="HEAVEN"].active {
            background: linear-gradient(135deg, rgba(245, 230, 211, 0.4), rgba(255, 215, 0, 0.3));
        }

        .biome-btn[data-biome="CORRUPTION"] {
            color: #9b59b6;
            border-color: #3d1a78;
            background: linear-gradient(135deg, rgba(61, 26, 120, 0.3), rgba(155, 89, 182, 0.1));
        }

        .biome-btn[data-biome="CORRUPTION"].active {
            background: linear-gradient(135deg, rgba(61, 26, 120, 0.5), rgba(155, 89, 182, 0.3));
        }

        .biome-btn[data-biome="NULL"] {
            color: #a0a0a0;
            border-color: #808080;
            background: linear-gradient(135deg, rgba(160, 160, 160, 0.2), rgba(255, 255, 255, 0.1));
        }

        .biome-btn[data-biome="NULL"].active {
            background: linear-gradient(135deg, rgba(160, 160, 160, 0.4), rgba(255, 255, 255, 0.3));
        }

        .biome-btn[data-biome="GLITCHED"] {
            color: #00ffaa;
            border-color: #00ffaa;
            background: linear-gradient(135deg, rgba(0, 20, 20, 0.4), rgba(0, 255, 170, 0.1));
            box-shadow: 0 0 5px rgba(0, 255, 170, 0.3);
            animation: glitch-btn 0.5s infinite alternate;
        }

        .biome-btn[data-biome="DREAMSPACE"] {
            color: #ff9ff3;
            border-color: #ff9ff3;
            background: linear-gradient(135deg, rgba(255, 159, 243, 0.1), rgba(190, 46, 221, 0.1));
            box-shadow: 0 0 5px rgba(255, 159, 243, 0.3);
        }

        .biome-btn[data-biome="CYBERSPACE"] {
            color: #00ffff;
            border-color: #00ffff;
            background: rgba(0, 20, 40, 0.5);
            box-shadow: 0 0 5px rgba(0, 255, 255, 0.4);
            text-shadow: 0 0 2px #00ffff;
        }

        .biome-btn[data-biome="CYBERSPACE"]:hover {
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.6);
        }

        .biome-btn[data-biome="PUMPKIN MOON"] {
            color: #ff9f43;
            border-color: #ff9f43;
            background: linear-gradient(to right, rgba(255, 159, 67, 0.1), rgba(100, 0, 150, 0.2));
            box-shadow: 0 0 5px rgba(255, 159, 67, 0.3);
        }

        .biome-btn[data-biome="GRAVEYARD"] {
            color: #bdc3c7;
            border-color: #bdc3c7;
            background: rgba(44, 62, 80, 0.4);
            box-shadow: 0 0 3px rgba(189, 195, 199, 0.2);
        }

        .biome-btn[data-biome="BLOOD RAIN"] {
            color: #ff4757;
            border-color: #ff4757;
            background: rgba(40, 0, 0, 0.5);
            box-shadow: 0 0 8px rgba(255, 71, 87, 0.4);
            animation: pulse-red 2s infinite;
        }

        .biome-btn[data-biome="BLAZING SUN"] {
            color: #f1c40f;
            border-color: #f1c40f;
            background: rgba(50, 30, 0, 0.5);
            box-shadow: 0 0 8px rgba(241, 196, 15, 0.4);
            text-shadow: 0 0 2px #e67e22;
        }

        .biome-btn[data-biome="AURORA"] {
            color: #55efc4;
            border-color: #55efc4;
            background: linear-gradient(90deg, rgba(85, 239, 196, 0.1), rgba(162, 155, 254, 0.1));
            box-shadow: 0 0 5px rgba(85, 239, 196, 0.3);
            text-shadow: 0 0 2px rgba(85, 239, 196, 0.5);
        }

        @keyframes glitch-btn {

            0%,
            100% {
                text-shadow: 0 0 2px #00ffaa;
                opacity: 1;
            }

            50% {
                opacity: 0.8;
            }

            52% {
                text-shadow: -2px 0 #ff0055, 2px 0 #00ffaa;
                transform: translate(1px, 0);
            }

            54% {
                text-shadow: 2px 0 #ff0055, -2px 0 #00ffaa;
                transform: translate(-1px, 0);
            }
        }

        @keyframes pulse-red {

            0%,
            100% {
                box-shadow: 0 0 5px rgba(255, 71, 87, 0.4);
            }

            50% {
                box-shadow: 0 0 12px rgba(255, 71, 87, 0.7);
            }
        }

        @keyframes glitch-text {

            0%,
            100% {
                transform: translate(0);
                text-shadow: -2px 0 #ff0055, 2px 0 #00ffaa, 0 0 10px #00ffaa;
            }

            20% {
                transform: translate(-2px, 1px);
                text-shadow: 2px 0 #ff0055, -2px 0 #00ffaa, 0 0 15px #00ffaa;
            }

            40% {
                transform: translate(2px, -1px);
                text-shadow: -1px 0 #ff0055, 3px 0 #00ffaa, 0 0 8px #00ffaa;
            }

            60% {
                transform: translate(-1px, 2px);
                text-shadow: 3px 0 #ff0055, -1px 0 #00ffaa, 0 0 12px #00ffaa;
            }

            80% {
                transform: translate(1px, -2px);
                text-shadow: -3px 0 #ff0055, 1px 0 #00ffaa, 0 0 20px #00ffaa;
            }
        }

        .biome-btn[data-biome="GLITCHED"].active {
            background: linear-gradient(135deg, rgba(0, 40, 40, 0.5), rgba(0, 255, 170, 0.2));
        }

        .biome-btn[data-biome="DREAMSPACE"] {
            color: #ff6bcb;
            border-color: #e056fd;
            background: linear-gradient(135deg, rgba(224, 86, 253, 0.2), rgba(255, 107, 203, 0.1));
        }

        .biome-btn[data-biome="DREAMSPACE"].active {
            background: linear-gradient(135deg, rgba(224, 86, 253, 0.4), rgba(255, 107, 203, 0.3));
        }

        .biome-btn[data-biome="AURORA"] {
            color: #7efff5;
            border-color: #7efff5;
            background: linear-gradient(135deg, rgba(126, 255, 180, 0.1), rgba(100, 200, 255, 0.1), rgba(180, 100, 255, 0.1));
        }

        .biome-btn[data-biome="AURORA"].active {
            background: linear-gradient(135deg, rgba(126, 255, 180, 0.3), rgba(100, 200, 255, 0.3), rgba(180, 100, 255, 0.3));
        }

        /* Time Controls */
        .time-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .time-option {
            flex: 1;
            padding: 10px 15px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.6);
            font-family: 'Sarpanch', sans-serif;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .time-option:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }

        .time-option.active {
            background: rgba(100, 149, 237, 0.2);
            border-color: #6495ED;
            color: #fff;
        }

        #time-day.active {
            background: rgba(255, 200, 50, 0.2);
            border-color: #ffc832;
            color: #ffc832;
        }

        #time-night.active {
            background: rgba(100, 149, 237, 0.2);
            border-color: #6495ED;
            color: #a8c8ff;
        }

        /* Time Info Row */
        .time-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .time-label {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.7);
        }

        .time-toggle {
            padding: 6px 16px;
            background: rgba(46, 204, 113, 0.2);
            border: 1px solid #2ecc71;
            color: #2ecc71;
            font-family: 'Sarpanch', sans-serif;
            font-size: 12px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
        }

        .time-toggle:hover {
            background: rgba(46, 204, 113, 0.3);
        }

        .time-toggle.off {
            background: rgba(255, 107, 107, 0.2);
            border-color: #ff6b6b;
            color: #ff6b6b;
        }

        .time-toggle.off:hover {
            background: rgba(255, 107, 107, 0.3);
        }

        /* Debug Info */
        .debug-info {
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        /* Admin Gear Grid */
        .admin-gear-search {
            margin-bottom: 10px;
        }

        .admin-gear-search input {
            width: 100%;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #fff;
            font-family: 'Sarpanch', sans-serif;
            font-size: 13px;
        }

        .admin-gear-search input::placeholder {
            color: rgba(255, 255, 255, 0.3);
        }

        .admin-gear-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            max-height: 200px;
            overflow-y: auto;
            padding: 5px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .admin-gear-btn {
            padding: 5px 10px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            font-family: 'Sarpanch', sans-serif;
            font-size: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .admin-gear-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-1px);
        }

        .admin-gear-btn.owned {
            opacity: 0.5;
        }

        .admin-gear-btn.owned::after {
            content: '✓';
            position: absolute;
            top: -4px;
            right: -4px;
            background: #2ecc71;
            color: #fff;
            font-size: 8px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Admin Materials Row */
        .admin-materials-row {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .admin-materials-row input {
            flex: 1;
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #fff;
            font-family: 'Sarpanch', sans-serif;
            font-size: 12px;
        }

        .admin-materials-row input::placeholder {
            color: rgba(255, 255, 255, 0.3);
        }

        .admin-materials-row input[type="number"] {
            width: 80px;
            flex: none;
        }

        .admin-give-btn {
            padding: 8px 16px;
            background: rgba(46, 204, 113, 0.2);
            border: 1px solid #2ecc71;
            color: #2ecc71;
            font-family: 'Sarpanch', sans-serif;
            font-size: 12px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
        }

        .admin-give-btn:hover {
            background: rgba(46, 204, 113, 0.3);
        }

        /* Settings Panel Styling */
        .settings-panel {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1500;
            width: 650px;
            background: rgba(10, 15, 25, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 4px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 1);
            font-family: 'Sarpanch', sans-serif;
            color: #fff;
        }

        .settings-panel.active {
            display: block;
        }

        .settings-header {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 12px 20px;
            position: relative;
        }

        .settings-title {
            font-size: 22px;
            font-weight: 500;
            letter-spacing: 1px;
        }

        .settings-close,
        .admin-close {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            font-size: 24px;
            cursor: pointer;
            transition: color 0.2s;
        }

        .settings-close:hover,
        .admin-close:hover {
            color: #ff6b6b;
        }

        /* Settings Tabs */
        .settings-tabs {
            display: flex;
            padding: 0 10px;
            gap: 5px;
            margin-bottom: 10px;
        }

        .settings-tab {
            flex: 1;
            height: 40px;
            position: relative;
            background: rgba(40, 45, 55, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.4);
            font-family: 'Sarpanch', sans-serif;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .settings-tab.active {
            color: #fff;
            background: rgba(60, 65, 75, 0.7);
        }

        .settings-tab .corner {
            border-color: currentColor;
            opacity: 0;
        }

        .settings-tab.active .corner {
            opacity: 1;
        }

        .tab-rolling.active {
            color: #f1c40f;
            border-color: rgba(241, 196, 15, 0.5);
        }

        .tab-notifications.active {
            color: #3498db;
            border-color: rgba(52, 152, 219, 0.5);
        }

        .tab-misc.active {
            color: #9b59b6;
            border-color: rgba(155, 89, 182, 0.5);
        }

        .tab-sfx.active {
            color: #2ecc71;
            border-color: rgba(46, 204, 113, 0.5);
        }

        .settings-content {
            padding: 10px 15px 20px 15px;
            max-height: 400px;
            overflow-y: auto;
        }

        .settings-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }

        .setting-row {
            background: rgba(20, 25, 35, 0.4);
            padding: 10px 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: relative;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .setting-row.full-width {
            grid-column: span 2;
        }

        .setting-label {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.9);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .setting-input-number {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 4px 8px;
            width: 150px;
            text-align: right;
            font-family: inherit;
        }

        .setting-checkbox {
            appearance: none;
            width: 20px;
            height: 20px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.3);
            cursor: pointer;
            position: relative;
        }

        .setting-checkbox:checked {
            background: #fff;
        }

        .setting-checkbox:checked::after {
            content: '✓';
            color: #000;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
        }

        .setting-slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
        }

        .setting-slider {
            flex: 1;
            appearance: none;
            height: 3px;
            background: rgba(255, 255, 255, 0.1);
            cursor: pointer;
        }

        .setting-slider::-webkit-slider-thumb {
            appearance: none;
            width: 12px;
            height: 12px;
            background: #fff;
            border-radius: 50%;
        }

        .setting-value-badge {
            min-width: 40px;
            text-align: right;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
        }

        .setting-row .corner {
            border-color: rgba(255, 255, 255, 0.2);
        }

        /* Notifications */
        .notification-container {
            position: fixed;
            bottom: 20px;
            left: 20px;
            display: flex;
            flex-direction: column-reverse;
            gap: 8px;
            z-index: 2000;
            pointer-events: none;
        }

        .notification {
            background: rgba(10, 15, 25, 0.85);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #fff;
            padding: 8px 15px;
            font-family: 'Sarpanch', sans-serif;
            font-size: 13px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 10px;
            animation: notif-slide-in 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards;
            position: relative;
            overflow: hidden;
            min-width: 200px;
        }

        .notification .corner {
            width: 6px;
            height: 6px;
            border-color: rgba(255, 255, 255, 0.3);
        }

        @keyframes notif-slide-in {
            from {
                opacity: 0;
                transform: translateX(-30px);
            }

            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .notification.fade-out {
            animation: notif-fade-out 0.5s ease forwards;
        }

        @keyframes notif-fade-out {
            to {
                opacity: 0;
                transform: translateY(-10px);
            }
        }

        .notif-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 2px;
            background: #fff;
            width: 100%;
            animation: notif-progress 3s linear forwards;
        }

        @keyframes notif-progress {
            from {
                width: 100%;
            }

            to {
                width: 0%;
            }
        }

        /* ================================= */
        /* PERFORMANCE MONITOR STYLES        */
        /* ================================= */
        #perf-monitor {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid rgba(46, 204, 113, 0.5);
            border-radius: 8px;
            padding: 10px 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #fff;
            z-index: 999999;
            min-width: 180px;
            opacity: 0;
            pointer-events: none;
            transform: translateY(-10px);
            transition: opacity 0.2s, transform 0.2s;
        }

        #perf-monitor.visible {
            opacity: 1;
            pointer-events: auto;
            transform: translateY(0);
        }

        .perf-title {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding-bottom: 5px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            font-weight: bold;
            color: #2ecc71;
        }

        .perf-close {
            cursor: pointer;
            opacity: 0.7;
        }

        .perf-close:hover {
            opacity: 1;
        }

        .perf-row {
            display: flex;
            justify-content: space-between;
            margin: 3px 0;
        }

        .perf-label {
            color: #aaa;
        }

        .perf-value {
            font-weight: bold;
        }

        .perf-value.good {
            color: #2ecc71;
        }

        .perf-value.warning {
            color: #f1c40f;
        }

        .perf-value.bad {
            color: #e74c3c;
        }

        .perf-graph {
            height: 30px;
            margin-top: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            display: flex;
            align-items: flex-end;
        }

        .perf-graph-bar {
            width: 5px;
            margin-right: 1px;
            border-radius: 1px 1px 0 0;
            transition: height 0.2s;
        }

        .perf-toggle-btn {
            position: fixed;
            top: 10px;
            right: 200px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(46, 204, 113, 0.5);
            color: #2ecc71;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            z-index: 999998;
        }

        .perf-toggle-btn:hover {
            background: rgba(46, 204, 113, 0.2);
        }

        .perf-maxfps-btn {
            width: 100%;
            margin-top: 8px;
            padding: 6px 10px;
            background: rgba(231, 76, 60, 0.3);
            border: 1px solid #e74c3c;
            color: #e74c3c;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            font-weight: bold;
            transition: all 0.2s;
        }

        .perf-maxfps-btn:hover {
            background: rgba(231, 76, 60, 0.5);
        }
    </style>

</head>

<body>


    <!-- 3D Perspective Background -->
    <div id="perspective-grid-container">
        <div id="perspective-grid"></div>
        <div id="lighting-overlay"></div>
    </div>
    <div id="biome-overlay"></div>
    <div id="weather-container"></div>
    <div class="dim-overlay"></div>
    <div class="notification-container" id="notification-container"></div>

    <div class="roll-overlay" id="roll-overlay">
        <div class="overlay-name" id="overlay-name">AURA NAME</div>
        <div class="overlay-chance" id="overlay-chance">1 in X</div>
    </div>
    <div class="storage-full-popup" id="storage-full-popup">
        <div class="storage-full-title">Aura Storage Full</div>
        <div class="storage-full-desc" id="storage-full-desc">
            Storage is full. Replace your most recent aura, or discard the aura you just rolled.
        </div>
        <div class="storage-full-actions">
            <button class="storage-full-btn replace" id="storage-full-replace-btn">Replace Most Recent</button>
            <button class="storage-full-btn discard" id="storage-full-discard-btn">Delete Rolled Aura</button>
        </div>
    </div>

    <!-- Video Cutscene Overlay -->
    <div id="video-cutscene-overlay"
        style="display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: #000; z-index: 9999; justify-content: center; align-items: center; margin: 0; padding: 0; overflow: hidden; contain: strict; will-change: opacity;">
        <video id="cutscene-video"
            style="width: 100vw; height: 100vh; object-fit: cover; margin: 0; padding: 0; transform: translateZ(0);"
            preload="auto" playsinline disablepictureinpicture x-webkit-airplay="deny">
            Your browser does not support video playback.
        </video>
        <div id="cutscene-flash"
            style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #fff; opacity: 0; pointer-events: none; will-change: opacity;">
        </div>
    </div>


    <!-- Menu Overlay (background dimmer) -->
    <div class="menu-overlay" id="menu-overlay"></div>

    <!-- Menu Panel -->
    <div class="menu-panel" id="menu-panel">
        <div class="menu-header">
            <span class="menu-title">Menu</span>
            <button class="menu-close" id="menu-close">X</button>
        </div>
        <div class="menu-items">
            <!-- Season Pass -->
            <button class="menu-item premium" data-action="season-pass">
                <div class="menu-item-watermark">*</div>
                <span class="menu-item-text">Season Pass</span>
            </button>

            <!-- Achievements -->
            <button class="menu-item" data-action="achievements">
                <div class="menu-item-watermark">*</div>
                <span class="menu-item-text">Achievements</span>
            </button>

            <!-- Fishing -->
            <button class="menu-item" data-action="fishing">
                <div class="menu-item-watermark">F</div>
                <span class="menu-item-text">Fishing</span>
            </button>

            <!-- Settings -->
            <button class="menu-item" data-action="settings">
                <div class="menu-item-watermark">S</div>
                <span class="menu-item-text">Settings</span>
            </button>

            <!-- Robux Shop -->
            <button class="menu-item" data-action="shop">
                <div class="menu-item-watermark">$</div>
                <span class="menu-item-text">Robux Shop</span>
            </button>

            <!-- Developers -->
            <button class="menu-item" data-action="developers">
                <div class="menu-item-watermark">D</div>
                <span class="menu-item-text">Developers</span>
            </button>
        </div>
    </div>

    <!-- Game Info HUD -->
    <div class="game-info">
        <div class="version">v4.588</div>
        <div class="biome">[ NORMAL ]</div>
        <div class="time">DAYTIME</div>
        <div class="current-aura-hud" id="current-aura-hud"
            style="font-size: 18px; margin-top: 5px; color: #fff; text-shadow: 0 0 10px rgba(255,255,255,0.5);">
            Aura: None</div>
    </div>

    <!-- Admin Button (Fixed Top Left) -->
    <button class="admin-btn" id="admin-btn">
        <div class="corner tl"></div>
        <div class="corner tr"></div>
        <div class="corner bl"></div>
        <div class="corner br"></div>
        <span>Admin</span>
    </button>

    <!-- Left Sidebar Container -->
    <div class="left-sidebar">
        <!-- Aura Log Panel -->
        <div class="aura-log-panel" id="aura-log-panel">
            <div class="aura-log-header">
                <span class="aura-log-title">Aura Log</span>
                <div class="aura-log-controls">
                    <select id="aura-log-threshold" title="Minimum rarity to display">
                        <option value="0">All</option>
                        <option value="100">100+</option>
                        <option value="1000">1k+</option>
                        <option value="10000">10k+</option>
                        <option value="100000" selected>100k+</option>
                        <option value="1000000">1M+</option>
                        <option value="10000000">10M+</option>
                        <option value="100000000">100M+</option>
                        <option value="1000000000">1B+</option>
                    </select>
                    <button class="aura-log-toggle" id="aura-log-toggle">-</button>
                </div>
            </div>
            <div class="aura-log-options-row">
                <label class="aura-log-checkbox">
                    <input type="checkbox" id="aura-log-native-only">
                    <span>Native Only</span>
                </label>
                <label class="aura-log-checkbox">
                    <input type="checkbox" id="aura-log-show-biome" checked>
                    <span>Show Biome</span>
                </label>
                <button class="aura-log-clear-btn" id="aura-log-clear" title="Clear Log">Clear</button>
            </div>
            <div class="aura-log-username-row">
                <input type="text" id="aura-log-username" placeholder="@Player" value="@Player" maxlength="20">
            </div>
            <div class="aura-log-stats-row" id="aura-log-stats">
                <span class="aura-log-stat">Logged: <strong id="aura-log-count">0</strong></span>
                <span class="aura-log-stat" id="aura-log-biome-display"></span>
            </div>
            <div class="aura-log-content" id="aura-log-content">
                <!-- Log messages will appear here -->
            </div>
        </div>


        <!-- Menu Button -->
        <button class="menu-btn" id="menu-btn" onclick="toggleMenu()" aria-label="Open menu">
            <div class="corner tl"></div>
            <div class="corner tr"></div>
            <div class="corner bl"></div>
            <div class="corner br"></div>
            <i class="fa-solid fa-bars sidebar-icon" aria-hidden="true"></i>
        </button>

        <!-- Items/Workshop Button -->
        <button class="items-btn" id="items-btn" aria-label="Open workshop">
            <div class="corner tl"></div>
            <div class="corner tr"></div>
            <div class="corner bl"></div>
            <div class="corner br"></div>
            <i class="fa-solid fa-hammer sidebar-icon" aria-hidden="true"></i>
        </button>

        <!-- Inventory Button -->
        <button class="inventory-btn" id="inventory-btn" aria-label="Open inventory">
            <div class="corner tl"></div>
            <div class="corner tr"></div>
            <div class="corner bl"></div>
            <div class="corner br"></div>
            <i class="fa-solid fa-box-open sidebar-icon" aria-hidden="true"></i>
        </button>

        <!-- Aura Storage Button -->
        <button class="storage-btn" id="storage-btn" title="Aura Storage" aria-label="Open aura storage">
            <div class="corner tl"></div>
            <div class="corner tr"></div>
            <div class="corner bl"></div>
            <div class="corner br"></div>
            <i class="fa-solid fa-boxes-stacked sidebar-icon" aria-hidden="true"></i>
        </button>
    </div>

    <!-- Aura Storage Panel Modal -->
    <div class="aura-storage-panel" id="aura-storage-panel">
        <div class="aura-storage-header">
            <span class="aura-storage-title">Aura Storage</span>
            <button class="aura-storage-close" id="aura-storage-close">&times;</button>
        </div>

        <div class="aura-storage-content">
            <div class="aura-storage-left">
                <div class="aura-storage-preview">
                    <div class="aura-storage-preview-name" id="aura-storage-preview-name">No Aura Selected</div>
                    <div class="aura-storage-preview-chance" id="aura-storage-preview-chance">1/1</div>
                </div>

                <div class="aura-storage-info">
                    <div class="aura-storage-info-title">[ Information ]</div>
                    <div class="aura-storage-info-line" id="aura-storage-info-rolls">Rolled at: -</div>
                    <div class="aura-storage-info-line" id="aura-storage-info-luck">With luck of: -</div>
                    <div class="aura-storage-info-line" id="aura-storage-info-time">Time Discovered: -</div>
                    <div class="aura-storage-info-line" id="aura-storage-info-biome">Biome: -</div>
                </div>

                <div class="aura-storage-actions">
                    <button class="aura-storage-action-btn" id="aura-storage-equip-btn">Equip</button>
                    <button class="aura-storage-action-btn delete" id="aura-storage-delete-btn">Delete</button>
                    <button class="aura-storage-action-btn lock" id="aura-storage-lock-btn">Lock</button>
                </div>

                <div class="aura-storage-upgrade">
                    <div class="aura-storage-upgrade-title">[ Storage Upgrade ]</div>
                    <div class="aura-storage-upgrade-cost" id="aura-storage-upgrade-cost">0 Coins</div>
                    <button class="aura-storage-upgrade-btn" id="aura-storage-upgrade-btn">Upgrade</button>
                </div>
            </div>

            <div class="aura-storage-right">
                <div class="aura-storage-tabs">
                    <button class="aura-storage-tab active" id="aura-storage-tab-regular" data-tab="regular">Regular</button>
                    <button class="aura-storage-tab" id="aura-storage-tab-special" data-tab="special">Special</button>
                </div>
                <input type="text" class="aura-storage-search" id="aura-storage-search" placeholder="Search...">
                <div class="aura-storage-grid" id="aura-storage-grid"></div>
            </div>
        </div>
    </div>

    <!-- Inventory Panel Modal -->
    <div class="inventory-panel" id="inventory-panel">
        <div class="inventory-header">
            <span class="inventory-title">Inventory</span>
            <button class="inventory-close" id="inventory-close">X</button>
        </div>

        <div class="inventory-tabs">
            <button class="inventory-tab active" data-tab="gears">Gears</button>
            <button class="inventory-tab" data-tab="potions">Potions</button>
        </div>

        <div class="inventory-content">
            <!-- Left Panel: Character Preview & Equipped -->
            <div class="inventory-left">
                <div class="character-preview"></div>
                <div class="equipped-slots">
                    <div class="equipped-slot" id="equipped-right-slot" data-slot="right">
                        <div class="corner tl"></div>
                        <div class="corner tr"></div>
                        <div class="corner bl"></div>
                        <div class="corner br"></div>
                        <div class="equipped-slot-label">Right Gear</div>
                        <div class="equipped-slot-name">Empty.</div>
                        <div class="equipped-slot-effects">No gear equipped.</div>
                        <div class="equipped-slot-desc">Equip a right-hand gear to see its effects.</div>
                    </div>
                    <div class="equipped-slot" id="equipped-left-slot" data-slot="left">
                        <div class="corner tl"></div>
                        <div class="corner tr"></div>
                        <div class="corner bl"></div>
                        <div class="corner br"></div>
                        <div class="equipped-slot-label">Left Gear</div>
                        <div class="equipped-slot-name">Empty.</div>
                        <div class="equipped-slot-effects">No gear equipped.</div>
                        <div class="equipped-slot-desc">Equip a left-hand gear to see its effects.</div>
                    </div>
                </div>
            </div>

            <!-- Right Panel: Gear List -->
            <div class="inventory-right">
                <div class="inventory-search">
                    <input type="text" id="inventory-search" placeholder="Search...">
                </div>
                <div class="inventory-gear-list" id="inventory-gear-list">
                    <!-- Gear grids will be populated by JS -->
                </div>
            </div>
        </div>
    </div>

    <!-- Workshop Panel Modal -->
    <div class="workshop-panel" id="workshop-panel">
        <div class="workshop-header">
            <span class="workshop-title">Jake's workshop</span>
            <button class="workshop-close" id="workshop-close">X</button>
        </div>

        <div class="workshop-tabs">
            <button class="workshop-tab active" data-tab="gears">Gears</button>
            <button class="workshop-tab" data-tab="auras">Auras</button>
            <button class="workshop-tab" data-tab="items">Items</button>
        </div>

        <div class="workshop-search">
            <input type="text" id="workshop-search" placeholder="Search...">
        </div>

        <div class="workshop-content">
            <!-- Left Panel: Preview & Craft -->
            <div class="workshop-left">
                <div class="workshop-preview" id="workshop-preview">
                    <div class="preview-placeholder">Select an item to craft</div>
                </div>
                <div class="workshop-craft-buttons">
                    <button class="craft-btn" id="craft-btn">Craft</button>
                    <button class="auto-btn" id="auto-btn">Auto</button>
                </div>
                <div class="workshop-materials" id="workshop-materials">
                    <!-- Material list will be populated here -->
                </div>
            </div>

            <!-- Right Panel: Items List -->
            <div class="workshop-right">
                <div class="workshop-list" id="workshop-list">
                    <!-- Items will be populated here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Panel Modal -->
    <div class="settings-panel" id="settings-panel">
        <div class="settings-header">
            <span class="settings-title">Settings</span>
            <button class="settings-close" id="settings-close">X</button>
        </div>

        <div class="settings-tabs">
            <button class="settings-tab active tab-rolling" data-tab="rolling">
                <div class="corner tl"></div>
                <div class="corner tr"></div>
                <div class="corner bl"></div>
                <div class="corner br"></div>
                Rolling
            </button>
            <button class="settings-tab tab-notifications" data-tab="notifications">
                <div class="corner tl"></div>
                <div class="corner tr"></div>
                <div class="corner bl"></div>
                <div class="corner br"></div>
                Notifications
            </button>
            <button class="settings-tab tab-misc" data-tab="misc">
                <div class="corner tl"></div>
                <div class="corner tr"></div>
                <div class="corner bl"></div>
                <div class="corner br"></div>
                Miscellaneous
            </button>
            <button class="settings-tab tab-sfx" data-tab="sfx">
                <div class="corner tl"></div>
                <div class="corner tr"></div>
                <div class="corner bl"></div>
                <div class="corner br"></div>
                Sound Effects
            </button>
        </div>

        <div class="settings-content">
            <!-- Rolling Settings -->
            <div class="settings-tab-content" id="tab-rolling">
                <div class="settings-section-title">&lt; Roll Settings &gt;</div>
                <div class="settings-grid">
                    <div class="setting-row full-width">
                        <div class="corner tl"></div>
                        <div class="corner tr"></div>
                        <div class="corner bl"></div>
                        <div class="corner br"></div>
                        <div class="setting-label">Skip Warning Rarity</div>
                        <div class="setting-controls">
                            <span id="set-skip-warn-status" style="color: #ff6b6b; font-weight: bold; font-size: 14px;">Disabled</span>
                            <input type="text" id="set-skip-warn-val" class="setting-input-number" value="0">
                            <input type="checkbox" id="set-skip-warn-toggle" class="setting-checkbox">
                        </div>
                    </div>
                    <div class="setting-row full-width">
                        <div class="corner tl"></div>
                        <div class="corner tr"></div>
                        <div class="corner bl"></div>
                        <div class="corner br"></div>
                        <div class="setting-label">Swap Warning Rarity</div>
                        <div class="setting-controls">
                            <span id="set-swap-warn-status" style="color: #ff6b6b; font-weight: bold; font-size: 14px;">Disabled</span>
                            <input type="text" id="set-swap-warn-val" class="setting-input-number" value="0">
                            <input type="checkbox" id="set-swap-warn-toggle" class="setting-checkbox">
                        </div>
                    </div>
                    <div class="setting-row full-width">
                        <div class="corner tl"></div>
                        <div class="corner tr"></div>
                        <div class="corner bl"></div>
                        <div class="corner br"></div>
                        <div class="setting-label">Auto Equip Rarity</div>
                        <div class="setting-controls">
                            <input type="text" id="set-auto-equip-val" class="setting-input-number" value="2,999">
                            <input type="checkbox" id="set-auto-equip-toggle" class="setting-checkbox" checked>
                        </div>
                    </div>
                    <div class="setting-row full-width">
                        <div class="corner tl"></div>
                        <div class="corner tr"></div>
                        <div class="corner bl"></div>
                        <div class="corner br"></div>
                        <div class="setting-label">Auto Gear Progression</div>
                        <div class="setting-controls">
                            <input type="checkbox" id="set-auto-gear-toggle" class="setting-checkbox">
                        </div>
                    </div>
                    <div class="setting-row full-width">
                        <div class="corner tl"></div>
                        <div class="corner tr"></div>
                        <div class="corner bl"></div>
                        <div class="corner br"></div>
                        <div class="setting-label">Cutscene Skip Rarity</div>
                        <div class="setting-controls">
                            <input type="text" id="set-skip-cutscene-val" class="setting-input-number" value="10">
                            <input type="checkbox" id="set-skip-cutscene-toggle" class="setting-checkbox">
                        </div>
                    </div>
                    <div class="setting-row">
                        <div class="corner tl"></div>
                        <div class="corner tr"></div>
                        <div class="corner bl"></div>
                        <div class="corner br"></div>
                        <div class="setting-label">Buffs Enabled</div>
                        <div class="setting-controls"><input type="checkbox" id="set-buffs-enabled"
                                class="setting-checkbox" checked></div>
                    </div>
                    <div class="setting-row">
                        <div class="corner tl"></div>
                        <div class="corner tr"></div>
                        <div class="corner bl"></div>
                        <div class="corner br"></div>
                        <div class="setting-label">Storage Full Warning</div>
                        <div class="setting-controls"><input type="checkbox" id="set-storage-warning"
                                class="setting-checkbox" checked></div>
                    </div>
                    <div class="setting-row">
                        <div class="corner tl"></div>
                        <div class="corner tr"></div>
                        <div class="corner bl"></div>
                        <div class="corner br"></div>
                        <div class="setting-label">Play New Aura Cutscene</div>
                        <div class="setting-controls"><input type="checkbox" id="set-play-cutscene"
                                class="setting-checkbox" checked></div>
                    </div>
                    <div class="setting-row">
                        <div class="corner tl"></div>
                        <div class="corner tr"></div>
                        <div class="corner bl"></div>
                        <div class="corner br"></div>
                        <div class="setting-label">Hide All Buffs (Less Lag)</div>
                        <div class="setting-controls"><input type="checkbox" id="set-hide-buffs-hud"
                                class="setting-checkbox"></div>
                    </div>
                    <div class="setting-row">
                        <div class="corner tl"></div>
                        <div class="corner tr"></div>
                        <div class="corner bl"></div>
                        <div class="corner br"></div>
                        <div class="setting-label" id="open-filter-label" style="cursor: pointer;">Aura Filter</div>
                        <div class="setting-controls"><button class="setting-btn" id="open-filter-btn">Open</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Notifications Settings -->
            <div class="settings-tab-content" id="tab-notifications" style="display:none;">
                <div class="settings-section-title">&lt; Notification Settings &gt;</div>
                <div class="settings-grid">
                    <div class="setting-row">
                        <div class="corner tl"></div>
                        <div class="corner tr"></div>
                        <div class="corner bl"></div>
                        <div class="corner br"></div>
                        <div class="setting-label">Enable Notifications</div>
                        <div class="setting-controls"><input type="checkbox" id="set-notif-enabled"
                                class="setting-checkbox" checked></div>
                    </div>
                    <div class="setting-row">
                        <div class="corner tl"></div>
                        <div class="corner tr"></div>
                        <div class="corner bl"></div>
                        <div class="corner br"></div>
                        <div class="setting-label">Auto Add <div class="info-btn">?</div>
                        </div>
                        <div class="setting-controls"><input type="checkbox" id="set-notif-auto-add"
                                class="setting-checkbox" checked></div>
                    </div>
                    <div class="setting-row">
                        <div class="corner tl"></div>
                        <div class="corner tr"></div>
                        <div class="corner bl"></div>
                        <div class="corner br"></div>
                        <div class="setting-label">Coin <div class="info-btn">?</div>
                        </div>
                        <div class="setting-controls"><input type="checkbox" id="set-notif-coin"
                                class="setting-checkbox" checked></div>
                    </div>
                    <div class="setting-row">
                        <div class="corner tl"></div>
                        <div class="corner tr"></div>
                        <div class="corner bl"></div>
                        <div class="corner br"></div>
                        <div class="setting-label">Item Collect</div>
                        <div class="setting-controls"><input type="checkbox" id="set-notif-item"
                                class="setting-checkbox" checked></div>
                    </div>
                    <div class="setting-row">
                        <div class="corner tl"></div>
                        <div class="corner tr"></div>
                        <div class="corner bl"></div>
                        <div class="corner br"></div>
                        <div class="setting-label">Global Message Enabled</div>
                        <div class="setting-controls"><input type="checkbox" id="set-notif-global"
                                class="setting-checkbox"></div>
                    </div>
                    <div class="setting-row full-width">
                        <div class="corner tl"></div>
                        <div class="corner tr"></div>
                        <div class="corner bl"></div>
                        <div class="corner br"></div>
                        <div class="setting-label">Server Message Ignore Rarity</div>
                        <div class="setting-controls">
                            <input type="text" id="set-notif-ignore-rarity" class="setting-input-number" value="99,998">
                        </div>
                    </div>
                </div>
            </div>

            <!-- Miscellaneous Settings -->
            <div class="settings-tab-content" id="tab-misc" style="display:none;">
                <div class="settings-section-title">&lt; Miscellaneous &gt;</div>
                <div class="settings-grid">
                    <div class="setting-row">
                        <div class="corner tl"></div>
                        <div class="corner tr"></div>
                        <div class="corner bl"></div>
                        <div class="corner br"></div>
                        <div class="setting-label">PVP Mode</div>
                        <div class="setting-controls"><input type="checkbox" id="set-misc-pvp" class="setting-checkbox"
                                checked></div>
                    </div>
                    <div class="setting-row">
                        <div class="corner tl"></div>
                        <div class="corner tr"></div>
                        <div class="corner bl"></div>
                        <div class="corner br"></div>
                        <div class="setting-label">Hide AFK</div>
                        <div class="setting-controls"><input type="checkbox" id="set-misc-afk" class="setting-checkbox"
                                checked></div>
                    </div>
                    <div class="setting-row">
                        <div class="corner tl"></div>
                        <div class="corner tr"></div>
                        <div class="corner bl"></div>
                        <div class="corner br"></div>
                        <div class="setting-label">Gear Screen Effect</div>
                        <div class="setting-controls"><input type="checkbox" id="set-misc-gear-effect"
                                class="setting-checkbox" checked></div>
                    </div>
                    <div class="setting-row">
                        <div class="corner tl"></div>
                        <div class="corner tr"></div>
                        <div class="corner bl"></div>
                        <div class="corner br"></div>
                        <div class="setting-label">New Aura Effect <div class="info-btn">?</div>
                        </div>
                        <div class="setting-controls"><input type="checkbox" id="set-misc-new-aura-effect"
                                class="setting-checkbox" checked></div>
                    </div>
                    <div class="setting-row full-width">
                        <div class="corner tl"></div>
                        <div class="corner tr"></div>
                        <div class="corner bl"></div>
                        <div class="corner br"></div>
                        <div class="setting-label">Storage Deletion Warning <div class="info-btn">?</div>
                        </div>
                        <div class="setting-controls">
                            <input type="text" id="set-misc-delete-warn-rarity" class="setting-input-number"
                                value="9,007,199,254,740,991">
                        </div>
                    </div>
                    <div class="setting-row">
                        <div class="corner tl"></div>
                        <div class="corner tr"></div>
                        <div class="corner bl"></div>
                        <div class="corner br"></div>
                        <div class="setting-label">Title Selection</div>
                        <div class="setting-controls"><button class="setting-btn">Open</button></div>
                    </div>
                    <div class="setting-row">
                        <div class="corner tl"></div>
                        <div class="corner tr"></div>
                        <div class="corner bl"></div>
                        <div class="corner br"></div>
                        <div class="setting-label">Redeem Code</div>
                        <div class="setting-controls"><button class="setting-btn">Open</button></div>
                    </div>
                    <div class="setting-row full-width">
                        <div class="corner tl"></div>
                        <div class="corner tr"></div>
                        <div class="corner bl"></div>
                        <div class="corner br"></div>
                        <div class="setting-label" style="color: #ff6b6b;">Danger Zone</div>
                        <div class="setting-controls"><button class="setting-btn" id="reset-game-btn"
                                style="background: rgba(255, 107, 107, 0.2); border-color: rgba(255, 107, 107, 0.4); color: #ff6b6b;">Reset
                                All Data</button></div>
                    </div>
                </div>
            </div>

            <!-- SFX Settings -->
            <div class="settings-tab-content" id="tab-sfx" style="display:none;">
                <div class="settings-section-title">&lt; SFX Settings &gt;</div>
                <div class="settings-grid">
                    <div class="setting-row full-width">
                        <div class="corner tl"></div>
                        <div class="corner tr"></div>
                        <div class="corner bl"></div>
                        <div class="corner br"></div>
                        <div class="setting-label">Background Music</div>
                        <div class="setting-controls" style="flex: 1; margin-left: 20px;">
                            <div class="setting-slider-container">
                                <input type="range" id="vol-bgm" class="setting-slider" value="0">
                                <span class="setting-value-badge">0%</span>
                            </div>
                        </div>
                    </div>
                    <div class="setting-row full-width">
                        <div class="corner tl"></div>
                        <div class="corner tr"></div>
                        <div class="corner bl"></div>
                        <div class="corner br"></div>
                        <div class="setting-label">Others Aura BGM</div>
                        <div class="setting-controls" style="flex: 1; margin-left: 20px;">
                            <div class="setting-slider-container">
                                <input type="range" id="vol-others-aura" class="setting-slider" value="0">
                                <span class="setting-value-badge">0%</span>
                            </div>
                        </div>
                    </div>
                    <div class="setting-row full-width">
                        <div class="corner tl"></div>
                        <div class="corner tr"></div>
                        <div class="corner bl"></div>
                        <div class="corner br"></div>
                        <div class="setting-label">My Aura BGM</div>
                        <div class="setting-controls" style="flex: 1; margin-left: 20px;">
                            <div class="setting-slider-container">
                                <input type="range" id="vol-my-aura" class="setting-slider" value="0">
                                <span class="setting-value-badge">0%</span>
                            </div>
                        </div>
                    </div>
                    <div class="setting-row full-width">
                        <div class="corner tl"></div>
                        <div class="corner tr"></div>
                        <div class="corner bl"></div>
                        <div class="corner br"></div>
                        <div class="setting-label">UI</div>
                        <div class="setting-controls" style="flex: 1; margin-left: 20px;">
                            <div class="setting-slider-container">
                                <input type="range" id="vol-ui" class="setting-slider" value="0">
                                <span class="setting-value-badge">0%</span>
                            </div>
                        </div>
                    </div>
                    <div class="setting-row full-width">
                        <div class="corner tl"></div>
                        <div class="corner tr"></div>
                        <div class="corner bl"></div>
                        <div class="corner br"></div>
                        <div class="setting-label">Server Messages</div>
                        <div class="setting-controls" style="flex: 1; margin-left: 20px;">
                            <div class="setting-slider-container">
                                <input type="range" id="vol-server" class="setting-slider" value="100">
                                <span class="setting-value-badge">100%</span>
                            </div>
                        </div>
                    </div>
                    <div class="setting-row full-width">
                        <div class="corner tl"></div>
                        <div class="corner tr"></div>
                        <div class="corner bl"></div>
                        <div class="corner br"></div>
                        <div class="setting-label">Sound Effects</div>
                        <div class="setting-controls" style="flex: 1; margin-left: 20px;">
                            <div class="setting-slider-container">
                                <input type="range" id="vol-sfx" class="setting-slider" value="100">
                                <span class="setting-value-badge">100%</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Achievements Panel -->
    <div class="achievements-panel" id="achievements-panel">
        <div class="corner-brackets"></div>

        <div class="achievements-header">
            <div class="achievements-title">Achievements</div>
            <div id="achievements-close" class="achievements-close">X</div>
        </div>

        <div class="achievements-body">
            <div class="ach-sidebar">
                <div class="ach-sidebar-header bracket-box">
                    <div class="corner-brackets"></div>
                    <div id="ach-detail-title" class="ach-selected-title">Select Achievement</div>
                    <div id="ach-detail-desc" class="ach-selected-desc">Select an achievement to view details</div>
                </div>

                <div class="ach-rewards-box bracket-box">
                    <div class="corner-brackets"></div>
                    <div class="ach-rewards-title">Rewards</div>
                    <div id="ach-detail-rewards"></div>
                </div>

                <div id="ach-detail-status" class="ach-status-btn bracket-box">
                    <div class="corner-brackets"></div>
                    LOCKED
                </div>
            </div>

            <div class="ach-list-container">
                <div class="bracket-box" style="margin-bottom: 10px;">
                    <div class="corner-brackets"></div>
                    <input type="text" id="ach-search" class="ach-search-bar" placeholder="Search..."
                        style="width: 100%; box-sizing: border-box; background: transparent; border: none; color: white; padding: 10px;">
                </div>

                <div id="achievements-list" class="ach-list-scroll">
                    <!-- Items -->
                </div>
            </div>
        </div>
    </div>

    <!-- Admin Panel Modal -->
    <div class="admin-panel" id="admin-panel">
        <div class="admin-panel-inner">
            <div class="admin-header">
                <span class="admin-title">Admin Panel</span>
                <button class="admin-close" id="admin-close">X</button>
            </div>
            <div class="admin-tabs">
                <button class="admin-tab active" data-tab="biomes">Biomes</button>
                <button class="admin-tab" data-tab="time">Time</button>
                <button class="admin-tab" data-tab="items">Items</button>
                <button class="admin-tab" data-tab="player">Player</button>
                <button class="admin-tab" data-tab="testing">Testing</button>
                <button class="admin-tab" data-tab="danger">Danger</button>
            </div>

            <!-- Biomes Section -->
            <div class="admin-section" id="section-biomes">
                <div class="admin-section-title">&lt; Biome Settings &gt;</div>
                <div class="biome-grid" id="biome-grid">
                    <!-- Biomes will be populated by JS -->
                </div>
            </div>

            <!-- Time Section -->
            <div class="admin-section" id="section-time" style="display: none;">
                <div class="admin-section-title">&lt; Time Settings &gt;</div>
                <div class="time-controls">
                    <button class="time-option active" id="time-day">DAYTIME</button>
                    <button class="time-option" id="time-night">NIGHTTIME</button>
                </div>
                <div class="time-info">
                    <span class="time-label">Auto-cycle:</span>
                    <button class="time-toggle" id="time-auto-toggle">ON</button>
                </div>
            </div>

            <!-- Items Section (Gear, Materials, Potions, Chests) -->
            <div class="admin-section" id="section-items" style="display: none;">
                <div class="admin-section-title" style="color: #2ecc71;">&lt; Give Gear &gt;</div>
                <div class="admin-gear-search">
                    <input type="text" id="admin-gear-search" placeholder="Search gears...">
                </div>
                <div class="admin-gear-grid" id="admin-gear-grid">
                    <!-- Gears will be populated by JS -->
                </div>
                <div class="admin-section-title" style="margin-top: 15px; color: #3498db;">&lt; Give Materials &gt;</div>
                <div class="admin-materials-row">
                    <input type="text" id="admin-material-name" placeholder="Material name (e.g. Rare)">
                    <input type="number" id="admin-material-count" placeholder="Amount" value="100" min="1">
                    <button class="admin-give-btn" id="admin-give-material">Give</button>
                </div>
                <div class="admin-section-title" style="margin-top: 15px; color: #e056fd;">&lt; Give Potions &gt;</div>
                <div class="admin-materials-row" style="margin-bottom: 10px;">
                    <span style="color: #888; font-size: 11px;">Quantity:</span>
                    <input type="number" id="admin-potion-count" placeholder="Amount" value="10" min="1" max="9999"
                        style="width: 80px;">
                    <span style="color: #666; font-size: 10px; margin-left: 5px;">Click potion to give</span>
                </div>
                <div class="admin-gear-grid" id="admin-potion-grid">
                    <!-- Potions will be populated by JS -->
                </div>
                <div class="admin-section-title" style="margin-top: 15px; color: #f39c12;">&lt; Give Chests &gt;</div>
                <div class="admin-materials-row" style="margin-bottom: 10px;">
                    <span style="color: #888; font-size: 11px;">Quantity:</span>
                    <input type="number" id="admin-chest-count" placeholder="Amount" value="10" min="1" max="9999"
                        style="width: 80px;">
                    <span style="color: #666; font-size: 10px; margin-left: 5px;">Click chest to give</span>
                </div>
                <div class="admin-gear-grid" id="admin-chest-grid">
                    <!-- Chests will be populated by JS -->
                </div>
            </div>

            <!-- Player Section (Stats, VIP, Force Roll) -->
            <div class="admin-section" id="section-player" style="display: none;">
                <div class="admin-section-title" style="color: #9b59b6;">&lt; Player Stats &gt;</div>
                <div class="admin-materials-row">
                    <input type="number" id="admin-set-rolls" placeholder="Total Rolls" value="">
                    <button class="admin-give-btn" id="admin-update-rolls">Set Rolls</button>
                </div>

                <div class="admin-section-title" style="margin-top: 15px; color: #ffd700;">&lt; VIP Status &gt;</div>
                <div class="admin-materials-row" style="gap: 10px;">
                    <button class="admin-give-btn" id="admin-toggle-vip"
                        style="background: rgba(255, 215, 0, 0.2); border-color: rgba(255, 215, 0, 0.5); color: #ffd700; flex: 1;">VIP:
                        OFF</button>
                    <button class="admin-give-btn" id="admin-toggle-vip-plus"
                        style="background: rgba(147, 112, 219, 0.2); border-color: rgba(147, 112, 219, 0.5); color: #9370db; flex: 1;">VIP+:
                        OFF</button>
                </div>
                <div style="font-size: 11px; color: #888; margin-top: 5px; text-align: center;">
                    VIP = x1.2 luck | VIP + VIP+ = x1.3 luck
                </div>

                <div class="admin-section-title" style="margin-top: 15px; color: #00cec9;">&lt; Force Roll &gt;</div>
                <div class="admin-materials-row">
                    <input type="text" id="admin-force-roll-search" placeholder="Search aura by name or ID..."
                        style="flex: 2;">
                    <button class="admin-give-btn" id="admin-force-roll-btn"
                        style="background: rgba(0, 206, 201, 0.2); border-color: rgba(0, 206, 201, 0.5); color: #00cec9;">Force
                        Roll</button>
                </div>
                <div id="admin-force-roll-list"
                    style="margin-top: 8px; max-height: 200px; overflow-y: auto; background: rgba(0,0,0,0.3); border-radius: 6px; display: none;">
                </div>
                <div style="font-size: 10px; color: #888; margin-top: 5px; text-align: center;">
                    Type to search, click an aura, then click Force Roll
                </div>
            </div>

            <!-- Testing Section (Cutscenes) -->
            <div class="admin-section" id="section-testing" style="display: none;">
                <div class="admin-section-title" style="color: #e74c3c;">&lt; Test Cutscenes &gt;</div>
                <div class="admin-materials-row">
                    <input type="text" id="admin-cutscene-aura" placeholder="Aura ID (e.g. chromatic_genesis)"
                        style="flex: 1;">
                    <button class="admin-give-btn" id="admin-test-cutscene">Test</button>
                </div>
                <div id="admin-cutscene-list" style="margin-top: 10px; max-height: 200px; overflow-y: auto;"></div>

                <div class="admin-section-title" style="margin-top: 20px; color: #e056fd;">&lt; Cutscene Settings &gt;</div>
                <div class="admin-materials-row" style="gap: 10px;">
                    <button class="admin-give-btn" id="admin-toggle-potion-cutscenes"
                        style="background: rgba(224, 86, 253, 0.2); border-color: rgba(224, 86, 253, 0.5); color: #e056fd; flex: 1;">Only
                        Potion Auras: OFF</button>
                </div>
                <div style="font-size: 10px; color: #888; margin-top: 5px; text-align: center;">
                    Skip all cutscenes except Memory, Oblivion, etc.
                </div>
            </div>

            <!-- Danger Section -->
            <div class="admin-section" id="section-danger" style="display: none;">
                <div class="admin-section-title" style="color: #ff6b6b;">DANGER ZONE</div>
                <div style="font-size: 11px; color: #888; margin-bottom: 15px; text-align: center;">
                    These actions cannot be undone!
                </div>
                <div class="admin-materials-row" style="gap: 10px;">
                    <button class="admin-give-btn" id="admin-clear-buffs"
                        style="background: rgba(255, 159, 67, 0.2); border-color: rgba(255, 159, 67, 0.5); color: #ff9f43; flex: 1;">Clear
                        All Buffs</button>
                </div>
                <div style="font-size: 10px; color: #888; margin-top: 5px; margin-bottom: 15px; text-align: center;">
                    Removes all active potion effects and buffs
                </div>
                <div class="admin-materials-row" style="gap: 10px;">
                    <button class="admin-give-btn" id="admin-reset-data"
                        style="background: rgba(255, 107, 107, 0.2); border-color: rgba(255, 107, 107, 0.5); color: #ff6b6b; flex: 1;">Reset
                        All Data</button>
                </div>
                <div style="font-size: 10px; color: #888; margin-top: 5px; text-align: center;">
                    Deletes ALL save data and resets the game completely
                </div>
            </div>
        </div>
    </div>

    </div>

    <!-- Filter Panel Modal -->
    <div class="filter-panel" id="filter-panel">
        <div class="filter-header">
            <span class="filter-title">Filter Settings</span>
            <button class="filter-close" id="filter-close">X</button>
        </div>
        <div class="filter-content" id="filter-list">
            <!-- Rows will be populated by JS -->
        </div>
    </div>

    <div class="main-container">
        <div class="roll-buttons">
            <button class="button button-left" id="auto-roll" aria-pressed="false">
                <div class="corner tl"></div>
                <div class="corner tr"></div>
                <div class="corner bl"></div>
                <div class="corner br"></div>
                <span>Auto Roll : Off</span>
            </button>
            <button class="button button-center" id="roll-button">
                <div class="button-progress-fill"></div>
                <div class="corner tl"></div>
                <div class="corner tr"></div>
                <div class="corner bl"></div>
                <div class="corner br"></div>
                <span class="roll-text">Roll</span>
                <span class="roll-count">1/10</span>
            </button>
            <button class="button button-right" id="quick-roll" aria-pressed="false">
                <div class="corner tl"></div>
                <div class="corner tr"></div>
                <div class="corner bl"></div>
                <div class="corner br"></div>
                <span>Quick Roll : Off</span>
            </button>
        </div>
    </div>

    <!-- Stats Panel (Top Right) -->
    <div class="stats-panel" id="stats-panel">
        <div class="stats-header">
            <span class="stats-title">Stats</span>
            <button class="stats-toggle" id="stats-toggle">-</button>
        </div>
        <div class="stats-content" id="stats-content">
            <div class="stat-row">
                <span class="stat-label">Total Rolls</span>
                <span class="stat-value" id="stat-total-rolls">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Best Aura</span>
                <span class="stat-value stat-aura-styled" id="stat-best-aura">None</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Session Best</span>
                <span class="stat-value stat-aura-styled" id="stat-session-best">None</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Equipped</span>
                <span class="stat-value stat-aura-styled" id="stat-equipped-aura">None</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Collected</span>
                <span class="stat-value" id="stat-collected">0 / 0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Avg Rarity</span>
                <span class="stat-value" id="stat-avg-rarity">N/A</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Current Luck</span>
                <span class="stat-value" id="stat-luck">1.0x</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Biome Luck</span>
                <span class="stat-value" id="stat-biome-luck">x1</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Rolls/Min</span>
                <span class="stat-value" id="stat-rolls-per-min">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Playtime</span>
                <span class="stat-value" id="stat-playtime">0:00:00</span>
            </div>
            <div class="stat-divider"></div>
            <div class="stat-row">
                <span class="stat-label">Money</span>
                <span class="stat-value" id="stat-money" style="color: #f1c40f;">$0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">DM Points</span>
                <span class="stat-value" id="stat-dm-points" style="color: #e056fd;">0</span>
            </div>
            <div class="stat-divider"></div>
            <div class="stat-row">
                <span class="stat-label">Rarest Biome</span>
                <span class="stat-value" id="stat-rarest-biome">None</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Biomes Found</span>
                <span class="stat-value" id="stat-biomes-found">0 / 0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Native Auras</span>
                <span class="stat-value" id="stat-native-auras">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Bonus Rolls Hit</span>
                <span class="stat-value" id="stat-bonus-rolls">0</span>
            </div>
            <div class="stat-divider"></div>
            <div class="stat-row">
                <span class="stat-label">Best Streak</span>
                <span class="stat-value" id="stat-lucky-streak">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Dry Streak</span>
                <span class="stat-value" id="stat-dry-streak">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Current Streak</span>
                <span class="stat-value" id="stat-current-streak">0</span>
            </div>
            <div class="stat-divider"></div>
            <div class="stat-row">
                <span class="stat-label">Gears Crafted</span>
                <span class="stat-value" id="stat-gears-crafted">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Potions Used</span>
                <span class="stat-value" id="stat-potions-used">0</span>
            </div>
            <div class="stat-divider"></div>
            <div class="stat-row stat-tier-header">
                <span class="stat-label">&lt; Tier Counts &gt;</span>
            </div>
            <div class="stat-row stat-tier-row">
                <span class="stat-label" style="color: #aaa;">Common</span>
                <span class="stat-value" id="stat-tier-common">0</span>
            </div>
            <div class="stat-row stat-tier-row">
                <span class="stat-label" style="color: #3498db;">Uncommon</span>
                <span class="stat-value" id="stat-tier-uncommon">0</span>
            </div>
            <div class="stat-row stat-tier-row">
                <span class="stat-label" style="color: #2ecc71;">Rare</span>
                <span class="stat-value" id="stat-tier-rare">0</span>
            </div>
            <div class="stat-row stat-tier-row">
                <span class="stat-label" style="color: #9b59b6;">Epic</span>
                <span class="stat-value" id="stat-tier-epic">0</span>
            </div>
            <div class="stat-row stat-tier-row">
                <span class="stat-label" style="color: #f1c40f;">Legendary</span>
                <span class="stat-value" id="stat-tier-legendary">0</span>
            </div>
            <div class="stat-row stat-tier-row">
                <span class="stat-label" style="color: #e74c3c;">Mythic</span>
                <span class="stat-value" id="stat-tier-mythic">0</span>
            </div>
            <div class="stat-row stat-tier-row">
                <span class="stat-label" style="color: #00d4ff;">Exalted</span>
                <span class="stat-value" id="stat-tier-exalted">0</span>
            </div>
            <div class="stat-row stat-tier-row">
                <span class="stat-label" style="color: #ff00ff;">Glorious</span>
                <span class="stat-value" id="stat-tier-glorious">0</span>
            </div>
            <div class="stat-row stat-tier-row">
                <span class="stat-label" style="color: #ffd700; text-shadow: 0 0 5px #ffd700;">Transcendent</span>
                <span class="stat-value" id="stat-tier-transcendent">0</span>
            </div>
        </div>
    </div>

    <style>
        /* Stats Panel */
        .stats-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(10, 15, 25, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            min-width: 320px;
            z-index: 500;
            font-family: 'Sarpanch', sans-serif;
        }

        .stats-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stats-title {
            font-size: 14px;
            font-weight: 700;
            color: #ffd700;
        }

        .stats-toggle {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            font-size: 18px;
            cursor: pointer;
            transition: color 0.2s;
        }

        .stats-toggle:hover {
            color: #fff;
        }

        .stats-content {
            padding: 10px 15px;
        }

        .stats-content.collapsed {
            display: none;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .stat-label {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.5);
        }

        .stat-value {
            font-size: 12px;
            font-weight: 600;
            color: #fff;
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .stat-aura-styled {
            font-size: 11px;
        }

        .stat-divider {
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.15), transparent);
            margin: 8px 0;
        }

        .stat-tier-header .stat-label {
            color: #fff;
            font-weight: 600;
            font-size: 11px;
            width: 100%;
            text-align: center;
        }

        .stat-tier-row {
            padding: 3px 0;
        }

        .stat-tier-row .stat-label {
            font-size: 11px;
        }

        .stat-tier-row .stat-value {
            font-size: 11px;
        }

        #stat-best-aura {
            max-width: 160px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        #stat-luck {
            color: #2ecc71;
        }

        #stat-collected {
            color: #3498db;
        }

        /* Achievement Notification */
        .achievement-notification {
            position: fixed;
            top: 20px;
            right: -400px;
            width: 350px;
            background: linear-gradient(135deg, rgba(20, 20, 40, 0.98), rgba(40, 40, 80, 0.95));
            border: 2px solid #f39c12;
            border-radius: 12px;
            padding: 15px;
            display: flex;
            gap: 15px;
            z-index: 10002;
            box-shadow: 0 8px 32px rgba(243, 156, 18, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.1);
            transition: right 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        .achievement-notification.show {
            right: 20px;
        }

        .achievement-icon {
            font-size: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 50px;
        }

        .achievement-content {
            flex: 1;
        }

        .achievement-header {
            font-size: 11px;
            color: #f39c12;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
        }

        .achievement-name {
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .achievement-desc {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 5px;
        }

        .achievement-title {
            font-size: 11px;
            color: #2ecc71;
            font-style: italic;
        }

        /* Achievements Panel */
        /* Achievements Panel (Redesign) */
        .achievements-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.95);
            width: 900px;
            max-width: 95vw;
            height: 600px;
            max-height: 85vh;
            background: rgba(10, 10, 15, 0.95);
            z-index: 9999;
            display: none;
            flex-direction: column;
            opacity: 0;
            transition: all 0.2s ease;
            box-shadow: 0 30px 80px rgba(0, 0, 0, 0.8);
            color: #fff;
        }

        .achievements-panel.visible {
            display: flex;
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }

        /* Corner Brackets Mixin */
        .corner-brackets {
            background:
                linear-gradient(to right, #fff 2px, transparent 2px) 0 0,
                linear-gradient(to bottom, #fff 2px, transparent 2px) 0 0,
                linear-gradient(to left, #fff 2px, transparent 2px) 100% 0,
                linear-gradient(to bottom, #fff 2px, transparent 2px) 100% 0,
                linear-gradient(to right, #fff 2px, transparent 2px) 0 100%,
                linear-gradient(to top, #fff 2px, transparent 2px) 0 100%,
                linear-gradient(to left, #fff 2px, transparent 2px) 100% 100%,
                linear-gradient(to top, #fff 2px, transparent 2px) 100% 100%;
            background-repeat: no-repeat;
            background-size: 15px 15px;
            /* Bracket size */
            pointer-events: none;
            position: absolute;
            inset: 0;
            opacity: 0.8;
        }

        /* Box Utility */
        .bracket-box {
            position: relative;
            background: rgba(0, 0, 0, 0.4);
        }

        /* Header */
        .achievements-header {
            padding: 15px 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
        }

        .achievements-title {
            font-size: 24px;
            font-weight: 400;
            letter-spacing: 1px;
        }

        .achievements-close {
            position: absolute;
            right: 20px;
            font-size: 28px;
            cursor: pointer;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color 0.2s;
        }

        .achievements-close:hover {
            color: #e74c3c;
        }

        /* Body */
        .achievements-body {
            display: flex;
            flex: 1;
            overflow: hidden;
            padding: 20px;
            gap: 20px;
        }

        /* Left Sidebar */
        .ach-sidebar {
            width: 300px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .ach-sidebar-header {
            padding: 20px;
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
            min-height: 100px;
        }

        .ach-selected-title {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 10px;
            line-height: 1.2;
        }

        .ach-selected-desc {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
        }

        .ach-rewards-box {
            flex: 1;
            padding: 20px;
        }

        .ach-rewards-title {
            font-size: 20px;
            text-align: center;
            margin-bottom: 15px;
        }

        .ach-reward-item {
            position: relative;
            padding: 10px;
            margin-bottom: 10px;
            font-weight: 600;
            color: #ffd700;
            /* Gold */
            text-align: center;
            background: rgba(255, 215, 0, 0.05);
        }

        .ach-reward-bracket-sm {
            position: absolute;
            inset: 0;
            pointer-events: none;
            border: 1px solid rgba(255, 215, 0, 0.3);
            /* simpler bracket for items */
            background:
                linear-gradient(to right, #ffd700 2px, transparent 2px) 0 0,
                linear-gradient(to bottom, #ffd700 2px, transparent 2px) 0 0,
                linear-gradient(to left, #ffd700 2px, transparent 2px) 100% 100%,
                linear-gradient(to top, #ffd700 2px, transparent 2px) 100% 100%;
            background-repeat: no-repeat;
            background-size: 6px 6px;
        }

        .ach-status-btn {
            padding: 15px;
            text-align: center;
            font-size: 20px;
            text-transform: uppercase;
            color: #2ecc71;
            /* Green */
            background: rgba(46, 204, 113, 0.1);
        }

        /* Right List */
        .ach-list-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .ach-search-bar {
            background: transparent;
            border: none;
            border-bottom: 1px solid rgba(255, 255, 255, 0.5);
            color: #fff;
            padding: 10px;
            font-size: 16px;
            font-family: inherit;
        }

        .ach-search-bar:focus {
            outline: none;
            border-bottom-color: #fff;
        }

        .ach-list-scroll {
            flex: 1;
            overflow-y: auto;
            padding-right: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .ach-list-scroll::-webkit-scrollbar {
            width: 4px;
        }

        .ach-list-scroll::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
        }

        /* List Items */
        .ach-list-item {
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: background 0.2s;
        }

        .ach-list-item:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .ach-list-item.active {
            background: rgba(255, 255, 255, 0.1);
        }

        .ach-item-content {
            flex: 1;
        }

        .ach-item-title {
            font-size: 18px;
            font-weight: 500;
            margin-bottom: 4px;
        }

        .ach-item-desc {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.6);
        }

        .ach-progress-container {
            margin-top: 8px;
            position: relative;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
        }

        .ach-progress-bar {
            height: 100%;
            background: #fff;
            width: 0%;
        }

        .ach-progress-text {
            position: absolute;
            right: 0;
            top: -16px;
            font-size: 12px;
            color: #fff;
        }

        .ach-check-box {
            width: 30px;
            height: 30px;
            border: 2px solid rgba(255, 255, 255, 0.8);
            margin-left: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.3;
        }

        .ach-check-box.checked {
            opacity: 1;
        }

        .ach-check-box.checked::after {
            content: '✓';
            font-size: 20px;
            font-weight: bold;
        }

        /* --- Shared Sol-style UI skin (match roll UI) --- */
        :root {
            --sol-ui-frame: #f4fbff;
            --sol-ui-frame-soft: rgba(244, 251, 255, 0.24);
            --sol-ui-panel-top: rgba(20, 22, 27, 0.74);
            --sol-ui-panel-mid: rgba(10, 11, 15, 0.66);
            --sol-ui-panel-bottom: rgba(3, 4, 7, 0.6);
            --sol-ui-text: #eef7ff;
            --sol-ui-bracket-thickness: 3px;
            --sol-ui-bracket-len: 13px;
        }

        .stats-panel,
        .menu-panel,
        .filter-panel,
        .workshop-panel,
        .inventory-panel,
        .aura-storage-panel,
        .admin-panel-inner,
        .settings-panel,
        .achievements-panel {
            border-radius: 0 !important;
            border: 1px solid var(--sol-ui-frame-soft) !important;
            background:
                linear-gradient(180deg, rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0) 42%),
                linear-gradient(180deg, var(--sol-ui-panel-top), var(--sol-ui-panel-mid) 52%, var(--sol-ui-panel-bottom)) !important;
            box-shadow:
                inset 0 1px 0 rgba(255, 255, 255, 0.16),
                inset 0 -3px 0 rgba(0, 0, 0, 0.45),
                0 24px 70px rgba(0, 0, 0, 0.78) !important;
            color: var(--sol-ui-text);
            overflow: hidden;
        }

        .admin-panel-inner {
            position: relative;
        }

        .stats-panel::before,
        .menu-panel::before,
        .filter-panel::before,
        .workshop-panel::before,
        .inventory-panel::before,
        .aura-storage-panel::before,
        .admin-panel-inner::before,
        .settings-panel::before,
        .achievements-panel::before {
            content: "";
            position: absolute;
            inset: 0;
            pointer-events: none;
            background:
                linear-gradient(var(--sol-ui-frame), var(--sol-ui-frame)) left top / var(--sol-ui-bracket-len) var(--sol-ui-bracket-thickness) no-repeat,
                linear-gradient(var(--sol-ui-frame), var(--sol-ui-frame)) left top / var(--sol-ui-bracket-thickness) var(--sol-ui-bracket-len) no-repeat,
                linear-gradient(var(--sol-ui-frame), var(--sol-ui-frame)) right top / var(--sol-ui-bracket-len) var(--sol-ui-bracket-thickness) no-repeat,
                linear-gradient(var(--sol-ui-frame), var(--sol-ui-frame)) right top / var(--sol-ui-bracket-thickness) var(--sol-ui-bracket-len) no-repeat,
                linear-gradient(var(--sol-ui-frame), var(--sol-ui-frame)) left bottom / var(--sol-ui-bracket-len) var(--sol-ui-bracket-thickness) no-repeat,
                linear-gradient(var(--sol-ui-frame), var(--sol-ui-frame)) left bottom / var(--sol-ui-bracket-thickness) var(--sol-ui-bracket-len) no-repeat,
                linear-gradient(var(--sol-ui-frame), var(--sol-ui-frame)) right bottom / var(--sol-ui-bracket-len) var(--sol-ui-bracket-thickness) no-repeat,
                linear-gradient(var(--sol-ui-frame), var(--sol-ui-frame)) right bottom / var(--sol-ui-bracket-thickness) var(--sol-ui-bracket-len) no-repeat;
            opacity: 0.94;
            z-index: 2;
        }

        .stats-panel>*,
        .menu-panel>*,
        .filter-panel>*,
        .workshop-panel>*,
        .inventory-panel>*,
        .aura-storage-panel>*,
        .admin-panel-inner>*,
        .settings-panel>*,
        .achievements-panel>* {
            position: relative;
            z-index: 3;
        }

        .stats-header,
        .menu-header,
        .filter-header,
        .workshop-header,
        .inventory-header,
        .aura-storage-header,
        .admin-header,
        .settings-header,
        .achievements-header {
            background:
                linear-gradient(180deg, rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0) 62%),
                rgba(0, 0, 0, 0.24) !important;
            border-bottom: 1px solid var(--sol-ui-frame-soft) !important;
        }

        .stats-title,
        .menu-title,
        .filter-title,
        .workshop-title,
        .inventory-title,
        .aura-storage-title,
        .admin-title,
        .settings-title,
        .achievements-title {
            color: var(--sol-ui-text) !important;
            text-shadow: 0 2px 0 rgba(8, 29, 61, 0.9);
            letter-spacing: 0.04em;
        }

        .menu-btn,
        .admin-btn,
        .filter-status-btn,
        .filter-icon-btn,
        .admin-tab,
        .settings-tab,
        .workshop-tab,
        .inventory-tab,
        .aura-storage-action-btn,
        .aura-storage-upgrade-btn,
        .time-option,
        .time-toggle,
        .admin-give-btn,
        .admin-gear-btn,
        .stats-toggle,
        .menu-close,
        .filter-close,
        .workshop-close,
        .inventory-close,
        .aura-storage-close,
        .settings-close,
        .admin-close,
        .achievements-close {
            border-radius: 0;
            border: 1px solid var(--sol-ui-frame-soft);
            background:
                linear-gradient(180deg, rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0) 42%),
                linear-gradient(180deg, rgba(20, 23, 30, 0.58), rgba(10, 12, 18, 0.56) 52%, rgba(3, 5, 9, 0.52));
            color: var(--sol-ui-text);
            text-shadow: 0 1px 0 rgba(8, 29, 61, 0.85);
            box-shadow:
                inset 0 1px 0 rgba(255, 255, 255, 0.16),
                inset 0 -2px 0 rgba(0, 0, 0, 0.4),
                0 6px 14px rgba(0, 0, 0, 0.28);
            transition: transform 120ms ease, filter 120ms ease, border-color 120ms ease, color 120ms ease;
        }

        .items-btn,
        .storage-btn,
        .inventory-btn {
            border-radius: 0 !important;
            border: 1px solid var(--sol-ui-frame-soft) !important;
            background:
                linear-gradient(180deg, rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0) 42%),
                linear-gradient(180deg, rgba(20, 23, 30, 0.58), rgba(10, 12, 18, 0.56) 52%, rgba(3, 5, 9, 0.52)) !important;
            color: var(--sol-ui-text) !important;
            text-shadow: 0 1px 0 rgba(8, 29, 61, 0.85);
            box-shadow:
                inset 0 1px 0 rgba(255, 255, 255, 0.16),
                inset 0 -2px 0 rgba(0, 0, 0, 0.4),
                0 6px 14px rgba(0, 0, 0, 0.28);
        }

        .menu-btn:hover,
        .admin-btn:hover,
        .items-btn:hover,
        .storage-btn:hover,
        .inventory-btn:hover,
        .filter-status-btn:hover,
        .filter-icon-btn:hover,
        .admin-tab:hover,
        .settings-tab:hover,
        .workshop-tab:hover,
        .inventory-tab:hover,
        .aura-storage-action-btn:hover,
        .aura-storage-upgrade-btn:hover,
        .time-option:hover,
        .time-toggle:hover,
        .admin-give-btn:hover,
        .admin-gear-btn:hover,
        .stats-toggle:hover,
        .menu-close:hover,
        .filter-close:hover,
        .workshop-close:hover,
        .inventory-close:hover,
        .aura-storage-close:hover,
        .settings-close:hover,
        .admin-close:hover,
        .achievements-close:hover {
            filter: brightness(1.06);
            border-color: rgba(244, 251, 255, 0.4);
        }

        .menu-btn:active,
        .admin-btn:active,
        .items-btn:active,
        .storage-btn:active,
        .inventory-btn:active,
        .filter-status-btn:active,
        .filter-icon-btn:active,
        .admin-tab:active,
        .settings-tab:active,
        .workshop-tab:active,
        .inventory-tab:active,
        .aura-storage-action-btn:active,
        .aura-storage-upgrade-btn:active,
        .time-option:active,
        .time-toggle:active,
        .admin-give-btn:active,
        .admin-gear-btn:active,
        .stats-toggle:active,
        .menu-close:active,
        .filter-close:active,
        .workshop-close:active,
        .inventory-close:active,
        .aura-storage-close:active,
        .settings-close:active,
        .admin-close:active,
        .achievements-close:active {
            transform: translateY(1px);
        }

        .items-btn:hover,
        .storage-btn:hover,
        .inventory-btn:hover {
            background:
                linear-gradient(180deg, rgba(255, 255, 255, 0.14), rgba(255, 255, 255, 0.02) 36%),
                linear-gradient(180deg, rgba(28, 30, 37, 0.7), rgba(16, 18, 24, 0.66) 52%, rgba(6, 8, 12, 0.62)) !important;
            border-color: rgba(244, 251, 255, 0.4) !important;
        }

        .workshop-tabs,
        .inventory-tabs,
        .settings-tabs,
        .admin-tabs {
            background: rgba(0, 0, 0, 0.25) !important;
            border-bottom: 1px solid rgba(244, 251, 255, 0.16) !important;
        }

        .stats-content {
            background: rgba(0, 0, 0, 0.18);
        }

        .stat-row {
            border-bottom: 1px solid rgba(244, 251, 255, 0.08) !important;
        }

        .stat-label {
            color: rgba(238, 247, 255, 0.72);
        }

        /* Aura Log themed to match roll UI */
        .aura-log-panel {
            position: relative;
            border-radius: 0 !important;
            border: 1px solid var(--sol-ui-frame-soft) !important;
            background:
                linear-gradient(180deg, rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0) 42%),
                linear-gradient(180deg, var(--sol-ui-panel-top), var(--sol-ui-panel-mid) 52%, var(--sol-ui-panel-bottom)) !important;
            box-shadow:
                inset 0 1px 0 rgba(255, 255, 255, 0.16),
                inset 0 -3px 0 rgba(0, 0, 0, 0.45),
                0 14px 34px rgba(0, 0, 0, 0.5) !important;
            color: var(--sol-ui-text);
            overflow: hidden;
        }

        .aura-log-panel::before {
            content: "";
            position: absolute;
            inset: 0;
            pointer-events: none;
            background:
                linear-gradient(var(--sol-ui-frame), var(--sol-ui-frame)) left top / var(--sol-ui-bracket-len) var(--sol-ui-bracket-thickness) no-repeat,
                linear-gradient(var(--sol-ui-frame), var(--sol-ui-frame)) left top / var(--sol-ui-bracket-thickness) var(--sol-ui-bracket-len) no-repeat,
                linear-gradient(var(--sol-ui-frame), var(--sol-ui-frame)) right top / var(--sol-ui-bracket-len) var(--sol-ui-bracket-thickness) no-repeat,
                linear-gradient(var(--sol-ui-frame), var(--sol-ui-frame)) right top / var(--sol-ui-bracket-thickness) var(--sol-ui-bracket-len) no-repeat,
                linear-gradient(var(--sol-ui-frame), var(--sol-ui-frame)) left bottom / var(--sol-ui-bracket-len) var(--sol-ui-bracket-thickness) no-repeat,
                linear-gradient(var(--sol-ui-frame), var(--sol-ui-frame)) left bottom / var(--sol-ui-bracket-thickness) var(--sol-ui-bracket-len) no-repeat,
                linear-gradient(var(--sol-ui-frame), var(--sol-ui-frame)) right bottom / var(--sol-ui-bracket-len) var(--sol-ui-bracket-thickness) no-repeat,
                linear-gradient(var(--sol-ui-frame), var(--sol-ui-frame)) right bottom / var(--sol-ui-bracket-thickness) var(--sol-ui-bracket-len) no-repeat;
            opacity: 0.94;
            z-index: 2;
        }

        .aura-log-panel>* {
            position: relative;
            z-index: 3;
        }

        .aura-log-header {
            border-bottom: 1px solid var(--sol-ui-frame-soft) !important;
            border-radius: 0 !important;
            background:
                linear-gradient(180deg, rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0) 62%),
                rgba(0, 0, 0, 0.24) !important;
        }

        .aura-log-title {
            color: var(--sol-ui-text) !important;
            text-shadow: 0 2px 0 rgba(8, 29, 61, 0.9);
            letter-spacing: 0.04em;
        }

        .aura-log-controls select,
        .aura-log-toggle,
        .aura-log-clear-btn {
            border-radius: 0;
            border: 1px solid var(--sol-ui-frame-soft);
            background:
                linear-gradient(180deg, rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0) 42%),
                linear-gradient(180deg, rgba(20, 23, 30, 0.58), rgba(10, 12, 18, 0.56) 52%, rgba(3, 5, 9, 0.52));
            color: var(--sol-ui-text);
            text-shadow: 0 1px 0 rgba(8, 29, 61, 0.85);
            box-shadow:
                inset 0 1px 0 rgba(255, 255, 255, 0.16),
                inset 0 -2px 0 rgba(0, 0, 0, 0.4),
                0 4px 10px rgba(0, 0, 0, 0.24);
        }

        .aura-log-controls select {
            padding: 4px 8px;
        }

        .aura-log-toggle {
            padding: 0 8px;
            line-height: 1.1;
        }

        .aura-log-controls select:hover,
        .aura-log-toggle:hover,
        .aura-log-clear-btn:hover {
            filter: brightness(1.06);
            border-color: rgba(244, 251, 255, 0.4);
        }

        .aura-log-controls select:active,
        .aura-log-toggle:active,
        .aura-log-clear-btn:active {
            transform: translateY(1px);
        }

        .aura-log-username-row,
        .aura-log-options-row,
        .aura-log-stats-row {
            border-bottom: 1px solid rgba(244, 251, 255, 0.08) !important;
            background: rgba(0, 0, 0, 0.22) !important;
        }

        .aura-log-username-row input {
            border-radius: 0;
            border: 1px solid rgba(244, 251, 255, 0.22);
            background: rgba(0, 0, 0, 0.35);
            color: #c9f8ff;
        }

        .aura-log-username-row input:focus {
            border-color: rgba(126, 255, 245, 0.75);
            box-shadow: 0 0 0 1px rgba(126, 255, 245, 0.2);
        }

        .aura-log-checkbox {
            color: rgba(238, 247, 255, 0.72);
        }

        .aura-log-checkbox input {
            accent-color: #7efff5;
        }

        .aura-log-content {
            background: rgba(0, 0, 0, 0.16);
        }

        .aura-log-content::-webkit-scrollbar {
            width: 6px;
        }

        .aura-log-content::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.25);
        }

        .aura-log-content::-webkit-scrollbar-thumb {
            background: rgba(244, 251, 255, 0.2);
        }

        .aura-log-entry {
            border-bottom: 1px solid rgba(244, 251, 255, 0.08) !important;
        }

        .aura-log-player {
            color: #9afef0;
            text-shadow: 0 0 6px rgba(126, 255, 245, 0.24);
        }

        .aura-log-action {
            color: rgba(238, 247, 255, 0.6);
        }

        /* === PERFORMANCE MONITOR === */
        #perf-monitor {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            padding: 10px 15px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 11px;
            color: #00ff00;
            z-index: 999999;
            min-width: 180px;
            pointer-events: auto;
            user-select: none;
            display: none;
        }

        #perf-monitor.visible {
            display: block;
        }

        #perf-monitor .perf-title {
            font-size: 12px;
            font-weight: bold;
            color: #fff;
            margin-bottom: 8px;
            padding-bottom: 5px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #perf-monitor .perf-close {
            cursor: pointer;
            color: #ff6b6b;
            font-size: 14px;
        }

        #perf-monitor .perf-row {
            display: flex;
            justify-content: space-between;
            margin: 3px 0;
        }

        #perf-monitor .perf-label {
            color: #888;
        }

        #perf-monitor .perf-value {
            font-weight: bold;
        }

        #perf-monitor .perf-value.good {
            color: #2ecc71;
        }

        #perf-monitor .perf-value.warning {
            color: #f39c12;
        }

        #perf-monitor .perf-value.bad {
            color: #e74c3c;
        }

        #perf-monitor .perf-graph {
            height: 30px;
            background: rgba(0, 0, 0, 0.5);
            margin-top: 8px;
            border-radius: 2px;
            overflow: hidden;
            display: flex;
            align-items: flex-end;
        }

        #perf-monitor .perf-bar {
            width: 3px;
            margin-right: 1px;
            background: #00ff00;
            transition: height 0.1s ease;
        }

        .perf-toggle-btn {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #888;
            padding: 5px 10px;
            font-size: 10px;
            cursor: pointer;
            border-radius: 3px;
            z-index: 999998;
            font-family: 'Consolas', monospace;
        }

        .perf-toggle-btn:hover {
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
        }

        #perf-monitor.visible+.perf-toggle-btn {
            display: none;
        }
    </style>
    <script>
        // Fonts are loaded once via deferred scheduler in <head>

        // --- Game State & Data ---
        let rollCounter = 1;
        let autoRollInterval = null;
        let quickRollMode = false;
        let isRolling = false;
        let isOnCooldown = false;
        let cachedTotalWeight = null;
        let currentEquippedAura = null; // Will be set to AURAS[0] on init

        // --- Aura Lookup Cache (O(1) instead of O(n) lookups) ---
        const _auraIdCache = new Map();
        const _auraNameCache = new Map();

        function buildAuraCache() {
            _auraIdCache.clear();
            _auraNameCache.clear();
            AURAS.forEach(aura => {
                if (aura && aura.id && aura.name) {
                    _auraIdCache.set(aura.id, aura);
                    _auraNameCache.set(aura.name.toLowerCase(), aura);
                } else {
                    console.warn('Invalid aura object found:', aura);
                }
            });
        }

        // Fast aura lookup by ID - O(1)
        function getAuraById(id) {
            if (_auraIdCache.size === 0) buildAuraCache();
            return _auraIdCache.get(id) || null;
        }

        // Fast aura lookup by name - O(1)
        function getAuraByName(name) {
            if (_auraNameCache.size === 0) buildAuraCache();
            return _auraNameCache.get(name.toLowerCase()) || null;
        }

        // Initialize cache immediately
        if (typeof AURAS !== 'undefined' && AURAS.length > 0) {
            buildAuraCache();
            console.log(`[Performance] Built aura cache with ${AURAS.length} entries`);
        }

        // --- Darkshader Effect State ---
        let darkshaderRollTracker = 0; // Tracks rolls for the 20-roll cycle
        let darkshaderBuffActive = false; // Is the x2.5 buff currently active?
        let darkshaderBuffRollsRemaining = 0; // How many rolls remain with x2.5 buff
        let currentBonusRollMultiplier = 1; // Tracks the current roll's luck multiplier (for display)

        // --- Lightcaster Effect State ---
        let lightcasterRollTracker = 0; // Tracks rolls for the 15-roll cycle
        let lightcasterBuffActive = false; // Is the RADIANT buff currently active?
        let lightcasterBuffRollsRemaining = 0; // How many rolls remain with RADIANT buff

        // --- Omega Drive Effect State ---
        let omegaRollTracker = 0; // Tracks rolls for the 25-roll cycle
        let omegaBuffActive = false; // Is the OVERDRIVE buff currently active?
        let omegaBuffRollsRemaining = 0; // How many rolls remain with OVERDRIVE buff

        // --- Cataclysm Device Effect State ---
        let cataclysmRollTracker = 0; // Tracks rolls for the 50-roll cycle
        let cataclysmBuffActive = false; // Is CATACLYSM currently active?
        let cataclysmBuffRollsRemaining = 0; // How many rolls remain with CATACLYSM

        // --- Fatebreaker Device Effect State ---
        let fatebreakerRollTracker = 0; // Tracks rolls for the 100-roll charge
        let fatebreakerCharged = false; // Next roll samples 3 outcomes and keeps the rarest

        // --- VIP Status ---
        // VIP = x1.2 final luck multiplier
        // VIP+ (with VIP) = x1.3 final luck multiplier
        // VIP+ (without VIP) = x1.2 final luck multiplier
        let hasVIP = false;
        let hasVIPPlus = false;

        function getVIPMultiplier() {
            if (hasVIPPlus && hasVIP) return 1.3; // VIP + VIP+ = x1.3
            if (hasVIPPlus || hasVIP) return 1.2; // Either alone = x1.2
            return 1; // No VIP = x1
        }

        // --- Player Stats ---
        const playerStats = {
            totalRolls: 0,
            bestAura: null, // The rarest aura rolled (highest chance number)
            collectedAuras: {}, // Map of aura ID to true (for uniqueness)
            playtimeSeconds: 0,
            sessionStart: Date.now(),
            // Extended Stats
            biomesDiscovered: {}, // Map of biome name to true
            biomesVisited: new Set(), // Set for achievements
            rarestBiome: null, // Rarest biome encountered
            potionsUsed: 0,
            gearsCrafted: 0,
            rollsThisSession: 0,
            recentRollTimestamps: [], // Timestamps of rolls in the last 60 seconds
            // Streaks
            luckyStreak: 0, // Consecutive 10k+ rolls
            currentLuckyStreak: 0,
            dryStreak: 0, // Rolls without getting a 10k+ aura
            currentDryStreak: 0,
            // Tier Counts
            tierCounts: {
                common: 0, // 1-100
                uncommon: 0, // 100-1k
                rare: 0, // 1k-10k
                epic: 0, // 10k-100k
                legendary: 0, // 100k-1M
                mythic: 0, // 1M-10M
                exalted: 0, // 10M-100M
                glorious: 0, // 100M-1B
                transcendent: 0 // 1B+
            },
            // Native Auras
            nativeAurasRolled: 0,
            // Bonus rolls
            bonusRollsHit: 0,

            // Gear Counters
            gemstoneRollCounter: 0,
            poleRollCounter: 0,
            presentRollCounter: 0,
            xmasRollCounter: 0,
            points: 0,
            // Money (if not using coins)
            money: 0,

            // Materials
            totalMaterialsCollected: 0,

            // === NEW ACHIEVEMENT TRACKING ===
            // Time-based rolls
            nightRolls: 0,
            dayRolls: 0,

            // Streak tracking
            currentRareStreak: 0,  // Current streak of 1/16+ rolls
            maxRareStreak: 0,      // Best rare streak ever
            currentNothingStreak: 0, // Current streak of "Nothing" rolls
            maxNothingStreak: 0,   // Best nothing streak ever

            // Mutations tracking
            mutationsObtained: new Set(), // Set of mutation aura IDs obtained

            // Potion type tracking
            potionsUsedByType: {},  // { potion_id: count }

            // Crafting tiers
            gearTiersCrafted: new Set(),  // Set of gear tiers crafted

            // Speed tracking
            currentRollSpeed: 0,  // Calculated rolls per minute

            // === ADDITIONAL ACHIEVEMENT TRACKING ===
            rollsExactHit: new Set(),  // Set of exact roll counts achieved (777, 1337, etc)
            chestsOpened: 0,           // Total chests opened
            biomeRareRolls: {},        // { "BIOME_RARITY": true } - tracks biome-specific rare rolls
            natural1mRolls: 0,         // Count of 1M+ rolls without potions
            maxLegendStreak: 0,        // Best consecutive legendary+ (100k+) streak
            currentLegendStreak: 0,    // Current legendary+ streak
            double100mAchieved: false, // Has rolled two 100M+ in a row

            // === BIOME TRACKING ===
            biomeRollCounts: {},       // { "BIOMENAME": count } - rolls per biome
            maxBiomeStreak: 0,         // Best consecutive same-biome count
            currentBiomeStreak: 0,     // Current same-biome streak
            lastBiomeName: null        // Track what biome we were last in
        };

        // --- Player Achievements State ---
        let playerAchievements = {
            completed: {}, // { achievement_id: timestamp }
            unlockedTitles: [], // Array of title strings
            activeTitle: null, // Currently displayed title
            coins: 0,
            voidCoins: 0,
            highestRarityFound: 0, // Track highest rarity aura ever found
            breakthroughCount: 0, // Count of biome-exclusive auras obtained outside native biome
            playtimeSeconds: 0 // Total playtime in seconds
        };

        // Helper function to check if a tier has been obtained
        function checkTierObtained(tierName) {
            const tierRanges = {
                'common': [1, 100],
                'uncommon': [100, 1000],
                'rare': [1000, 10000],
                'epic': [10000, 100000],
                'legendary': [100000, 1000000],
                'mythic': [1000000, 10000000],
                'exalted': [10000000, 100000000],
                'glorious': [100000000, 1000000000],
                'transcendent': [1000000000, Infinity],
                'challenged': [0, 0] // Special tier - check by biomeExclusive
            };

            const [minChance, maxChance] = tierRanges[tierName] || [0, 0];

            for (const auraId in playerStats.collectedAuras) {
                const aura = AURAS.find(a => a.id === auraId);
                if (aura) {
                    if (tierName === 'challenged') {
                        if (aura.biomeExclusive) return true;
                    } else if (aura.chance >= minChance && aura.chance < maxChance) {
                        return true;
                    }
                }
            }
            return false;
        }

        // Helper function to count auras in a tier
        function countAurasInTier(tierName) {
            const tierRanges = {
                'common': [1, 100],
                'uncommon': [100, 1000],
                'rare': [1000, 10000],
                'epic': [10000, 100000],
                'legendary': [100000, 1000000],
                'mythic': [1000000, 10000000],
                'exalted': [10000000, 100000000],
                'glorious': [100000000, 1000000000],
                'transcendent': [1000000000, Infinity]
            };

            const [minChance, maxChance] = tierRanges[tierName] || [0, 0];
            let count = 0;

            for (const auraId in playerStats.collectedAuras) {
                const aura = AURAS.find(a => a.id === auraId);
                if (aura && aura.chance >= minChance && aura.chance < maxChance) {
                    count++;
                }
            }
            return count;
        }

        // Helper function to check if all auras in a tier are collected
        function checkTierComplete(tierName) {
            const tierRanges = {
                'basic': [1, 100],
                'common': [1, 100],
                'uncommon': [100, 1000],
                'rare': [1000, 10000],
                'epic': [10000, 100000]
            };

            const [minChance, maxChance] = tierRanges[tierName] || [0, 0];
            if (minChance === 0) return false;

            // Get all auras in this tier
            const tierAuras = AURAS.filter(a => a.chance >= minChance && a.chance < maxChance && !a.unrollable);
            if (tierAuras.length === 0) return false;

            // Check if all are collected
            return tierAuras.every(aura => playerStats.collectedAuras[aura.id]);
        }

        // Helper function to count auras from a specific biome
        function countBiomeAuras(biomeName) {
            const normalizedBiome = biomeName.toLowerCase();
            let count = 0;

            for (const auraId in playerStats.collectedAuras) {
                const aura = AURAS.find(a => a.id === auraId);
                if (aura && aura.nativeBiome && aura.nativeBiome.toLowerCase() === normalizedBiome) {
                    count++;
                }
            }
            return count;
        }

        // Helper function to check if all biome-exclusive auras are collected
        function checkBiomeCollectionComplete(biomeName) {
            const normalizedBiome = biomeName.toLowerCase();

            // Get all auras native to this biome
            const biomeAuras = AURAS.filter(a =>
                a.nativeBiome &&
                a.nativeBiome.toLowerCase() === normalizedBiome &&
                !a.unrollable
            );

            if (biomeAuras.length === 0) return false;

            // Check if all are collected
            return biomeAuras.every(aura => playerStats.collectedAuras[aura.id]);
        }

        // Achievement checking function
        function checkAchievements() {
            if (typeof ACHIEVEMENTS === 'undefined') return;

            // Update biomes visited logic here (auto-track current biome)
            if (currentBiome && playerStats.biomesVisited) {
                playerStats.biomesVisited.add(currentBiome.name);
            }

            ACHIEVEMENTS.forEach(achievement => {
                // Skip if already completed
                if (playerAchievements.completed[achievement.id]) return;

                let completed = false;
                const req = achievement.requirement;

                switch (req.type) {
                    case 'rolls':
                        completed = playerStats.totalRolls >= req.value;
                        break;
                    case 'find_rarity':
                        completed = playerAchievements.highestRarityFound >= req.value;
                        break;
                    case 'playtime':
                        completed = playerAchievements.playtimeSeconds >= req.value;
                        break;
                    case 'breakthroughs':
                        completed = playerAchievements.breakthroughCount >= req.value;
                        break;
                    case 'biome_visited':
                        completed = playerStats.biomesVisited && playerStats.biomesVisited.has(req.value);
                        break;
                    case 'aura_obtained':
                        completed = playerStats.collectedAuras[req.value];
                        break;
                    case 'potions_used':
                        completed = playerStats.potionsUsed >= req.value;
                        break;
                    case 'achievements_completed':
                        completed = Object.keys(playerAchievements.completed).length >= req.value;
                        break;
                    case 'unique_auras':
                        completed = Object.keys(playerStats.collectedAuras).length >= req.value;
                        break;
                    // === NEW ACHIEVEMENT TYPES ===
                    case 'night_rolls':
                        completed = playerStats.nightRolls >= req.value;
                        break;
                    case 'day_rolls':
                        completed = playerStats.dayRolls >= req.value;
                        break;
                    case 'rare_streak':
                        completed = playerStats.maxRareStreak >= req.value;
                        break;
                    case 'nothing_streak':
                        completed = playerStats.maxNothingStreak >= req.value;
                        break;
                    case 'mutation_obtained':
                        completed = playerStats.mutationsObtained && playerStats.mutationsObtained.size >= req.value;
                        break;
                    case 'potion_used':
                        // Check if specific potion type was ever used
                        completed = playerStats.potionsUsedByType && playerStats.potionsUsedByType[req.value] > 0;
                        break;
                    case 'gears_crafted':
                        completed = playerStats.gearsCrafted >= req.value;
                        break;
                    case 'gear_tier_crafted':
                        completed = playerStats.gearTiersCrafted && playerStats.gearTiersCrafted.has(req.value);
                        break;
                    case 'rolls_per_minute':
                        completed = playerStats.currentRollSpeed >= req.value;
                        break;
                    case 'tier_obtained':
                        // Check if any aura of specified tier was obtained
                        completed = checkTierObtained(req.value);
                        break;
                    case 'double_100m':
                        // Special: two 100M+ in a row - tracked separately
                        completed = playerStats.double100mAchieved;
                        break;
                    case 'random_chance':
                        // Random chance achievements - checked separately
                        break;
                    // === ADDITIONAL NEW TYPES ===
                    case 'rolls_exact':
                        // Check if player has rolled exactly this many times (at any point)
                        completed = playerStats.rollsExactHit && playerStats.rollsExactHit.has(req.value);
                        break;
                    case 'auras_all_obtained':
                        // Check if ALL auras in the array have been obtained
                        if (Array.isArray(req.value)) {
                            completed = req.value.every(auraId => playerStats.collectedAuras[auraId]);
                        }
                        break;
                    case 'chests_opened':
                        completed = (playerStats.chestsOpened || 0) >= req.value;
                        break;
                    case 'tier_count':
                        // Check if player has X auras of a specific tier
                        if (req.value && req.value.tier && req.value.count) {
                            completed = countAurasInTier(req.value.tier) >= req.value.count;
                        }
                        break;
                    case 'tier_complete':
                        // Check if player has ALL auras of a tier
                        completed = checkTierComplete(req.value);
                        break;
                    case 'biome_rare_roll':
                        // Tracked separately when rolling
                        if (req.value && req.value.biome && req.value.rarity) {
                            const key = `${req.value.biome}_${req.value.rarity}`;
                            completed = playerStats.biomeRareRolls && playerStats.biomeRareRolls[key];
                        }
                        break;
                    case 'natural_1m_roll':
                        // Rolling 1M+ without potions - tracked separately
                        completed = playerStats.natural1mRolls >= req.value;
                        break;
                    case 'consecutive_legend':
                        // Two legendary+ in a row - tracked
                        completed = playerStats.maxLegendStreak >= req.value;
                        break;
                    // === BIOME-RELATED ACHIEVEMENT TYPES ===
                    case 'biome_aura_count':
                        // Count auras obtained from a specific biome
                        if (req.value && req.value.biome && req.value.count) {
                            completed = countBiomeAuras(req.value.biome) >= req.value.count;
                        }
                        break;
                    case 'biome_collection_complete':
                        // Check if all auras from a biome are collected
                        completed = checkBiomeCollectionComplete(req.value);
                        break;
                    case 'biome_rolls':
                        // Check if player has rolled X times in a specific biome
                        if (req.value && req.value.biome && req.value.count) {
                            const biomeRolls = playerStats.biomeRollCounts && playerStats.biomeRollCounts[req.value.biome];
                            completed = (biomeRolls || 0) >= req.value.count;
                        }
                        break;
                    case 'biomes_visited_count':
                        // Check number of unique biomes visited
                        completed = playerStats.biomesVisited && playerStats.biomesVisited.size >= req.value;
                        break;
                    case 'all_biomes_rolled':
                        // Check if player has rolled in all biomes
                        completed = playerStats.biomeRollCounts && Object.keys(playerStats.biomeRollCounts).length >= 15;
                        break;
                    case 'native_auras_rolled':
                        // Check native aura roll count
                        completed = playerStats.nativeAurasRolled >= req.value;
                        break;
                    case 'biome_streak':
                        // Track staying in same biome streak
                        completed = (playerStats.maxBiomeStreak || 0) >= req.value;
                        break;
                }

                if (completed) {
                    awardAchievement(achievement);
                }
            });
        }

        // Award an achievement
        function awardAchievement(achievement) {
            if (playerAchievements.completed[achievement.id]) return;

            // Mark as completed
            playerAchievements.completed[achievement.id] = Date.now();

            // Add title if available
            if (achievement.title && !playerAchievements.unlockedTitles.includes(achievement.title)) {
                playerAchievements.unlockedTitles.push(achievement.title);
            }

            // Award rewards
            const rewards = achievement.rewards;
            if (rewards.coins) playerAchievements.coins += rewards.coins;
            if (rewards.voidCoins) playerAchievements.voidCoins += rewards.voidCoins;
            if (rewards.potions) {
                for (const [id, count] of Object.entries(rewards.potions)) {
                    playerInventory.potions[id] = (playerInventory.potions[id] || 0) + count;
                }
            }
            // Add Chests
            if (rewards.potionChest) playerInventory.chests['potion_chest'] = (playerInventory.chests['potion_chest'] || 0) + rewards.potionChest;
            if (rewards.rarePotionChest) playerInventory.chests['rare_potion_chest'] = (playerInventory.chests['rare_potion_chest'] || 0) + rewards.rarePotionChest;
            if (rewards.megaPotionChest) playerInventory.chests['mega_potion_chest'] = (playerInventory.chests['mega_potion_chest'] || 0) + rewards.megaPotionChest;

            // Show notification
            const categoryInfo = ACHIEVEMENT_CATEGORIES[achievement.category] || { color: '#f39c12', icon: '' };
            showAchievementNotification(achievement, categoryInfo);

            // Check for achievement progress achievements
            checkAchievements();
        }

        // Show achievement notification
        function showAchievementNotification(achievement, categoryInfo) {
            const notification = document.createElement('div');
            notification.className = 'achievement-notification';
            notification.innerHTML = `
                <div class="achievement-icon">${categoryInfo.icon}</div>
                <div class="achievement-content">
                    <div class="achievement-header">Achievement Unlocked!</div>
                    <div class="achievement-name" style="color: ${categoryInfo.color}">${achievement.name}</div>
                    <div class="achievement-desc">${achievement.description}</div>
                    ${achievement.title ? `<div class="achievement-title">Title: "${achievement.title}"</div>` : ''}
                </div>
            `;
            document.body.appendChild(notification);

            // Animate in
            setTimeout(() => notification.classList.add('show'), 100);

            // Remove after 5 seconds
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => notification.remove(), 500);
            }, 5000);
        }

        // Playtime tracking
        let playtimeInterval = null;
        function startPlaytimeTracking() {
            if (playtimeInterval) clearInterval(playtimeInterval);
            playtimeInterval = setInterval(() => {
                playerStats.playtimeSeconds++;
                // Sync to achievements (though checking function uses playerAchievements.playtimeSeconds which we should update too or just point to playerStats)
                playerAchievements.playtimeSeconds = playerStats.playtimeSeconds;

                updatePlaytimeDisplay();

                // Check playtime achievements every minute
                if (playerStats.playtimeSeconds % 60 === 0) {
                    checkAchievements();
                }
            }, 1000);
        }

        // --- Active Buffs State ---
        // Map of buffType -> { multiplier, duration, sourceId }
        // For one-time buffs: { type: 'one_time', stats: {}, sourceId: '...' } in an array?
        // Actually, user requested: "Same potion types don't stack... Duration can stack".
        // Implementation:
        // Key: potion.id (e.g. 'fortune_i') -> { duration: 300, stats: {...} } ??
        // No, user said "Fortune I" and "Fortune II" might stack.
        // But "Same potion type" usually refers to the ID.
        // Let's store active timed buffs in a map by Potion ID or Buff Type?
        // "Different potion types DO stack". Haste + Fortune works.
        // What about Fortune I + Fortune II? If they are "different types" they stack.
        // I will key by Reference ID (potion.id). If you use Fortune I again, it extends Fortune I.
        // If you use Fortune II, it adds a separate buff.
        let activeBuffs = {}; // { 'fortune_i': { duration: 300, stats: {...}, name: '...' } }
        let oneTimeBuffs = []; // List of buffs to consume on next roll: [ { stats: {...}, name: '...' } ]
        const MAX_ONE_TIME_BUFF_QUEUE = 500;

        // --- User Settings State ---
        const userSettings = {
            rolling: {
                skipWarnRarity: 0,
                skipWarnEnabled: false,
                swapWarnRarity: 0,
                swapWarnEnabled: false,
                autoEquipRarity: 2999,
                autoEquipEnabled: true,
                skipCutsceneRarity: 10,
                skipCutsceneEnabled: false,
                buffsEnabled: true,
                hideAllBuffs: false,
                storageWarning: true,
                playNewAuraCutscene: true
            },
            notifications: {
                enabled: true,
                autoAdd: true,
                coin: true,
                itemCollect: true,
                globalMessage: false,
                ignoreRarity: 99998
            },
            misc: {
                pvp: true,
                afk: true,
                gearEffect: true,
                newAuraEffect: true,
                deleteWarnRarity: 9007199254740991
            },
            audio: {
                bgm: 0,
                othersAura: 0,
                myAura: 0,
                ui: 0,
                server: 100,
                sfx: 100
            },
            filters: {}, // Map of auraId -> 'disabled' | 'skip' | 'keep'
            debug: {
                skipToSpecialAuras: false, // When true, skip normal auras and only roll special potion auras (ignoreLuck)
                onlyPotionAuraCutscenes: false // When true, skip all cutscenes except special potion auras (Memory, Oblivion, etc.)
            },
            performance: {
                maxFpsMode: false // When true, dramatically reduce all visual effects for 240+ FPS
            }
        };

        // Performance mode particle multiplier
        function getParticleMultiplier() {
            if (userSettings.performance.maxFpsMode) return 0.15; // 85% reduction
            if (typeof PerfMonitor !== 'undefined' && PerfMonitor.fps < 30) return 0.4;
            if (typeof PerfMonitor !== 'undefined' && PerfMonitor.fps < 60) return 0.7;
            return 1;
        }

        // Toggle max FPS mode
        function toggleMaxFpsMode() {
            userSettings.performance.maxFpsMode = !userSettings.performance.maxFpsMode;
            console.log(`[Performance] Max FPS Mode: ${userSettings.performance.maxFpsMode ? 'ON' : 'OFF'}`);
            showNotification(
                `Max FPS Mode: ${userSettings.performance.maxFpsMode ? 'ON (240+ FPS target)' : 'OFF (Normal effects)'}`,
                userSettings.performance.maxFpsMode ? '#2ecc71' : '#e74c3c'
            );
            // Force biome refresh to apply new settings
            currentWeatherType = null;
        }

        // --- Player Inventory & Gears ---
        const playerInventory = {
            materials: {}, // { 'Rare': 1234, 'Divinus': 50, etc }
            craftedGears: {}, // { 'luck-glove': true, 'solar-device': true }
            equipped: {
                left: null,  // gear ID or null
                right: null  // gear ID or null
            },
            potions: {}, // { 'lucky_potion': 5, 'heavenly_potion': 1 }
            chests: {}, // { 'potion_chest': 10, 'rare_potion_chest': 1, 'mega_potion_chest': 0 }
            auraStorage: {
                level: 0,
                capacity: 8,
                nextId: 1,
                items: []
            }
        };

        const CHEST_TYPES = {
            // Potion Chest - Based on Sols RNG Fandom Wiki
            // Wiki: Speed/Lucky 20% (x50), Fortune I/Haste I 10% (x10), Heavenly 1%
            'potion_chest': {
                name: 'Potion Chest',
                color: '#f1c40f',
                icon: 'BOX',
                description: 'A basic chest containing common potions. Bulk drops possible!',
                lootTable: [
                    { id: 'lucky_potion', weight: 2000, quantity: 50 },     // 20% - drops 50
                    { id: 'speed_potion', weight: 2000, quantity: 50 },    // 20% - drops 50
                    { id: 'fortune_i', weight: 1000, quantity: 10 },       // 10% - drops 10
                    { id: 'haste_i', weight: 1000, quantity: 10 },         // 10% - drops 10
                    { id: 'fortune_ii', weight: 500, quantity: 2 },        // 5% - drops 2
                    { id: 'haste_ii', weight: 500, quantity: 2 },          // 5% - drops 2
                    { id: 'strange_i', weight: 300, quantity: 3 },         // 3%
                    { id: 'huge_fortune_i', weight: 200, quantity: 1 },    // 2%
                    { id: 'heavenly_potion', weight: 100, quantity: 1 },   // 1% (Wiki confirmed)
                    { id: 'godlike_potion', weight: 50, quantity: 1 },     // 0.5%
                    { id: 'potion_of_bound', weight: 20, quantity: 1 },    // 0.2%
                    { id: 'warp_potion', weight: 10, quantity: 1 },        // 0.1%
                    { id: 'strange_potion', weight: 5, quantity: 1 },      // 0.05%
                    { id: 'oblivion_potion', weight: 2, quantity: 1 },     // 0.02%
                    { id: 'transcendent_potion', weight: 1, quantity: 1 }  // 0.01%
                ]
            },
            // Rare Potion Chest - Based on Sols RNG Fandom Wiki
            // Wiki: Speed/Lucky 5-10% (x50), Fortune I/Haste I 10% (x10), Fortune II 9% (x4), Potion of Bound 3.5%, Heavenly 2.5%
            'rare_potion_chest': {
                name: 'Rare Potion Chest',
                color: '#3498db',
                icon: 'CHEST',
                description: 'Higher quality potions with better odds for rare concoctions!',
                lootTable: [
                    { id: 'lucky_potion', weight: 1000, quantity: 50 },    // 10% - drops 50
                    { id: 'speed_potion', weight: 1000, quantity: 50 },   // 10% - drops 50
                    { id: 'fortune_i', weight: 1000, quantity: 10 },      // 10% - drops 10
                    { id: 'haste_i', weight: 1000, quantity: 10 },        // 10% - drops 10
                    { id: 'fortune_ii', weight: 900, quantity: 4 },       // 9% - drops 4 (Wiki confirmed)
                    { id: 'haste_ii', weight: 900, quantity: 4 },         // 9% - drops 4
                    { id: 'fortune_iii', weight: 400, quantity: 2 },      // 4% - drops 2
                    { id: 'haste_iii', weight: 400, quantity: 2 },        // 4% - drops 2
                    { id: 'potion_of_bound', weight: 350, quantity: 1 },  // 3.5% (Wiki confirmed)
                    { id: 'heavenly_potion', weight: 250, quantity: 1 },  // 2.5% (Wiki confirmed)
                    { id: 'huge_fortune_i', weight: 200, quantity: 1 },   // 2%
                    { id: 'godlike_potion', weight: 150, quantity: 1 },   // 1.5%
                    { id: 'strange_ii', weight: 100, quantity: 2 },       // 1%
                    { id: 'warp_potion', weight: 50, quantity: 1 },       // 0.5%
                    { id: 'strange_potion', weight: 20, quantity: 1 },    // 0.2%
                    { id: 'oblivion_potion', weight: 10, quantity: 1 },   // 0.1%
                    { id: 'transcendent_potion', weight: 5, quantity: 1 } // 0.05%
                ]
            },
            // Mega Potion Chest - Based on Sols RNG Fandom Wiki
            // Wiki: Fortune II/Haste II most common, Oblivion 0.08%, Transcendent 0.05%
            'mega_potion_chest': {
                name: 'Mega Potion Chest',
                color: '#9b59b6',
                icon: 'GEM',
                description: 'The ultimate chest! High chance for rare and powerful potions.',
                lootTable: [
                    { id: 'fortune_ii', weight: 2500, quantity: 5 },       // 25% - drops 5 (common per wiki)
                    { id: 'haste_ii', weight: 2500, quantity: 5 },         // 25% - drops 5 (common per wiki)
                    { id: 'fortune_iii', weight: 1500, quantity: 3 },      // 15% - drops 3
                    { id: 'haste_iii', weight: 1500, quantity: 3 },        // 15% - drops 3
                    { id: 'heavenly_potion', weight: 500, quantity: 2 },   // 5% - drops 2
                    { id: 'godlike_potion', weight: 300, quantity: 1 },    // 3%
                    { id: 'potion_of_bound', weight: 250, quantity: 1 },   // 2.5%
                    { id: 'huge_fortune_i', weight: 200, quantity: 2 },    // 2%
                    { id: 'warp_potion', weight: 150, quantity: 1 },       // 1.5%
                    { id: 'strange_potion', weight: 50, quantity: 1 },     // 0.5%
                    { id: 'oblivion_potion', weight: 8, quantity: 1 },     // 0.08% (Wiki confirmed!)
                    { id: 'transcendent_potion', weight: 5, quantity: 1 }  // 0.05% (Wiki confirmed!)
                ]
            }
        };

        let selectedGear = null; // Currently selected gear in workshop
        const AURA_STORAGE_BASE_CAPACITY = 8;
        const AURA_STORAGE_CAPACITY_STEP = 1;
        let selectedAuraStorageUid = null;
        let auraStorageActiveTab = 'regular';
        let lastAuraStorageWarningAt = 0;
        let pendingStorageFullRoll = null;

        // "Weather" and "Regular" and "Rare" are all treated as Biomes that override 'Normal'
        const BIOMES = [
            { name: 'NORMAL', chance: 1, multiplier: 1, color: '#6495ED' }, // Fallback
            // Weather Biomes
            { name: 'WINDY', chance: 1 / 500, multiplier: 1, duration: 120, color: '#dff9fb' },
            { name: 'SNOWY', chance: 1 / 600, multiplier: 1, duration: 120, color: '#b8c5d0' },
            { name: 'RAINY', chance: 1 / 750, multiplier: 1, duration: 120, color: '#3d5a6e' },
            // Regular Biomes
            { name: 'SANDSTORM', chance: 1 / 3000, multiplier: 1, duration: 120, color: '#c4a574' },
            { name: 'HELL', chance: 1 / 6666, multiplier: 1, duration: 120, color: '#8b0000' },
            { name: 'STARFALL', chance: 1 / 7500, multiplier: 1, duration: 120, color: '#1a1a5e' },
            { name: 'HEAVEN', chance: 1 / 7777, multiplier: 1, duration: 120, color: '#f5d742' },
            { name: 'CORRUPTION', chance: 1 / 9000, multiplier: 1, duration: 120, color: '#3d1a78' },
            { name: 'NULL', chance: 1 / 10100, multiplier: 1, duration: 120, color: '#a0a0a0' },
            { name: 'JUNGLE', chance: 1 / 12000, multiplier: 1, duration: 120, color: '#228B22' },
            // Rare Biomes
            { name: 'GLITCHED', chance: 1 / 30000, multiplier: 1, duration: 60, color: '#00ffaa', rollOnBiomeChange: true },
            { name: 'LIMBO', chance: 1 / 1111111, multiplier: 1, duration: 120, color: '#0a0a0a' },
            { name: 'DREAMSPACE', chance: 1 / 3500000, multiplier: 1, duration: 60, color: '#ff6bcb' },
            { name: 'CYBERSPACE', chance: 1 / 5000, multiplier: 1, duration: 720, color: '#00d4ff', rollOnBiomeChange: true }, // 12 minutes, rolls only per biome change
            // Halloween 2025 Event Biomes
            { name: 'PUMPKIN MOON', chance: 1 / 1000, multiplier: 1, duration: 180, color: '#ff6b1a', requiresNighttime: true },
            { name: 'GRAVEYARD', chance: 1 / 1500, multiplier: 1, duration: 180, color: '#4a4a4a', requiresNighttime: true },
            { name: 'BLOOD RAIN', chance: 1 / 50000, multiplier: 1, duration: 600, color: '#8b0000', requiresNighttime: true }, // 10 minutes, very rare (normally summoned)
            // Summer 2025 Event Biome
            { name: 'BLAZING SUN', chance: 1 / 2000, multiplier: 1, duration: 180, color: '#ffd700', requiresDaytime: true },
            // Special Event Biomes (spawn during other biomes)
            { name: 'AURORA', chance: 1 / 5000, multiplier: 1, duration: 120, color: '#7efff5', spawnsFrom: 'SNOWY' },
            // Peaceful / Nature Biome
            { name: 'SAKURA', chance: 1 / 8888, multiplier: 1, duration: 180, color: '#ffb7c5' },
            // Underwater / Abyss Biome
            { name: 'DEEP SEA', chance: 1 / 12000, multiplier: 1, duration: 300, color: '#003366' }
        ];

        let currentBiome = BIOMES[0];
        let biomeTimeLeft = 0;
        let currentTime = 'DAYTIME';
        let timeCycleTimer = 0;
        const TIME_CYCLE_LENGTH = 600; // 10 minutes per cycle? Or faster for demo? Let's do 60s for now so user sees it.
        // Actually user said Daylight/Nighttime multiplier 10x.

        // --- Core RNG Logic ---

        // --- Core RNG Logic ---

        function calculateBasicLuckMultiplier() {
            let basicLuckMult = 1;
            const slots = ['left', 'right'];
            slots.forEach(slot => {
                const gearId = playerInventory.equipped[slot];
                if (!gearId) return;
                const gear = GEARS.find(g => g.id === gearId);
                if (gear && gear.stats && gear.stats.luckMultiplier) {
                    basicLuckMult *= gear.stats.luckMultiplier;
                }
            });
            return basicLuckMult;
        }

        function calculateFinalLuckMultiplier(oneTimeStats = null) {
            let finalLuckMult = 1;
            if (!userSettings.rolling.buffsEnabled) return finalLuckMult;

            // Duration / roll-duration "final luck" multipliers
            Object.values(activeBuffs).forEach(buff => {
                if (buff.stats && buff.stats.luckMultiplier) {
                    finalLuckMult *= buff.stats.luckMultiplier;
                }
            });

            // Queued one-time multipliers (if any potion uses this in future)
            if (oneTimeStats && oneTimeStats.luckMultiplier) {
                finalLuckMult *= oneTimeStats.luckMultiplier;
            }

            return finalLuckMult;
        }

        // Calculate Basic Buffs (additive luck from gear + duration potions)
        // This does NOT include Special Buffs (flat luck from one-time potions)
        // Official Formula: ((1 + Basic Buffs) * Bonus Roll + Special Buffs) * VIP
        function calculateBasicBuffs() {
            let basicLuck = 0;

            // Gears - only additive luck (not multipliers)
            const gearBonuses = calculateGearBonuses();
            basicLuck += gearBonuses.luck;

            // Duration Potions (timed buffs) - only additive luck
            if (userSettings.rolling.buffsEnabled) {
                Object.values(activeBuffs).forEach(buff => {
                    if (buff.stats && buff.stats.luck) {
                        basicLuck += buff.stats.luck;
                    }
                });
            }

            return basicLuck; // Returns additive bonus (e.g. 1.5 for +150%)
        }

        // Calculate Special Buffs (flat luck from one-time potions like Heavenly, Oblivion)
        // These are NOT multiplied by Bonus Roll, only by VIP
        function calculateSpecialBuffs(oneTimeStats = null) {
            let specialLuck = 0;
            if (!userSettings.rolling.buffsEnabled) return specialLuck;

            // One-Time Buff (queued potion) - flat luck only
            if (oneTimeStats && oneTimeStats.luckFlat) {
                specialLuck += oneTimeStats.luckFlat;
            }

            return specialLuck;
        }

        function normalizeOneTimeStats(buff) {
            if (!buff || !buff.stats) return null;
            return {
                luck: buff.stats.luck || 0,
                luckFlat: buff.stats.luckFlat || 0,
                luckMultiplier: buff.stats.luckMultiplier || 1,
                unlockAuras: Array.isArray(buff.stats.unlockAuras) ? buff.stats.unlockAuras : [],
                sourceId: buff.sourceId || null
            };
        }

        function getNextQueuedOneTimeStats() {
            if (!userSettings.rolling.buffsEnabled || oneTimeBuffs.length === 0) return null;
            return normalizeOneTimeStats(oneTimeBuffs[0]);
        }

        // Sol's RNG formula:
        // Total Luck = (((1 + Basic Buffs) * Bonus Roll Multiplier) + Special Buffs) * VIP Multiplier
        // Extended here with:
        // - Basic luck multipliers (e.g., Ominous Coffin x1.35 basic luck)
        // - Final luck multipliers from active buffs (e.g., ??? potion)
        function calculateLuckFromFormula(baseLuckMultiplier = 1, oneTimeStats = null, includeSpecialBuffs = true) {
            const basicBuffs = calculateBasicBuffs();
            const basicLuckMultiplier = calculateBasicLuckMultiplier();
            const specialBuffs = includeSpecialBuffs ? calculateSpecialBuffs(oneTimeStats) : 0;
            const vipMultiplier = getVIPMultiplier();
            const finalLuckMultiplier = calculateFinalLuckMultiplier(oneTimeStats);

            let bonusRollMultiplier = baseLuckMultiplier;
            if (hasRemoveBonusRollGear()) {
                bonusRollMultiplier = 1;
            }

            return ((((1 + basicBuffs) * basicLuckMultiplier) * bonusRollMultiplier) + specialBuffs) * vipMultiplier * finalLuckMultiplier;
        }

        // Legacy function for backwards compatibility
        function calculateTotalLuck() {
            return calculateLuckFromFormula(currentBonusRollMultiplier, null, false);
        }

        function calculateTotalRollSpeed() {
            // Check if Axis buff is active - it overrides everything
            const axisBuff = activeBuffs['axis_potion'];
            if (axisBuff && axisBuff.isAxis && axisBuff.stats.axisSpeed) {
                return axisBuff.stats.axisSpeed;
            }

            let speed = 0;

            // Gears
            const gearBonuses = calculateGearBonuses();
            speed += gearBonuses.rollSpeed;

            // Potions (Timed)
            if (userSettings.rolling.buffsEnabled) {
                Object.values(activeBuffs).forEach(buff => {
                    if (buff.stats && buff.stats.rollSpeed) speed += buff.stats.rollSpeed;
                });
            }

            // Lightcaster/Chromatic Crusher phase roll-speed bonus
            const casterProfile = getCasterProfile();
            if (casterProfile && lightcasterBuffActive && lightcasterBuffRollsRemaining > 0) {
                speed += casterProfile.phaseRollSpeedBonus;
            }

            // Omega Drive OVERDRIVE phase bonus (+50% roll speed)
            if (isOmegaDriveEquipped() && omegaBuffActive && omegaBuffRollsRemaining > 0) {
                speed += 0.50;
            }

            // Cataclysm Device phase bonus (+80% roll speed)
            if (isCataclysmDeviceEquipped() && cataclysmBuffActive && cataclysmBuffRollsRemaining > 0) {
                speed += 0.80;
            }

            return speed;
        }

        function updateEnvironment() {
            // Update Buff Timers
            Object.keys(activeBuffs).forEach(key => {
                const buff = activeBuffs[key];
                // Only decrement time-based buffs here. Roll-based handled in roll.
                if (buff.type === 'duration') {
                    buff.duration--;
                    if (buff.duration <= 0) {
                        delete activeBuffs[key];
                        showNotification(`${buff.name} worn off.`, '#95a5a6');
                        updateBuffsHUD();
                        updateStatsPanel();
                    }
                }
            });
            if (Object.keys(activeBuffs).length > 0) updateBuffsHUD(); // refresh timer display

            // Time Cycle (60s Day / 60s Night for gameplay flow)
            if (autoTimeCycle) {
                timeCycleTimer++;
                if (timeCycleTimer >= 60) {
                    currentTime = (currentTime === 'DAYTIME') ? 'NIGHTTIME' : 'DAYTIME';
                    timeCycleTimer = 0;
                    updateHUD();
                    updateTimeButtons();
                    updateLighting(); // Use shared function
                }
            }

            // Biome Rolling (Every second)
            if (currentBiome.name !== 'NORMAL') {
                biomeTimeLeft--;

                // Check for special biomes that spawn FROM this biome (e.g., Aurora spawns during Snowy)
                const spawnFromBiomes = BIOMES.filter(b => b.spawnsFrom === currentBiome.name);
                for (const specialBiome of spawnFromBiomes) {
                    if (Math.random() < specialBiome.chance) {
                        // Special biome spawned! Replace current biome
                        currentBiome = specialBiome;
                        biomeTimeLeft = specialBiome.duration;
                        updateHUD();
                        showNotification(`${specialBiome.name} has appeared!`, specialBiome.color);
                        break;
                    }
                }

                if (biomeTimeLeft <= 0) {
                    // Roll for biomes that only roll on biome change (like CYBERSPACE)
                    const biomeChangeBiomes = BIOMES.filter(b => b.rollOnBiomeChange && !b.spawnsFrom);
                    for (const biome of biomeChangeBiomes) {
                        // Check time requirements
                        if (biome.requiresNighttime && currentTime !== 'NIGHTTIME') continue;
                        if (biome.requiresDaytime && currentTime !== 'DAYTIME') continue;

                        if (Math.random() < biome.chance) {
                            currentBiome = biome;
                            biomeTimeLeft = biome.duration;
                            updateHUD();
                            showNotification(`${biome.name} has appeared!`, biome.color);
                            return; // Don't fall through to NORMAL
                        }
                    }

                    // No special biome rolled, return to NORMAL
                    currentBiome = BIOMES[0];
                    updateHUD();
                }
            } else {
                // Try to roll for a new biome
                // We roll for ALL biomes and take the rarest one that hits
                let candidateBiome = null;

                // Shuffle or iterate? Iterating standard order: rarer biomes should be checked last or first?
                // Logic: Roll separate dice for each. If multiple hit, rarest wins.
                // Filter out Normal and biomes that require another biome to spawn
                const rollableBiomes = BIOMES.filter(b => {
                    if (b.name === 'NORMAL' || b.spawnsFrom) return false;
                    // Exclude biomes that trigger only on biome change (Glitched, Cyberspace)
                    if (b.rollOnBiomeChange) return false;
                    // Check time requirements
                    if (b.requiresNighttime && currentTime !== 'NIGHTTIME') return false;
                    if (b.requiresDaytime && currentTime !== 'DAYTIME') return false;
                    return true;
                });

                for (const biome of rollableBiomes) {
                    if (Math.random() < biome.chance) {
                        if (!candidateBiome || biome.chance < candidateBiome.chance) {
                            candidateBiome = biome;
                        }
                    }
                }

                if (candidateBiome) {
                    currentBiome = candidateBiome;
                    biomeTimeLeft = candidateBiome.duration;
                    updateHUD();
                    // Play a sound or flash effect here if requested later
                }
            }
        }

        // Run environment update every second
        setInterval(updateEnvironment, 1000);

        // Weather System
        let activeWeatherInterval = null;
        let currentWeatherType = null;
        window.isCutsceneActive = false;
        const GAME_BOOT_TIME = Date.now();

        function shouldUseLiteBiomeEffects() {
            const startupWindowMs = 15000;
            if (Date.now() - GAME_BOOT_TIME < startupWindowMs) return true;

            if (typeof userSettings !== 'undefined' && userSettings.performance && userSettings.performance.maxFpsMode) {
                return true;
            }

            if (typeof PerfMonitor !== 'undefined' && PerfMonitor && PerfMonitor.fps > 0 && PerfMonitor.fps < 40) {
                return true;
            }

            return false;
        }

        window.pauseBiomeEffects = function () {
            window.isCutsceneActive = true;

            // Clear standard weather interval
            if (activeWeatherInterval) {
                if (activeWeatherInterval.clear) {
                    activeWeatherInterval.clear();
                } else if (typeof activeWeatherInterval === 'number') {
                    clearInterval(activeWeatherInterval);
                    cancelAnimationFrame(activeWeatherInterval);
                }
                activeWeatherInterval = null;
            }
            currentWeatherType = null; // Force reset on resume

            // Special Biome Cleanup
            const pumpkin = document.getElementById('pumpkin-particles');
            if (pumpkin) {
                pumpkin.remove();
                if (window.pumpkinParticleInterval) {
                    clearInterval(window.pumpkinParticleInterval);
                    window.pumpkinParticleInterval = null;
                }
            }

            const sunRays = document.getElementById('sun-rays');
            if (sunRays) sunRays.remove();

            // Clear overlay
            const biomeOverlay = document.getElementById('biome-overlay');
            if (biomeOverlay) {
                biomeOverlay.classList.remove('active');
                biomeOverlay.style.background = 'transparent';
                biomeOverlay.style.opacity = '0';
            }

            // Global Effects
            if (window.sakuraEffect && typeof window.sakuraEffect.stop === 'function') window.sakuraEffect.stop();
            if (window.deepSeaEffect && typeof window.deepSeaEffect.stop === 'function') window.deepSeaEffect.stop();

            console.log('[Biome] Effects paused for cutscene');
        };

        window.resumeBiomeEffects = function () {
            window.isCutsceneActive = false;
            console.log('[Biome] Resuming effects');
            if (typeof updateHUD === 'function') updateHUD();
        };

        function renderWeather() {
            if (window.isCutsceneActive) return;
            const container = document.getElementById('weather-container');
            const validWeathers = ['RAINY', 'WINDY', 'SNOWY', 'SANDSTORM', 'HELL', 'AURORA', 'STARFALL', 'HEAVEN', 'CORRUPTION', 'NULL', 'DREAMSPACE', 'GLITCHED', 'BLOOD RAIN', 'GRAVEYARD', 'CYBERSPACE', 'JUNGLE', 'SAKURA', 'DEEP SEA', 'LIMBO'];
            const clearActiveWeather = () => {
                container.innerHTML = '';
                if (activeWeatherInterval) {
                    if (activeWeatherInterval.isMultiple) {
                        activeWeatherInterval.clear();
                    } else if (typeof activeWeatherInterval === 'number') {
                        clearInterval(activeWeatherInterval);
                        cancelAnimationFrame(activeWeatherInterval);
                    }
                    activeWeatherInterval = null;
                }
            };

            // Check if we need to switch weather types
            if (currentWeatherType !== currentBiome.name) {
                // Clear existing weather
                clearActiveWeather();
                currentWeatherType = currentBiome.name;
            }

            // If not a weather biome, just return
            if (!validWeathers.includes(currentBiome.name)) {
                return;
            }

            // During startup or low FPS, use tint-only biome mode (no weather particles)
            if (shouldUseLiteBiomeEffects()) {
                clearActiveWeather();
                return;
            }

            // RAINY - Diagonal rain streaks (with adaptive particle rate)
            if (currentBiome.name === 'RAINY' && !activeWeatherInterval) {
                // Base rate is 8ms (125 particles/sec), scales up to 24ms when FPS drops
                const getAdaptiveDelay = () => {
                    if (typeof PerfMonitor !== 'undefined' && PerfMonitor.fps > 0) {
                        if (PerfMonitor.fps < 20) return 32; // Very low FPS - reduce heavily
                        if (PerfMonitor.fps < 30) return 20; // Low FPS - reduce moderately
                        if (PerfMonitor.fps < 45) return 12; // Medium FPS - slight reduction
                    }
                    return 12; // Good FPS - reduced base rate
                };

                let lastSpawn = 0;
                const spawnRain = () => {
                    const now = performance.now();
                    const delay = getAdaptiveDelay();

                    if (now - lastSpawn >= delay) {
                        lastSpawn = now;
                        const drop = document.createElement('div');
                        drop.classList.add('raindrop');
                        drop.style.left = Math.random() * 110 - 5 + 'vw';
                        drop.style.animationDuration = (0.4 + Math.random() * 0.3) + 's';
                        drop.style.opacity = 0.2 + Math.random() * 0.4;
                        drop.style.height = (60 + Math.random() * 50) + 'px';
                        container.appendChild(drop);
                        setTimeout(() => drop.remove(), 800);
                    }

                    if (currentBiome.name === 'RAINY') {
                        activeWeatherInterval = requestAnimationFrame(spawnRain);
                    }
                };
                activeWeatherInterval = requestAnimationFrame(spawnRain);
            }

            // WINDY - Horizontal wind streaks
            if (currentBiome.name === 'WINDY' && !activeWeatherInterval) {
                activeWeatherInterval = setInterval(() => {
                    const streak = document.createElement('div');
                    streak.classList.add('wind-streak');
                    streak.style.top = Math.random() * 100 + 'vh';
                    streak.style.width = (80 + Math.random() * 150) + 'px';
                    streak.style.animationDuration = (0.8 + Math.random() * 0.6) + 's';
                    streak.style.opacity = 0.2 + Math.random() * 0.3;
                    container.appendChild(streak);
                    setTimeout(() => streak.remove(), 1500);
                }, 45);
            }

            // SNOWY - Pseudo-3D layered snowflakes
            if (currentBiome.name === 'SNOWY' && !activeWeatherInterval) {
                activeWeatherInterval = setInterval(() => {
                    const flake = document.createElement('div');
                    flake.classList.add('snowflake');

                    // Random layer: 0 = background, 1 = middle, 2 = foreground
                    const layer = Math.floor(Math.random() * 3);

                    let size, duration, opacity;
                    if (layer === 0) {
                        // Background - small, slow, faint
                        size = 2 + Math.random() * 2;
                        duration = 6 + Math.random() * 2;
                        opacity = 0.3 + Math.random() * 0.2;
                    } else if (layer === 1) {
                        // Middle - medium
                        size = 4 + Math.random() * 2;
                        duration = 4 + Math.random() * 1.5;
                        opacity = 0.5 + Math.random() * 0.2;
                    } else {
                        // Foreground - large, fast, bright
                        size = 6 + Math.random() * 3;
                        duration = 2.5 + Math.random() * 1;
                        opacity = 0.7 + Math.random() * 0.3;
                    }

                    flake.style.left = Math.random() * 100 + 'vw';
                    flake.style.width = size + 'px';
                    flake.style.height = size + 'px';
                    flake.style.opacity = opacity;
                    flake.style.animationDuration = duration + 's';

                    container.appendChild(flake);
                    setTimeout(() => flake.remove(), (duration + 1) * 1000);
                }, 45);
            }

            // AURORA - Realistic Aurora Borealis with canvas
            if (currentBiome.name === 'AURORA' && !activeWeatherInterval) {
                const intervals = [];

                // Create aurora canvas
                const canvas = document.createElement('canvas');
                canvas.id = 'aurora-canvas';
                canvas.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    z-index: 1;
                `;
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                container.appendChild(canvas);

                const ctx = canvas.getContext('2d');
                let time = 0;
                let animationId;

                // Aurora color palette (realistic northern lights colors)
                const auroraColors = [
                    { r: 80, g: 255, b: 150, a: 0.4 },   // Green (most common)
                    { r: 100, g: 255, b: 200, a: 0.35 }, // Cyan-green
                    { r: 150, g: 100, b: 255, a: 0.3 },  // Purple
                    { r: 100, g: 180, b: 255, a: 0.25 }, // Blue
                    { r: 255, g: 100, b: 150, a: 0.2 },  // Pink (rare)
                ];

                // Aurora curtain class for realistic wave movement
                class AuroraCurtain {
                    constructor(index, total) {
                        this.index = index;
                        this.baseX = (index / total) * canvas.width;
                        this.width = canvas.width / total * 1.5;
                        this.color = auroraColors[index % auroraColors.length];
                        this.phaseOffset = Math.random() * Math.PI * 2;
                        this.speed = 0.3 + Math.random() * 0.4;
                        this.waveAmplitude = 30 + Math.random() * 50;
                        this.segments = 60;
                        this.intensity = 0.5 + Math.random() * 0.5;
                    }

                    draw(ctx, time) {
                        ctx.beginPath();

                        const points = [];
                        for (let i = 0; i <= this.segments; i++) {
                            const t = i / this.segments;
                            const y = t * canvas.height * 0.7;

                            // Multiple sine waves for organic movement
                            const wave1 = Math.sin(t * 3 + time * this.speed + this.phaseOffset) * this.waveAmplitude;
                            const wave2 = Math.sin(t * 5 + time * this.speed * 0.7 + this.phaseOffset * 2) * this.waveAmplitude * 0.5;
                            const wave3 = Math.sin(t * 8 + time * this.speed * 1.3) * this.waveAmplitude * 0.3;

                            const x = this.baseX + wave1 + wave2 + wave3;
                            points.push({ x, y });
                        }

                        // Create gradient for each curtain
                        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height * 0.7);
                        const pulseIntensity = (Math.sin(time * 0.5 + this.phaseOffset) + 1) * 0.3 + 0.4;
                        const alpha = this.color.a * this.intensity * pulseIntensity;

                        gradient.addColorStop(0, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 0)`);
                        gradient.addColorStop(0.1, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${alpha * 0.3})`);
                        gradient.addColorStop(0.3, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${alpha})`);
                        gradient.addColorStop(0.6, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${alpha * 0.7})`);
                        gradient.addColorStop(0.85, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${alpha * 0.2})`);
                        gradient.addColorStop(1, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 0)`);

                        // Draw the curtain with soft edges
                        ctx.moveTo(points[0].x - this.width / 2, points[0].y);

                        for (let i = 1; i < points.length; i++) {
                            const xc = (points[i].x + points[i - 1].x) / 2;
                            const yc = (points[i].y + points[i - 1].y) / 2;
                            ctx.quadraticCurveTo(points[i - 1].x - this.width / 2, points[i - 1].y, xc - this.width / 2, yc);
                        }

                        // Right edge (going back up)
                        for (let i = points.length - 1; i >= 0; i--) {
                            const xc = i > 0 ? (points[i].x + points[i - 1].x) / 2 : points[0].x;
                            const yc = i > 0 ? (points[i].y + points[i - 1].y) / 2 : points[0].y;
                            if (i > 0) {
                                ctx.quadraticCurveTo(points[i].x + this.width / 2, points[i].y, xc + this.width / 2, yc);
                            }
                        }

                        ctx.closePath();
                        ctx.fillStyle = gradient;
                        ctx.filter = 'blur(8px)';
                        ctx.fill();
                        ctx.filter = 'none';
                    }
                }

                // Create multiple aurora curtains
                const numCurtains = 6;
                const curtains = [];
                for (let i = 0; i < numCurtains; i++) {
                    curtains.push(new AuroraCurtain(i, numCurtains));
                }

                // Animation loop
                function animateAurora() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // Dark sky gradient background
                    const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    skyGradient.addColorStop(0, 'rgba(5, 10, 30, 0.3)');
                    skyGradient.addColorStop(0.5, 'rgba(10, 20, 40, 0.1)');
                    skyGradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = skyGradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw stars
                    if (time < 0.1) {
                        canvas.stars = [];
                        for (let i = 0; i < 100; i++) {
                            canvas.stars.push({
                                x: Math.random() * canvas.width,
                                y: Math.random() * canvas.height * 0.6,
                                size: Math.random() * 1.5 + 0.5,
                                twinkle: Math.random() * Math.PI * 2
                            });
                        }
                    }

                    if (canvas.stars) {
                        canvas.stars.forEach(star => {
                            const twinkleAlpha = (Math.sin(time * 2 + star.twinkle) + 1) * 0.3 + 0.4;
                            ctx.beginPath();
                            ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                            ctx.fillStyle = `rgba(255, 255, 255, ${twinkleAlpha})`;
                            ctx.fill();
                        });
                    }

                    // Draw aurora curtains (back to front for proper layering)
                    ctx.globalCompositeOperation = 'screen';
                    curtains.forEach(curtain => curtain.draw(ctx, time));
                    ctx.globalCompositeOperation = 'source-over';

                    // Add glow effect overlay
                    const glowGradient = ctx.createRadialGradient(
                        canvas.width / 2, 0, 0,
                        canvas.width / 2, 0, canvas.height * 0.8
                    );
                    const glowPulse = (Math.sin(time * 0.3) + 1) * 0.05 + 0.05;
                    glowGradient.addColorStop(0, `rgba(100, 255, 180, ${glowPulse})`);
                    glowGradient.addColorStop(0.5, `rgba(80, 200, 255, ${glowPulse * 0.5})`);
                    glowGradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = glowGradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    time += 0.016;
                    animationId = requestAnimationFrame(animateAurora);
                }

                animateAurora();

                // Handle resize
                const resizeHandler = () => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                };
                window.addEventListener('resize', resizeHandler);

                // Aurora-tinted snowflakes
                intervals.push(setInterval(() => {
                    const flake = document.createElement('div');
                    flake.classList.add('snowflake');

                    const colors = ['#7efff5', '#7eff9e', '#b47eff', '#7eb4ff'];
                    const color = colors[Math.floor(Math.random() * colors.length)];

                    const layer = Math.floor(Math.random() * 3);
                    let size, duration, opacity;
                    if (layer === 0) {
                        size = 2 + Math.random() * 2;
                        duration = 6 + Math.random() * 2;
                        opacity = 0.4 + Math.random() * 0.2;
                    } else if (layer === 1) {
                        size = 4 + Math.random() * 2;
                        duration = 4 + Math.random() * 1.5;
                        opacity = 0.6 + Math.random() * 0.2;
                    } else {
                        size = 6 + Math.random() * 3;
                        duration = 2.5 + Math.random() * 1;
                        opacity = 0.8 + Math.random() * 0.2;
                    }

                    flake.style.left = Math.random() * 100 + 'vw';
                    flake.style.width = size + 'px';
                    flake.style.height = size + 'px';
                    flake.style.opacity = opacity;
                    flake.style.animationDuration = duration + 's';
                    flake.style.background = color;
                    flake.style.boxShadow = `0 0 ${size * 2}px ${color}`;

                    container.appendChild(flake);
                    setTimeout(() => flake.remove(), (duration + 1) * 1000);
                }, 40));

                activeWeatherInterval = {
                    isMultiple: true,
                    intervals: intervals,
                    animationId: animationId,
                    resizeHandler: resizeHandler,
                    clear: function () {
                        this.intervals.forEach(i => clearInterval(i));
                        cancelAnimationFrame(animationId);
                        window.removeEventListener('resize', this.resizeHandler);
                        const c = document.getElementById('aurora-canvas');
                        if (c) c.remove();
                    }
                };
            }

            // STARFALL - Realistic shooting stars and cosmic atmosphere
            if (currentBiome.name === 'STARFALL' && !activeWeatherInterval) {
                const intervals = [];

                // Create starfall canvas
                const canvas = document.createElement('canvas');
                canvas.id = 'starfall-canvas';
                canvas.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    z-index: 1;
                `;
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                container.appendChild(canvas);

                const ctx = canvas.getContext('2d');
                let time = 0;
                let animationId;

                // Stars array
                const backgroundStars = [];
                for (let i = 0; i < 200; i++) {
                    backgroundStars.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        size: Math.random() * 2 + 0.5,
                        twinkleSpeed: Math.random() * 2 + 1,
                        twinklePhase: Math.random() * Math.PI * 2,
                        color: Math.random() > 0.7 ? '#7c6aef' : (Math.random() > 0.5 ? '#a29bfe' : '#ffffff')
                    });
                }

                // Shooting stars array
                const shootingStars = [];

                class ShootingStar {
                    constructor() {
                        this.reset();
                    }

                    reset() {
                        this.x = Math.random() * canvas.width * 1.5;
                        this.y = -50;
                        this.length = 80 + Math.random() * 120;
                        this.speed = 8 + Math.random() * 12;
                        this.angle = Math.PI / 4 + (Math.random() - 0.5) * 0.3;
                        this.opacity = 0.7 + Math.random() * 0.3;
                        this.thickness = 1 + Math.random() * 2;
                        this.active = true;
                        this.trail = [];
                        // Color variations - mostly white/blue with occasional purple
                        const colorRand = Math.random();
                        if (colorRand > 0.8) {
                            this.color = { r: 124, g: 106, b: 239 }; // Purple
                        } else if (colorRand > 0.5) {
                            this.color = { r: 162, g: 155, b: 254 }; // Light purple
                        } else {
                            this.color = { r: 255, g: 255, b: 255 }; // White
                        }
                    }

                    update() {
                        this.x += Math.cos(this.angle) * this.speed;
                        this.y += Math.sin(this.angle) * this.speed;

                        // Add trail point
                        this.trail.unshift({ x: this.x, y: this.y });
                        if (this.trail.length > 20) this.trail.pop();

                        // Check if out of bounds
                        if (this.y > canvas.height + 100 || this.x > canvas.width + 100 || this.x < -100) {
                            this.active = false;
                        }
                    }

                    draw(ctx) {
                        if (this.trail.length < 2) return;

                        // Draw the trail with gradient
                        const gradient = ctx.createLinearGradient(
                            this.trail[this.trail.length - 1].x,
                            this.trail[this.trail.length - 1].y,
                            this.trail[0].x,
                            this.trail[0].y
                        );
                        gradient.addColorStop(0, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 0)`);
                        gradient.addColorStop(0.3, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.opacity * 0.5})`);
                        gradient.addColorStop(1, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.opacity})`);

                        ctx.beginPath();
                        ctx.moveTo(this.trail[0].x, this.trail[0].y);
                        for (let i = 1; i < this.trail.length; i++) {
                            ctx.lineTo(this.trail[i].x, this.trail[i].y);
                        }
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = this.thickness;
                        ctx.lineCap = 'round';
                        ctx.stroke();

                        // Draw head glow
                        const headGlow = ctx.createRadialGradient(
                            this.trail[0].x, this.trail[0].y, 0,
                            this.trail[0].x, this.trail[0].y, 8
                        );
                        headGlow.addColorStop(0, `rgba(255, 255, 255, ${this.opacity})`);
                        headGlow.addColorStop(0.5, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.opacity * 0.5})`);
                        headGlow.addColorStop(1, 'transparent');
                        ctx.beginPath();
                        ctx.arc(this.trail[0].x, this.trail[0].y, 8, 0, Math.PI * 2);
                        ctx.fillStyle = headGlow;
                        ctx.fill();
                    }
                }

                // Floating cosmic dust particles
                const cosmicDust = [];
                for (let i = 0; i < 50; i++) {
                    cosmicDust.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        size: Math.random() * 3 + 1,
                        speedX: (Math.random() - 0.5) * 0.5,
                        speedY: Math.random() * 0.3 + 0.1,
                        opacity: Math.random() * 0.5 + 0.2,
                        color: Math.random() > 0.5 ? '#7c6aef' : '#a29bfe'
                    });
                }

                // Animation loop
                function animateStarfall() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // Deep cosmic background gradient
                    const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    skyGradient.addColorStop(0, 'rgba(10, 10, 50, 0.4)');
                    skyGradient.addColorStop(0.3, 'rgba(26, 26, 94, 0.3)');
                    skyGradient.addColorStop(0.7, 'rgba(15, 15, 60, 0.2)');
                    skyGradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = skyGradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw twinkling background stars
                    backgroundStars.forEach(star => {
                        const twinkle = (Math.sin(time * star.twinkleSpeed + star.twinklePhase) + 1) * 0.4 + 0.2;
                        ctx.beginPath();
                        ctx.arc(star.x, star.y, star.size * twinkle, 0, Math.PI * 2);
                        ctx.fillStyle = star.color;
                        ctx.globalAlpha = twinkle;
                        ctx.fill();
                        ctx.globalAlpha = 1;

                        // Add subtle glow to some stars
                        if (star.size > 1.5) {
                            const glow = ctx.createRadialGradient(star.x, star.y, 0, star.x, star.y, star.size * 3);
                            glow.addColorStop(0, star.color);
                            glow.addColorStop(1, 'transparent');
                            ctx.fillStyle = glow;
                            ctx.globalAlpha = twinkle * 0.3;
                            ctx.beginPath();
                            ctx.arc(star.x, star.y, star.size * 3, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.globalAlpha = 1;
                        }
                    });

                    // Update and draw cosmic dust
                    cosmicDust.forEach(dust => {
                        dust.x += dust.speedX;
                        dust.y += dust.speedY;

                        // Wrap around
                        if (dust.y > canvas.height) dust.y = 0;
                        if (dust.x < 0) dust.x = canvas.width;
                        if (dust.x > canvas.width) dust.x = 0;

                        ctx.beginPath();
                        ctx.arc(dust.x, dust.y, dust.size, 0, Math.PI * 2);
                        ctx.fillStyle = dust.color;
                        ctx.globalAlpha = dust.opacity;
                        ctx.fill();
                        ctx.globalAlpha = 1;
                    });

                    // Spawn new shooting stars occasionally
                    if (Math.random() < 0.02) {
                        shootingStars.push(new ShootingStar());
                    }

                    // Update and draw shooting stars
                    for (let i = shootingStars.length - 1; i >= 0; i--) {
                        const star = shootingStars[i];
                        star.update();
                        star.draw(ctx);

                        if (!star.active) {
                            shootingStars.splice(i, 1);
                        }
                    }

                    // Nebula glow effect
                    const nebulaGlow = ctx.createRadialGradient(
                        canvas.width * 0.3, canvas.height * 0.2, 0,
                        canvas.width * 0.3, canvas.height * 0.2, canvas.width * 0.4
                    );
                    const glowPulse = (Math.sin(time * 0.2) + 1) * 0.03 + 0.02;
                    nebulaGlow.addColorStop(0, `rgba(124, 106, 239, ${glowPulse})`);
                    nebulaGlow.addColorStop(0.5, `rgba(162, 155, 254, ${glowPulse * 0.5})`);
                    nebulaGlow.addColorStop(1, 'transparent');
                    ctx.fillStyle = nebulaGlow;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    time += 0.016;
                    animationId = requestAnimationFrame(animateStarfall);
                }

                animateStarfall();

                // Handle resize
                const resizeHandler = () => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;

                    // Redistribute stars
                    backgroundStars.forEach(star => {
                        star.x = Math.random() * canvas.width;
                        star.y = Math.random() * canvas.height;
                    });
                };
                window.addEventListener('resize', resizeHandler);

                activeWeatherInterval = {
                    isMultiple: true,
                    intervals: intervals,
                    animationId: animationId,
                    resizeHandler: resizeHandler,
                    clear: function () {
                        this.intervals.forEach(i => clearInterval(i));
                        cancelAnimationFrame(animationId);
                        window.removeEventListener('resize', this.resizeHandler);
                        const c = document.getElementById('starfall-canvas');
                        if (c) c.remove();
                    }
                };
            }

            // HEAVEN - Divine golden atmosphere with falling light rays
            if (currentBiome.name === 'HEAVEN' && !activeWeatherInterval) {
                const intervals = [];

                // Create heaven canvas
                const canvas = document.createElement('canvas');
                canvas.id = 'heaven-canvas';
                canvas.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    z-index: 1;
                `;
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                container.appendChild(canvas);

                const ctx = canvas.getContext('2d');
                let time = 0;
                let animationId;

                // Performance multiplier for Max FPS Mode
                const mult = typeof getParticleMultiplier === 'function' ? getParticleMultiplier() : 1;

                // Light rays falling from above
                const lightRays = [];
                const rayCount = Math.max(3, Math.floor(15 * mult));
                for (let i = 0; i < rayCount; i++) {
                    lightRays.push({
                        x: Math.random() * canvas.width,
                        width: 3 + Math.random() * 8,
                        speed: 0.5 + Math.random() * 1,
                        opacity: 0.1 + Math.random() * 0.2,
                        phase: Math.random() * Math.PI * 2,
                        drift: (Math.random() - 0.5) * 0.5
                    });
                }

                // Floating golden particles - reduced for performance
                const divineParticles = [];
                const particleCount = Math.max(12, Math.floor(80 * mult));
                for (let i = 0; i < particleCount; i++) {
                    divineParticles.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        size: Math.random() * 3 + 1,
                        speedY: -(Math.random() * 0.5 + 0.2), // Floating upward
                        speedX: (Math.random() - 0.5) * 0.3,
                        opacity: Math.random() * 0.6 + 0.2,
                        twinkle: Math.random() * Math.PI * 2,
                        twinkleSpeed: Math.random() * 2 + 1,
                        color: Math.random() > 0.6 ? '#ffd700' : (Math.random() > 0.5 ? '#fff5cc' : '#f5d742')
                    });
                }

                // Ethereal orbs of light
                const orbs = [];
                for (let i = 0; i < 5; i++) {
                    orbs.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        size: 30 + Math.random() * 50,
                        speedX: (Math.random() - 0.5) * 0.3,
                        speedY: (Math.random() - 0.5) * 0.2,
                        opacity: 0.05 + Math.random() * 0.1,
                        pulse: Math.random() * Math.PI * 2
                    });
                }

                // Sparkle bursts
                const sparkles = [];

                // Animation loop
                function animateHeaven() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // Warm golden sky gradient
                    const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    skyGradient.addColorStop(0, 'rgba(205, 180, 150, 0.3)');
                    skyGradient.addColorStop(0.3, 'rgba(245, 215, 66, 0.15)');
                    skyGradient.addColorStop(0.6, 'rgba(255, 235, 200, 0.1)');
                    skyGradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = skyGradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw light rays from above
                    lightRays.forEach(ray => {
                        const sway = Math.sin(time * ray.speed + ray.phase) * 20;
                        const rayOpacity = ray.opacity * (0.7 + Math.sin(time * 0.5 + ray.phase) * 0.3);

                        const gradient = ctx.createLinearGradient(
                            ray.x + sway, 0,
                            ray.x + sway, canvas.height
                        );
                        gradient.addColorStop(0, `rgba(255, 215, 0, ${rayOpacity})`);
                        gradient.addColorStop(0.3, `rgba(255, 235, 180, ${rayOpacity * 0.8})`);
                        gradient.addColorStop(0.7, `rgba(255, 245, 220, ${rayOpacity * 0.4})`);
                        gradient.addColorStop(1, 'transparent');

                        ctx.beginPath();
                        ctx.moveTo(ray.x + sway - ray.width / 2, 0);
                        ctx.lineTo(ray.x + sway + ray.width / 2, 0);
                        ctx.lineTo(ray.x + sway + ray.width * 2, canvas.height);
                        ctx.lineTo(ray.x + sway - ray.width * 2, canvas.height);
                        ctx.closePath();
                        ctx.fillStyle = gradient;
                        ctx.fill();

                        ray.x += ray.drift;
                        if (ray.x < -50) ray.x = canvas.width + 50;
                        if (ray.x > canvas.width + 50) ray.x = -50;
                    });

                    // Draw ethereal orbs
                    orbs.forEach(orb => {
                        const pulseSize = orb.size * (1 + Math.sin(time + orb.pulse) * 0.2);
                        const pulseOpacity = orb.opacity * (0.7 + Math.sin(time * 0.5 + orb.pulse) * 0.3);

                        const orbGradient = ctx.createRadialGradient(
                            orb.x, orb.y, 0,
                            orb.x, orb.y, pulseSize
                        );
                        orbGradient.addColorStop(0, `rgba(255, 255, 255, ${pulseOpacity * 2})`);
                        orbGradient.addColorStop(0.3, `rgba(255, 235, 180, ${pulseOpacity})`);
                        orbGradient.addColorStop(0.7, `rgba(255, 215, 100, ${pulseOpacity * 0.5})`);
                        orbGradient.addColorStop(1, 'transparent');

                        ctx.beginPath();
                        ctx.arc(orb.x, orb.y, pulseSize, 0, Math.PI * 2);
                        ctx.fillStyle = orbGradient;
                        ctx.fill();

                        orb.x += orb.speedX;
                        orb.y += orb.speedY;

                        // Bounce off edges gently
                        if (orb.x < 0 || orb.x > canvas.width) orb.speedX *= -1;
                        if (orb.y < 0 || orb.y > canvas.height) orb.speedY *= -1;
                    });

                    // Draw floating divine particles
                    divineParticles.forEach(particle => {
                        const twinkle = (Math.sin(time * particle.twinkleSpeed + particle.twinkle) + 1) * 0.5;
                        const currentOpacity = particle.opacity * (0.5 + twinkle * 0.5);

                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size * twinkle, 0, Math.PI * 2);
                        ctx.fillStyle = particle.color;
                        ctx.globalAlpha = currentOpacity;
                        ctx.fill();

                        // Soft glow
                        const glow = ctx.createRadialGradient(
                            particle.x, particle.y, 0,
                            particle.x, particle.y, particle.size * 4
                        );
                        glow.addColorStop(0, particle.color);
                        glow.addColorStop(1, 'transparent');
                        ctx.fillStyle = glow;
                        ctx.globalAlpha = currentOpacity * 0.3;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size * 4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;

                        particle.x += particle.speedX;
                        particle.y += particle.speedY;

                        // Wrap around
                        if (particle.y < -10) {
                            particle.y = canvas.height + 10;
                            particle.x = Math.random() * canvas.width;
                        }
                        if (particle.x < 0) particle.x = canvas.width;
                        if (particle.x > canvas.width) particle.x = 0;
                    });

                    // Occasional sparkle bursts
                    if (Math.random() < 0.03) {
                        sparkles.push({
                            x: Math.random() * canvas.width,
                            y: Math.random() * canvas.height * 0.8,
                            life: 1,
                            size: 5 + Math.random() * 10
                        });
                    }

                    // Draw and update sparkles
                    for (let i = sparkles.length - 1; i >= 0; i--) {
                        const sparkle = sparkles[i];
                        const points = 4;
                        const outerRadius = sparkle.size * sparkle.life;
                        const innerRadius = outerRadius * 0.4;

                        ctx.beginPath();
                        for (let j = 0; j < points * 2; j++) {
                            const radius = j % 2 === 0 ? outerRadius : innerRadius;
                            const angle = (j * Math.PI) / points;
                            const x = sparkle.x + Math.cos(angle) * radius;
                            const y = sparkle.y + Math.sin(angle) * radius;
                            if (j === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.closePath();
                        ctx.fillStyle = `rgba(255, 255, 255, ${sparkle.life})`;
                        ctx.fill();

                        // Glow around sparkle
                        const sparkleGlow = ctx.createRadialGradient(
                            sparkle.x, sparkle.y, 0,
                            sparkle.x, sparkle.y, outerRadius * 2
                        );
                        sparkleGlow.addColorStop(0, `rgba(255, 235, 180, ${sparkle.life * 0.5})`);
                        sparkleGlow.addColorStop(1, 'transparent');
                        ctx.fillStyle = sparkleGlow;
                        ctx.beginPath();
                        ctx.arc(sparkle.x, sparkle.y, outerRadius * 2, 0, Math.PI * 2);
                        ctx.fill();

                        sparkle.life -= 0.02;
                        if (sparkle.life <= 0) sparkles.splice(i, 1);
                    }

                    // Soft divine glow from horizon
                    const horizonGlow = ctx.createRadialGradient(
                        canvas.width / 2, canvas.height * 0.3, 0,
                        canvas.width / 2, canvas.height * 0.3, canvas.width * 0.6
                    );
                    const glowPulse = (Math.sin(time * 0.3) + 1) * 0.02 + 0.03;
                    horizonGlow.addColorStop(0, `rgba(255, 235, 180, ${glowPulse})`);
                    horizonGlow.addColorStop(0.5, `rgba(255, 215, 100, ${glowPulse * 0.5})`);
                    horizonGlow.addColorStop(1, 'transparent');
                    ctx.fillStyle = horizonGlow;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    time += 0.016;
                    animationId = requestAnimationFrame(animateHeaven);
                }

                animateHeaven();

                // Handle resize
                const resizeHandler = () => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                };
                window.addEventListener('resize', resizeHandler);

                activeWeatherInterval = {
                    isMultiple: true,
                    intervals: intervals,
                    animationId: animationId,
                    resizeHandler: resizeHandler,
                    clear: function () {
                        this.intervals.forEach(i => clearInterval(i));
                        cancelAnimationFrame(animationId);
                        window.removeEventListener('resize', this.resizeHandler);
                        const c = document.getElementById('heaven-canvas');
                        if (c) c.remove();
                    }
                };
            }

            // CORRUPTION - Ominous rising fog and dark purple atmosphere
            if (currentBiome.name === 'CORRUPTION' && !activeWeatherInterval) {
                const intervals = [];

                // Create corruption canvas
                const canvas = document.createElement('canvas');
                canvas.id = 'corruption-canvas';
                canvas.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    z-index: 1;
                `;
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                container.appendChild(canvas);

                const ctx = canvas.getContext('2d');
                let time = 0;
                let animationId;

                // Fog layers for realistic rising mist
                const fogLayers = [];
                for (let i = 0; i < 8; i++) {
                    fogLayers.push({
                        y: canvas.height - (i * 80) - Math.random() * 50,
                        baseY: canvas.height - (i * 80),
                        amplitude: 20 + Math.random() * 30,
                        speed: 0.3 + Math.random() * 0.4,
                        phase: Math.random() * Math.PI * 2,
                        opacity: 0.15 - (i * 0.015),
                        height: 150 + Math.random() * 100,
                        color: i % 2 === 0 ? { r: 61, g: 26, b: 120 } : { r: 80, g: 40, b: 140 }
                    });
                }

                // Floating corruption particles
                const corruptionParticles = [];
                for (let i = 0; i < 60; i++) {
                    corruptionParticles.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        size: Math.random() * 4 + 1,
                        speedY: -(Math.random() * 0.8 + 0.3),
                        speedX: (Math.random() - 0.5) * 0.5,
                        opacity: Math.random() * 0.6 + 0.2,
                        pulse: Math.random() * Math.PI * 2,
                        color: Math.random() > 0.5 ? '#9b59b6' : '#6c3483'
                    });
                }

                // Dark energy wisps
                const wisps = [];
                for (let i = 0; i < 12; i++) {
                    wisps.push({
                        x: Math.random() * canvas.width,
                        y: canvas.height + Math.random() * 200,
                        width: 100 + Math.random() * 150,
                        height: 200 + Math.random() * 300,
                        speedY: -(Math.random() * 0.5 + 0.2),
                        speedX: (Math.random() - 0.5) * 0.3,
                        opacity: 0.1 + Math.random() * 0.15,
                        phase: Math.random() * Math.PI * 2,
                        twist: Math.random() * 0.02
                    });
                }

                // Pulsing corruption orbs
                const orbs = [];
                for (let i = 0; i < 4; i++) {
                    orbs.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        size: 40 + Math.random() * 60,
                        pulse: Math.random() * Math.PI * 2,
                        driftX: (Math.random() - 0.5) * 0.2,
                        driftY: (Math.random() - 0.5) * 0.15
                    });
                }

                // Animation loop
                function animateCorruption() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // Deep purple sky gradient
                    const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    skyGradient.addColorStop(0, 'rgba(20, 10, 40, 0.4)');
                    skyGradient.addColorStop(0.4, 'rgba(40, 20, 80, 0.3)');
                    skyGradient.addColorStop(0.7, 'rgba(61, 26, 120, 0.25)');
                    skyGradient.addColorStop(1, 'rgba(80, 40, 140, 0.3)');
                    ctx.fillStyle = skyGradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw pulsing corruption orbs (behind fog)
                    orbs.forEach(orb => {
                        const pulseSize = orb.size * (1 + Math.sin(time * 0.8 + orb.pulse) * 0.3);
                        const pulseOpacity = 0.08 + Math.sin(time * 0.5 + orb.pulse) * 0.04;

                        const orbGradient = ctx.createRadialGradient(
                            orb.x, orb.y, 0,
                            orb.x, orb.y, pulseSize
                        );
                        orbGradient.addColorStop(0, `rgba(155, 89, 182, ${pulseOpacity * 2})`);
                        orbGradient.addColorStop(0.4, `rgba(108, 52, 131, ${pulseOpacity})`);
                        orbGradient.addColorStop(0.7, `rgba(61, 26, 120, ${pulseOpacity * 0.5})`);
                        orbGradient.addColorStop(1, 'transparent');

                        ctx.beginPath();
                        ctx.arc(orb.x, orb.y, pulseSize, 0, Math.PI * 2);
                        ctx.fillStyle = orbGradient;
                        ctx.fill();

                        orb.x += orb.driftX;
                        orb.y += orb.driftY;

                        // Wrap around
                        if (orb.x < -orb.size) orb.x = canvas.width + orb.size;
                        if (orb.x > canvas.width + orb.size) orb.x = -orb.size;
                        if (orb.y < -orb.size) orb.y = canvas.height + orb.size;
                        if (orb.y > canvas.height + orb.size) orb.y = -orb.size;
                    });

                    // Draw rising wisps
                    wisps.forEach(wisp => {
                        const waveX = Math.sin(time * 0.5 + wisp.phase) * 30;

                        const wispGradient = ctx.createRadialGradient(
                            wisp.x + waveX, wisp.y, 0,
                            wisp.x + waveX, wisp.y, wisp.height / 2
                        );
                        wispGradient.addColorStop(0, `rgba(100, 50, 150, ${wisp.opacity})`);
                        wispGradient.addColorStop(0.5, `rgba(61, 26, 120, ${wisp.opacity * 0.6})`);
                        wispGradient.addColorStop(1, 'transparent');

                        ctx.save();
                        ctx.translate(wisp.x + waveX, wisp.y);
                        ctx.scale(wisp.width / wisp.height, 1);
                        ctx.beginPath();
                        ctx.arc(0, 0, wisp.height / 2, 0, Math.PI * 2);
                        ctx.fillStyle = wispGradient;
                        ctx.fill();
                        ctx.restore();

                        wisp.y += wisp.speedY;
                        wisp.x += wisp.speedX;

                        // Reset when off screen
                        if (wisp.y < -wisp.height) {
                            wisp.y = canvas.height + wisp.height;
                            wisp.x = Math.random() * canvas.width;
                        }
                    });

                    // Draw fog layers (rising mist effect)
                    fogLayers.forEach((layer, index) => {
                        const wave = Math.sin(time * layer.speed + layer.phase) * layer.amplitude;
                        const currentY = layer.baseY + wave - (time * 10 % 50);

                        const fogGradient = ctx.createLinearGradient(0, currentY, 0, currentY - layer.height);
                        fogGradient.addColorStop(0, `rgba(${layer.color.r}, ${layer.color.g}, ${layer.color.b}, ${layer.opacity})`);
                        fogGradient.addColorStop(0.3, `rgba(${layer.color.r}, ${layer.color.g}, ${layer.color.b}, ${layer.opacity * 0.7})`);
                        fogGradient.addColorStop(0.7, `rgba(${layer.color.r}, ${layer.color.g}, ${layer.color.b}, ${layer.opacity * 0.3})`);
                        fogGradient.addColorStop(1, 'transparent');

                        ctx.fillStyle = fogGradient;

                        // Draw wavy fog shape
                        ctx.beginPath();
                        ctx.moveTo(0, canvas.height);

                        for (let x = 0; x <= canvas.width; x += 20) {
                            const fogWave = Math.sin((x * 0.01) + time * layer.speed + layer.phase) * 20;
                            ctx.lineTo(x, currentY + fogWave);
                        }

                        ctx.lineTo(canvas.width, canvas.height);
                        ctx.closePath();
                        ctx.fill();
                    });

                    // Draw floating corruption particles
                    corruptionParticles.forEach(particle => {
                        const pulse = (Math.sin(time * 2 + particle.pulse) + 1) * 0.5;
                        const currentOpacity = particle.opacity * (0.5 + pulse * 0.5);
                        const currentSize = particle.size * (0.8 + pulse * 0.4);

                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, currentSize, 0, Math.PI * 2);
                        ctx.fillStyle = particle.color;
                        ctx.globalAlpha = currentOpacity;
                        ctx.fill();

                        // Particle glow
                        const glow = ctx.createRadialGradient(
                            particle.x, particle.y, 0,
                            particle.x, particle.y, currentSize * 3
                        );
                        glow.addColorStop(0, particle.color);
                        glow.addColorStop(1, 'transparent');
                        ctx.fillStyle = glow;
                        ctx.globalAlpha = currentOpacity * 0.4;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, currentSize * 3, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;

                        particle.x += particle.speedX;
                        particle.y += particle.speedY;

                        // Reset when off screen
                        if (particle.y < -20) {
                            particle.y = canvas.height + 20;
                            particle.x = Math.random() * canvas.width;
                        }
                        if (particle.x < 0) particle.x = canvas.width;
                        if (particle.x > canvas.width) particle.x = 0;
                    });

                    // Vignette effect for ominous feel
                    const vignette = ctx.createRadialGradient(
                        canvas.width / 2, canvas.height / 2, canvas.width * 0.3,
                        canvas.width / 2, canvas.height / 2, canvas.width * 0.8
                    );
                    vignette.addColorStop(0, 'transparent');
                    vignette.addColorStop(1, 'rgba(20, 10, 40, 0.3)');
                    ctx.fillStyle = vignette;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    time += 0.016;
                    animationId = requestAnimationFrame(animateCorruption);
                }

                animateCorruption();

                // Handle resize
                const resizeHandler = () => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;

                    // Recalculate fog layer positions
                    fogLayers.forEach((layer, i) => {
                        layer.baseY = canvas.height - (i * 80);
                    });
                };
                window.addEventListener('resize', resizeHandler);

                activeWeatherInterval = {
                    isMultiple: true,
                    intervals: intervals,
                    animationId: animationId,
                    resizeHandler: resizeHandler,
                    clear: function () {
                        this.intervals.forEach(i => clearInterval(i));
                        cancelAnimationFrame(animationId);
                        window.removeEventListener('resize', this.resizeHandler);
                        const c = document.getElementById('corruption-canvas');
                        if (c) c.remove();
                    }
                };
            }

            // NULL - Void-like grey/white fog atmosphere
            if (currentBiome.name === 'NULL' && !activeWeatherInterval) {
                const intervals = [];

                // Create background image
                const bgImage = document.createElement('div');
                bgImage.id = 'null-bg';
                bgImage.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background-image: url('biome pictures/NULL.jpeg');
                    background-size: cover;
                    background-position: center;
                    opacity: 0.5;
                    pointer-events: none;
                    z-index: 0;
                `;
                container.appendChild(bgImage);

                // Create null canvas
                const canvas = document.createElement('canvas');
                canvas.id = 'null-canvas';
                canvas.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    z-index: 1;
                `;
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                container.appendChild(canvas);

                const ctx = canvas.getContext('2d');
                let time = 0;
                let animationId;

                // Dense fog layers
                const fogLayers = [];
                for (let i = 0; i < 6; i++) {
                    fogLayers.push({
                        y: (i / 6) * canvas.height,
                        opacity: 0.15 + Math.random() * 0.1,
                        speed: 0.2 + Math.random() * 0.3,
                        phase: Math.random() * Math.PI * 2,
                        height: 200 + Math.random() * 150
                    });
                }

                // Floating void particles
                const voidParticles = [];
                for (let i = 0; i < 40; i++) {
                    voidParticles.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        size: Math.random() * 3 + 1,
                        speedX: (Math.random() - 0.5) * 0.3,
                        speedY: (Math.random() - 0.5) * 0.3,
                        opacity: Math.random() * 0.4 + 0.1,
                        pulse: Math.random() * Math.PI * 2
                    });
                }

                // Static noise for void effect - use offscreen canvas
                let noiseCanvas = document.createElement('canvas');
                noiseCanvas.width = 128;
                noiseCanvas.height = 128;
                let noiseCtx = noiseCanvas.getContext('2d');

                function generateNoise() {
                    const imageData = noiseCtx.createImageData(128, 128);
                    for (let i = 0; i < imageData.data.length; i += 4) {
                        const noise = Math.random() * 40 + 180; // Light grey noise
                        imageData.data[i] = noise;
                        imageData.data[i + 1] = noise;
                        imageData.data[i + 2] = noise;
                        imageData.data[i + 3] = 12 + Math.random() * 8; // Very subtle
                    }
                    noiseCtx.putImageData(imageData, 0, 0);
                }
                generateNoise();

                // Animation loop
                function animateNull() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // Base grey/white background
                    const bgGradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                    bgGradient.addColorStop(0, 'rgba(180, 180, 180, 0.5)');
                    bgGradient.addColorStop(0.5, 'rgba(200, 200, 200, 0.4)');
                    bgGradient.addColorStop(1, 'rgba(160, 160, 160, 0.5)');
                    ctx.fillStyle = bgGradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw subtle noise overlay (regenerate occasionally)
                    if (Math.random() < 0.05) {
                        generateNoise();
                    }
                    // Tile the noise pattern across the canvas
                    ctx.globalAlpha = 0.3;
                    for (let x = 0; x < canvas.width; x += 128) {
                        for (let y = 0; y < canvas.height; y += 128) {
                            ctx.drawImage(noiseCanvas, x, y);
                        }
                    }
                    ctx.globalAlpha = 1;

                    // Draw fog layers
                    fogLayers.forEach((layer, index) => {
                        const wave = Math.sin(time * layer.speed + layer.phase) * 30;

                        const fogGradient = ctx.createLinearGradient(
                            0, layer.y - layer.height / 2 + wave,
                            0, layer.y + layer.height / 2 + wave
                        );
                        fogGradient.addColorStop(0, 'transparent');
                        fogGradient.addColorStop(0.3, `rgba(220, 220, 220, ${layer.opacity})`);
                        fogGradient.addColorStop(0.5, `rgba(240, 240, 240, ${layer.opacity * 1.2})`);
                        fogGradient.addColorStop(0.7, `rgba(220, 220, 220, ${layer.opacity})`);
                        fogGradient.addColorStop(1, 'transparent');

                        ctx.fillStyle = fogGradient;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    });

                    // Draw horizontal fog bands
                    for (let i = 0; i < 3; i++) {
                        const bandY = (i / 3) * canvas.height + Math.sin(time * 0.3 + i) * 50;
                        const bandGradient = ctx.createLinearGradient(0, bandY - 100, 0, bandY + 100);
                        bandGradient.addColorStop(0, 'transparent');
                        bandGradient.addColorStop(0.5, `rgba(255, 255, 255, ${0.1 + Math.sin(time * 0.5 + i) * 0.05})`);
                        bandGradient.addColorStop(1, 'transparent');
                        ctx.fillStyle = bandGradient;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }

                    // Draw floating void particles
                    voidParticles.forEach(particle => {
                        const pulse = (Math.sin(time * 1.5 + particle.pulse) + 1) * 0.5;
                        const currentOpacity = particle.opacity * (0.5 + pulse * 0.5);

                        // Particle
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(255, 255, 255, ${currentOpacity})`;
                        ctx.fill();

                        // Soft glow
                        const glow = ctx.createRadialGradient(
                            particle.x, particle.y, 0,
                            particle.x, particle.y, particle.size * 5
                        );
                        glow.addColorStop(0, `rgba(255, 255, 255, ${currentOpacity * 0.5})`);
                        glow.addColorStop(1, 'transparent');
                        ctx.fillStyle = glow;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size * 5, 0, Math.PI * 2);
                        ctx.fill();

                        // Slow drifting movement
                        particle.x += particle.speedX + Math.sin(time + particle.pulse) * 0.1;
                        particle.y += particle.speedY + Math.cos(time + particle.pulse) * 0.1;

                        // Wrap around
                        if (particle.x < 0) particle.x = canvas.width;
                        if (particle.x > canvas.width) particle.x = 0;
                        if (particle.y < 0) particle.y = canvas.height;
                        if (particle.y > canvas.height) particle.y = 0;
                    });

                    // Central void glow (pulsing)
                    const voidPulse = (Math.sin(time * 0.3) + 1) * 0.03 + 0.02;
                    const voidGlow = ctx.createRadialGradient(
                        canvas.width / 2, canvas.height / 2, 0,
                        canvas.width / 2, canvas.height / 2, canvas.width * 0.6
                    );
                    voidGlow.addColorStop(0, `rgba(255, 255, 255, ${voidPulse})`);
                    voidGlow.addColorStop(0.5, `rgba(220, 220, 220, ${voidPulse * 0.5})`);
                    voidGlow.addColorStop(1, 'transparent');
                    ctx.fillStyle = voidGlow;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Edge fade (stronger white at edges for void feel)
                    const edgeFade = ctx.createRadialGradient(
                        canvas.width / 2, canvas.height / 2, canvas.width * 0.2,
                        canvas.width / 2, canvas.height / 2, canvas.width * 0.8
                    );
                    edgeFade.addColorStop(0, 'transparent');
                    edgeFade.addColorStop(1, 'rgba(200, 200, 200, 0.3)');
                    ctx.fillStyle = edgeFade;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    time += 0.016;
                    animationId = requestAnimationFrame(animateNull);
                }

                animateNull();

                // Handle resize
                const resizeHandler = () => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                    noiseData = null; // Force noise regeneration
                };
                window.addEventListener('resize', resizeHandler);

                activeWeatherInterval = {
                    isMultiple: true,
                    intervals: intervals,
                    animationId: animationId,
                    resizeHandler: resizeHandler,
                    clear: function () {
                        this.intervals.forEach(i => clearInterval(i));
                        cancelAnimationFrame(animationId);
                        window.removeEventListener('resize', this.resizeHandler);
                        const c = document.getElementById('null-canvas');
                        if (c) c.remove();
                        const bg = document.getElementById('null-bg');
                        if (bg) bg.remove();
                    }
                };
            }

            // JUNGLE - Green particles and dark fog atmosphere
            if (currentBiome.name === 'JUNGLE' && !activeWeatherInterval) {
                const intervals = [];

                // Create background image
                const bgImage = document.createElement('div');
                bgImage.id = 'jungle-bg';
                bgImage.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background-image: url('biome pictures/JUNGLE.png');
                    background-size: cover;
                    background-position: center;
                    opacity: 0.4;
                    pointer-events: none;
                    z-index: 0;
                `;
                container.appendChild(bgImage);

                // Create jungle canvas (for particles)
                const canvas = document.createElement('canvas');
                canvas.id = 'jungle-canvas';
                canvas.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    z-index: 1;
                `;
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                container.appendChild(canvas);

                const ctx = canvas.getContext('2d');
                let time = 0;
                let animationId;

                // Floating particles (various green hues)
                const particles = [];
                for (let i = 0; i < 60; i++) {
                    particles.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        size: 2 + Math.random() * 4,
                        speedX: (Math.random() - 0.5) * 0.3,
                        speedY: -0.2 - Math.random() * 0.3, // Slowly float up
                        opacity: 0.3 + Math.random() * 0.4,
                        phase: Math.random() * Math.PI * 2,
                        color: Math.random() > 0.5 ? '#228B22' : '#006400' // Forest green or dark green
                    });
                }

                // Animation loop
                function animateJungle() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // Dark green fog background
                    const fogGradient = ctx.createRadialGradient(
                        canvas.width / 2, canvas.height / 2, 0,
                        canvas.width / 2, canvas.height / 2, canvas.width * 0.9
                    );
                    fogGradient.addColorStop(0, 'rgba(0, 50, 0, 0.2)');
                    fogGradient.addColorStop(0.4, 'rgba(0, 40, 0, 0.25)');
                    fogGradient.addColorStop(0.7, 'rgba(0, 30, 0, 0.3)');
                    fogGradient.addColorStop(1, 'rgba(0, 20, 0, 0.35)');
                    ctx.fillStyle = fogGradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Edge fog (darker at edges)
                    const edgeFog = ctx.createRadialGradient(
                        canvas.width / 2, canvas.height / 2, canvas.width * 0.3,
                        canvas.width / 2, canvas.height / 2, canvas.width * 0.8
                    );
                    edgeFog.addColorStop(0, 'transparent');
                    edgeFog.addColorStop(1, 'rgba(0, 30, 0, 0.4)');
                    ctx.fillStyle = edgeFog;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw particles
                    particles.forEach(particle => {
                        const pulse = (Math.sin(time * 2 + particle.phase) + 1) * 0.3 + 0.7;

                        // Particle glow
                        const glow = ctx.createRadialGradient(
                            particle.x, particle.y, 0,
                            particle.x, particle.y, particle.size * 3
                        );
                        glow.addColorStop(0, particle.color);
                        glow.addColorStop(0.5, `rgba(34, 139, 34, ${particle.opacity * pulse * 0.5})`);
                        glow.addColorStop(1, 'transparent');
                        ctx.fillStyle = glow;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size * 3, 0, Math.PI * 2);
                        ctx.fill();

                        // Particle core
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size * pulse, 0, Math.PI * 2);
                        ctx.fillStyle = particle.color;
                        ctx.globalAlpha = particle.opacity * pulse;
                        ctx.fill();
                        ctx.globalAlpha = 1;

                        // Update position
                        particle.x += particle.speedX + Math.sin(time + particle.phase) * 0.2;
                        particle.y += particle.speedY;

                        // Wrap around
                        if (particle.y < -10) particle.y = canvas.height + 10;
                        if (particle.x < 0) particle.x = canvas.width;
                        if (particle.x > canvas.width) particle.x = 0;
                    });

                    time += 0.016;
                    animationId = requestAnimationFrame(animateJungle);
                }

                animateJungle();

                // Handle resize
                const resizeHandler = () => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                };
                window.addEventListener('resize', resizeHandler);

                activeWeatherInterval = {
                    isMultiple: true,
                    intervals: intervals,
                    animationId: animationId,
                    resizeHandler: resizeHandler,
                    clear: function () {
                        this.intervals.forEach(i => clearInterval(i));
                        cancelAnimationFrame(animationId);
                        window.removeEventListener('resize', this.resizeHandler);
                        const c = document.getElementById('jungle-canvas');
                        if (c) c.remove();
                        const bg = document.getElementById('jungle-bg');
                        if (bg) bg.remove();
                    }
                };
            }

            // BLOOD RAIN - Crimson atmosphere, blood rain, and glowing crosses
            if (currentBiome.name === 'BLOOD RAIN' && !activeWeatherInterval) {
                const intervals = [];

                // Create blood rain canvas
                const canvas = document.createElement('canvas');
                canvas.id = 'blood-rain-canvas';
                canvas.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    z-index: 1;
                `;
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                container.appendChild(canvas);

                const ctx = canvas.getContext('2d');
                let time = 0;
                let animationId;
                let frameSkip = 0; // For adaptive frame skipping

                // Blood Rain Drops - reduced to 60 for performance (was 200)
                const drops = [];
                const dropCount = (typeof PerfMonitor !== 'undefined' && PerfMonitor.fps < 30) ? 30 : 60;
                for (let i = 0; i < dropCount; i++) {
                    drops.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        length: 30 + Math.random() * 40,
                        speed: 20 + Math.random() * 15,
                        opacity: 0.5 + Math.random() * 0.5
                    });
                }

                // Floating Crosses - Reduced to 3 main ones for performance
                const crosses = [];
                const crossPositions = [
                    { x: 0.08, y: 0.5, size: 100 },    // Left (main)
                    { x: 0.92, y: 0.5, size: 100 },    // Right (main)
                    { x: 0.5, y: 0.45, size: 130 },    // Center (main, largest)
                ];

                for (let i = 0; i < crossPositions.length; i++) {
                    const pos = crossPositions[i];
                    crosses.push({
                        x: pos.x * canvas.width,
                        y: pos.y * canvas.height,
                        size: pos.size,
                        rotation: (Math.random() - 0.5) * 0.15,
                        rotationSpeed: 0,
                        floatSpeed: 0,
                        opacity: i < 3 ? 0.95 : 0.7, // Main crosses more visible
                        type: i === 2 ? 'celtic' : 'gothic' // Center is celtic
                    });
                }

                function animateBloodRain() {
                    // Frame skipping for low FPS
                    frameSkip++;
                    if (typeof PerfMonitor !== 'undefined' && PerfMonitor.fps < 30 && frameSkip % 2 !== 0) {
                        animationId = requestAnimationFrame(animateBloodRain);
                        return;
                    }

                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // Red Tint Background (Atmosphere)
                    ctx.fillStyle = 'rgba(40, 0, 0, 0.3)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw Crosses - SIMPLIFIED for performance (no shadows!)
                    ctx.shadowBlur = 0; // Disable shadows completely
                    crosses.forEach(cross => {
                        ctx.save();
                        ctx.translate(cross.x, cross.y);

                        // Slight floating animation
                        const floatY = Math.sin(time * 0.3 + cross.x * 0.01) * 5;
                        ctx.translate(0, floatY);
                        ctx.rotate(cross.rotation);

                        const s = cross.size;
                        ctx.beginPath();

                        if (cross.type === 'gothic') {
                            // Simplified Gothic Cross
                            const longArm = s * 1.8;
                            const shortArm = s * 0.8;
                            const w = s * 0.2;
                            const flare = s * 0.35;

                            ctx.moveTo(-w / 2, -w / 2);
                            ctx.lineTo(-flare / 2, -shortArm);
                            ctx.lineTo(0, -shortArm - flare / 2);
                            ctx.lineTo(flare / 2, -shortArm);
                            ctx.lineTo(w / 2, -w / 2);
                            ctx.lineTo(shortArm, -flare / 2);
                            ctx.lineTo(shortArm + flare / 2, 0);
                            ctx.lineTo(shortArm, flare / 2);
                            ctx.lineTo(w / 2, w / 2);
                            ctx.lineTo(flare / 2, longArm);
                            ctx.lineTo(0, longArm + flare);
                            ctx.lineTo(-flare / 2, longArm);
                            ctx.lineTo(-w / 2, w / 2);
                            ctx.lineTo(-shortArm, flare / 2);
                            ctx.lineTo(-shortArm - flare / 2, 0);
                            ctx.lineTo(-shortArm, -flare / 2);
                            ctx.closePath();
                        } else {
                            // Simplified Celtic Cross
                            const arm = s * 0.9;
                            const ringR = s * 0.55;
                            const w = s * 0.18;
                            const flare = s * 0.35;

                            ctx.moveTo(-w / 2, -w / 2);
                            ctx.lineTo(-flare / 2, -arm);
                            ctx.lineTo(flare / 2, -arm);
                            ctx.lineTo(w / 2, -w / 2);
                            ctx.lineTo(arm, -flare / 2);
                            ctx.lineTo(arm, flare / 2);
                            ctx.lineTo(w / 2, w / 2);
                            ctx.lineTo(flare / 2, arm * 1.4);
                            ctx.lineTo(-flare / 2, arm * 1.4);
                            ctx.lineTo(-w / 2, w / 2);
                            ctx.lineTo(-arm, flare / 2);
                            ctx.lineTo(-arm, -flare / 2);
                            ctx.closePath();
                            ctx.moveTo(ringR, 0);
                            ctx.arc(0, 0, ringR, 0, Math.PI * 2);
                        }

                        // Black fill with red stroke (NO shadows for performance)
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                        ctx.fill();
                        ctx.strokeStyle = '#cc0000';
                        ctx.lineWidth = 3;
                        ctx.stroke();

                        ctx.restore();
                    });

                    // Draw Blood Rain - batched for performance
                    ctx.beginPath();
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 1.5;
                    ctx.globalAlpha = 0.7; // Fixed opacity for batching

                    drops.forEach(drop => {
                        ctx.moveTo(drop.x, drop.y);
                        ctx.lineTo(drop.x, drop.y + drop.length);
                        drop.y += drop.speed;
                        if (drop.y > canvas.height) {
                            drop.y = -drop.length;
                            drop.x = Math.random() * canvas.width;
                        }
                    });
                    ctx.stroke();
                    ctx.globalAlpha = 1;

                    // Simple red vignette (no gradient - much faster)
                    ctx.fillStyle = 'rgba(30, 0, 0, 0.15)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    time += 0.016;
                    animationId = requestAnimationFrame(animateBloodRain);
                }

                animateBloodRain();

                const resizeHandler = () => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                };
                window.addEventListener('resize', resizeHandler);

                activeWeatherInterval = {
                    isMultiple: true,
                    intervals: intervals,
                    animationId: animationId,
                    resizeHandler: resizeHandler,
                    clear: function () {
                        this.intervals.forEach(i => clearInterval(i));
                        cancelAnimationFrame(animationId);
                        window.removeEventListener('resize', this.resizeHandler);
                        const c = document.getElementById('blood-rain-canvas');
                        if (c) c.remove();
                    }
                };
            }

            // GRAVEYARD - Foggy grey atmosphere with tombstone silhouettes
            if (currentBiome.name === 'GRAVEYARD' && !activeWeatherInterval) {
                const intervals = [];

                // Create graveyard canvas
                const canvas = document.createElement('canvas');
                canvas.id = 'graveyard-canvas';
                canvas.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    z-index: 1;
                `;
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                container.appendChild(canvas);

                const ctx = canvas.getContext('2d');
                let time = 0;
                let animationId;

                // Performance multiplier for Max FPS Mode
                const mult = typeof getParticleMultiplier === 'function' ? getParticleMultiplier() : 1;

                // Tombstones - various shapes positioned along the bottom
                const tombstones = [];
                const tombstoneTypes = ['cross', 'rounded', 'flat', 'obelisk', 'angel'];
                const tombstoneCount = Math.max(5, Math.floor(20 * mult));

                for (let i = 0; i < tombstoneCount; i++) {
                    tombstones.push({
                        x: (i / tombstoneCount) * canvas.width + (Math.random() - 0.5) * 100,
                        y: canvas.height - 50 - Math.random() * 100,
                        width: 30 + Math.random() * 40,
                        height: 60 + Math.random() * 80,
                        type: tombstoneTypes[Math.floor(Math.random() * tombstoneTypes.length)],
                        tilt: (Math.random() - 0.5) * 0.15
                    });
                }

                // Fog particles - reduced for performance
                const fogParticles = [];
                const fogCount = Math.max(8, Math.floor(50 * mult));
                for (let i = 0; i < fogCount; i++) {
                    fogParticles.push({
                        x: Math.random() * canvas.width,
                        y: canvas.height * 0.5 + Math.random() * canvas.height * 0.5,
                        size: 100 + Math.random() * 200,
                        speed: 0.2 + Math.random() * 0.3,
                        opacity: 0.1 + Math.random() * 0.2
                    });
                }

                // Floating spirits/wisps - reduced for performance
                const spirits = [];
                const spiritCount = Math.max(2, Math.floor(8 * mult));
                for (let i = 0; i < spiritCount; i++) {
                    spirits.push({
                        x: Math.random() * canvas.width,
                        y: canvas.height * 0.3 + Math.random() * canvas.height * 0.4,
                        size: 15 + Math.random() * 25,
                        speedX: (Math.random() - 0.5) * 0.5,
                        speedY: (Math.random() - 0.5) * 0.3,
                        opacity: 0.3 + Math.random() * 0.4,
                        phase: Math.random() * Math.PI * 2
                    });
                }

                function drawTombstone(ctx, x, y, width, height, type, tilt) {
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(tilt);

                    ctx.fillStyle = 'rgba(30, 35, 40, 0.9)';
                    ctx.strokeStyle = 'rgba(60, 65, 70, 0.6)';
                    ctx.lineWidth = 2;

                    ctx.beginPath();

                    switch (type) {
                        case 'cross':
                            // Cross-topped tombstone
                            const cw = width * 0.15;
                            ctx.moveTo(-width / 2, 0);
                            ctx.lineTo(-width / 2, -height * 0.6);
                            ctx.lineTo(-cw, -height * 0.6);
                            ctx.lineTo(-cw, -height * 0.8);
                            ctx.lineTo(-width * 0.3, -height * 0.8);
                            ctx.lineTo(-width * 0.3, -height);
                            ctx.lineTo(width * 0.3, -height);
                            ctx.lineTo(width * 0.3, -height * 0.8);
                            ctx.lineTo(cw, -height * 0.8);
                            ctx.lineTo(cw, -height * 0.6);
                            ctx.lineTo(width / 2, -height * 0.6);
                            ctx.lineTo(width / 2, 0);
                            break;

                        case 'rounded':
                            // Rounded top tombstone
                            ctx.moveTo(-width / 2, 0);
                            ctx.lineTo(-width / 2, -height * 0.6);
                            ctx.quadraticCurveTo(-width / 2, -height, 0, -height);
                            ctx.quadraticCurveTo(width / 2, -height, width / 2, -height * 0.6);
                            ctx.lineTo(width / 2, 0);
                            break;

                        case 'flat':
                            // Simple flat-topped tombstone
                            ctx.rect(-width / 2, -height, width, height);
                            break;

                        case 'obelisk':
                            // Tall pointed obelisk
                            ctx.moveTo(-width / 3, 0);
                            ctx.lineTo(-width / 3, -height * 0.85);
                            ctx.lineTo(0, -height);
                            ctx.lineTo(width / 3, -height * 0.85);
                            ctx.lineTo(width / 3, 0);
                            break;

                        case 'angel':
                            // Angel-topped tombstone (simplified)
                            ctx.moveTo(-width / 2, 0);
                            ctx.lineTo(-width / 2, -height * 0.5);
                            ctx.lineTo(-width * 0.3, -height * 0.5);
                            ctx.lineTo(-width * 0.3, -height * 0.7);
                            ctx.quadraticCurveTo(0, -height - 10, width * 0.3, -height * 0.7);
                            ctx.lineTo(width * 0.3, -height * 0.5);
                            ctx.lineTo(width / 2, -height * 0.5);
                            ctx.lineTo(width / 2, 0);
                            break;
                    }

                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    ctx.restore();
                }

                function animateGraveyard() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // Dark grey-blue sky gradient
                    const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    skyGradient.addColorStop(0, 'rgba(25, 30, 40, 0.5)');
                    skyGradient.addColorStop(0.4, 'rgba(40, 45, 55, 0.4)');
                    skyGradient.addColorStop(0.7, 'rgba(50, 55, 65, 0.3)');
                    skyGradient.addColorStop(1, 'rgba(35, 40, 50, 0.4)');
                    ctx.fillStyle = skyGradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw fog layer (back)
                    fogParticles.forEach(fog => {
                        const gradient = ctx.createRadialGradient(
                            fog.x, fog.y, 0,
                            fog.x, fog.y, fog.size
                        );
                        gradient.addColorStop(0, `rgba(100, 110, 120, ${fog.opacity})`);
                        gradient.addColorStop(0.5, `rgba(80, 90, 100, ${fog.opacity * 0.5})`);
                        gradient.addColorStop(1, 'transparent');
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(fog.x, fog.y, fog.size, 0, Math.PI * 2);
                        ctx.fill();

                        // Move fog
                        fog.x += fog.speed;
                        if (fog.x > canvas.width + fog.size) {
                            fog.x = -fog.size;
                        }
                    });

                    // Draw tombstones
                    tombstones.forEach(tomb => {
                        drawTombstone(ctx, tomb.x, tomb.y, tomb.width, tomb.height, tomb.type, tomb.tilt);
                    });

                    // Draw floating spirits/wisps
                    spirits.forEach(spirit => {
                        const pulse = (Math.sin(time * 2 + spirit.phase) + 1) * 0.5;
                        const currentOpacity = spirit.opacity * (0.5 + pulse * 0.5);

                        // Spirit glow
                        const spiritGlow = ctx.createRadialGradient(
                            spirit.x, spirit.y, 0,
                            spirit.x, spirit.y, spirit.size * 2
                        );
                        spiritGlow.addColorStop(0, `rgba(180, 200, 220, ${currentOpacity})`);
                        spiritGlow.addColorStop(0.3, `rgba(150, 170, 190, ${currentOpacity * 0.6})`);
                        spiritGlow.addColorStop(1, 'transparent');
                        ctx.fillStyle = spiritGlow;
                        ctx.beginPath();
                        ctx.arc(spirit.x, spirit.y, spirit.size * 2, 0, Math.PI * 2);
                        ctx.fill();

                        // Spirit core
                        ctx.beginPath();
                        ctx.arc(spirit.x, spirit.y, spirit.size * 0.3, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(220, 230, 240, ${currentOpacity})`;
                        ctx.fill();

                        // Move spirit with wavy motion
                        spirit.x += spirit.speedX + Math.sin(time + spirit.phase) * 0.5;
                        spirit.y += spirit.speedY + Math.cos(time * 0.7 + spirit.phase) * 0.3;

                        // Wrap around
                        if (spirit.x > canvas.width + 50) spirit.x = -50;
                        if (spirit.x < -50) spirit.x = canvas.width + 50;
                        if (spirit.y > canvas.height * 0.8) spirit.y = canvas.height * 0.3;
                        if (spirit.y < canvas.height * 0.2) spirit.y = canvas.height * 0.7;
                    });

                    // Ground fog layer (front)
                    const groundFog = ctx.createLinearGradient(0, canvas.height * 0.7, 0, canvas.height);
                    groundFog.addColorStop(0, 'transparent');
                    groundFog.addColorStop(0.3, 'rgba(80, 90, 100, 0.2)');
                    groundFog.addColorStop(0.6, 'rgba(90, 100, 110, 0.4)');
                    groundFog.addColorStop(1, 'rgba(70, 80, 90, 0.5)');
                    ctx.fillStyle = groundFog;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Vignette Effect
                    const vignette = ctx.createRadialGradient(
                        canvas.width / 2, canvas.height / 2, canvas.width * 0.3,
                        canvas.width / 2, canvas.height / 2, canvas.width
                    );
                    vignette.addColorStop(0, 'transparent');
                    vignette.addColorStop(1, 'rgba(10, 15, 20, 0.6)');
                    ctx.fillStyle = vignette;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    time += 0.016;
                    animationId = requestAnimationFrame(animateGraveyard);
                }

                animateGraveyard();

                const resizeHandler = () => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                };
                window.addEventListener('resize', resizeHandler);

                activeWeatherInterval = {
                    isMultiple: true,
                    intervals: intervals,
                    animationId: animationId,
                    resizeHandler: resizeHandler,
                    clear: function () {
                        this.intervals.forEach(i => clearInterval(i));
                        cancelAnimationFrame(animationId);
                        window.removeEventListener('resize', this.resizeHandler);
                        const c = document.getElementById('graveyard-canvas');
                        if (c) c.remove();
                    }
                };
            }

            // CYBERSPACE - Neon wireframe grid, rising numbers, digital atmosphere
            if (currentBiome.name === 'CYBERSPACE' && !activeWeatherInterval) {
                const intervals = [];

                // Create cyberspace canvas
                const canvas = document.createElement('canvas');
                canvas.id = 'cyberspace-canvas';
                canvas.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    z-index: 1;
                `;
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                container.appendChild(canvas);

                const ctx = canvas.getContext('2d');
                let time = 0;
                let animationId;
                let frameSkip = 0;

                // Performance multiplier for Max FPS Mode
                const mult = typeof getParticleMultiplier === 'function' ? getParticleMultiplier() : 1;

                // Rising Numbers - reduced for performance
                const numbers = [];
                const numCount = Math.max(10, Math.floor(60 * mult));
                for (let i = 0; i < numCount; i++) {
                    numbers.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        value: Math.floor(Math.random() * 10), // 0-9
                        speed: 1 + Math.random() * 2,
                        size: 10 + Math.random() * 15,
                        opacity: 0.2 + Math.random() * 0.5,
                        changeInterval: Math.floor(Math.random() * 10) + 5,
                        frame: 0
                    });
                }

                // Floating Wireframe Cubes - reduced for performance
                const cubes = [];
                const cubeCount = Math.max(1, Math.floor(8 * mult));
                for (let i = 0; i < cubeCount; i++) {
                    cubes.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        z: Math.random() * 2 + 1, // Depth scale
                        size: 30 + Math.random() * 40,
                        rotationX: Math.random() * Math.PI,
                        rotationY: Math.random() * Math.PI,
                        rotationSpeedX: (Math.random() - 0.5) * 0.02,
                        rotationSpeedY: (Math.random() - 0.5) * 0.02,
                        floatSpeed: (Math.random() - 0.5) * 0.5,
                        opacity: 0.6 + Math.random() * 0.4
                    });
                }

                // Grid Points (for geodesic dome effect)
                const gridPoints = [];
                // Not actually storing points here, will draw procedural grid

                function drawCube(ctx, x, y, size, rx, ry, opacity) {
                    ctx.save();
                    ctx.translate(x, y);

                    // Simple 3D projection
                    const points = [
                        { x: -1, y: -1, z: -1 }, { x: 1, y: -1, z: -1 }, { x: 1, y: 1, z: -1 }, { x: -1, y: 1, z: -1 },
                        { x: -1, y: -1, z: 1 }, { x: 1, y: -1, z: 1 }, { x: 1, y: 1, z: 1 }, { x: -1, y: 1, z: 1 }
                    ];

                    const rotated = points.map(p => {
                        // Rotate X
                        let y1 = p.y * Math.cos(rx) - p.z * Math.sin(rx);
                        let z1 = p.y * Math.sin(rx) + p.z * Math.cos(rx);
                        // Rotate Y
                        let x1 = p.x * Math.cos(ry) + z1 * Math.sin(ry);
                        let z2 = -p.x * Math.sin(ry) + z1 * Math.cos(ry);

                        return { x: x1 * size, y: y1 * size };
                    });

                    ctx.strokeStyle = `rgba(0, 255, 255, ${opacity})`;
                    ctx.lineWidth = 2;
                    ctx.shadowColor = '#00ffff';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();

                    // Front face
                    ctx.moveTo(rotated[0].x, rotated[0].y);
                    ctx.lineTo(rotated[1].x, rotated[1].y);
                    ctx.lineTo(rotated[2].x, rotated[2].y);
                    ctx.lineTo(rotated[3].x, rotated[3].y);
                    ctx.closePath();

                    // Back face
                    ctx.moveTo(rotated[4].x, rotated[4].y);
                    ctx.lineTo(rotated[5].x, rotated[5].y);
                    ctx.lineTo(rotated[6].x, rotated[6].y);
                    ctx.lineTo(rotated[7].x, rotated[7].y);
                    ctx.closePath();

                    // Connecting lines
                    for (let i = 0; i < 4; i++) {
                        ctx.moveTo(rotated[i].x, rotated[i].y);
                        ctx.lineTo(rotated[i + 4].x, rotated[i + 4].y);
                    }

                    ctx.stroke();
                    ctx.restore();
                }

                function animateCyberspace() {
                    // Frame skipping for Max FPS Mode
                    frameSkip++;
                    if (userSettings.performance.maxFpsMode && frameSkip % 2 !== 0) {
                        time += 0.016;
                        animationId = requestAnimationFrame(animateCyberspace);
                        return;
                    }

                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // Dark Blue Background
                    ctx.fillStyle = '#000510'; // Deep dark blue
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw Wireframe Geodesic/Triangular Sky Grid (skip in max FPS mode)
                    if (!userSettings.performance.maxFpsMode) {
                        ctx.save();
                        ctx.strokeStyle = 'rgba(0, 100, 255, 0.3)';
                        ctx.lineWidth = 1;
                        ctx.beginPath();

                        // Triangular grid - larger size for better performance
                        const gridSize = userSettings.performance.maxFpsMode ? 200 : 100;
                        const shiftX = (time * 10) % gridSize; // Move grid slowly

                        for (let y = -gridSize; y < canvas.height + gridSize; y += gridSize * 0.866) { // hex height
                            const rowOffset = (Math.floor(y / (gridSize * 0.866)) % 2) * (gridSize / 2);
                            for (let x = -gridSize; x < canvas.width + gridSize; x += gridSize) {
                                const px = x + rowOffset - shiftX;
                                const py = y;

                                // Draw triangle connected to top-left and top-right neighbors
                                ctx.moveTo(px, py);
                                ctx.lineTo(px + gridSize / 2, py - gridSize * 0.866);
                                ctx.lineTo(px + gridSize, py);
                                ctx.lineTo(px + gridSize / 2, py + gridSize * 0.866);
                                ctx.closePath();
                            }
                        }
                        ctx.stroke();

                        // Add glowing nodes at intersections
                        ctx.fillStyle = 'rgba(0, 200, 255, 0.5)';
                        for (let y = -gridSize; y < canvas.height + gridSize; y += gridSize * 0.866) {
                            const rowOffset = (Math.floor(y / (gridSize * 0.866)) % 2) * (gridSize / 2);
                            for (let x = -gridSize; x < canvas.width + gridSize; x += gridSize) {
                                const px = x + rowOffset - shiftX;
                                const py = y;
                                // Only draw some to reduce clutter
                                if ((px + py) % 3 === 0) {
                                    ctx.beginPath();
                                    ctx.arc(px, py, 2, 0, Math.PI * 2);
                                    ctx.fill();
                                }
                            }
                        }
                        ctx.restore();
                    } // End of grid drawing if block

                    // Draw Rising Numbers (always draw, but already reduced count)
                    ctx.font = 'bold 16px "Courier New", monospace';
                    ctx.textAlign = 'center';
                    numbers.forEach(num => {
                        ctx.fillStyle = `rgba(0, 255, 255, ${num.opacity})`;
                        // Occasionally glitch/change value
                        num.frame++;
                        if (num.frame > num.changeInterval) {
                            num.value = Math.floor(Math.random() * 10);
                            num.frame = 0;
                        }

                        ctx.save();
                        ctx.translate(num.x, num.y);
                        // Scale based on size
                        const scale = num.size / 16;
                        ctx.scale(scale, scale);
                        ctx.fillText(num.value, 0, 0);
                        ctx.restore();

                        // Move Up
                        num.y -= num.speed;
                        if (num.y < -20) {
                            num.y = canvas.height + 20;
                            num.x = Math.random() * canvas.width;
                        }
                    });

                    // Draw Floating Cubes (always draw, but already reduced count)
                    cubes.forEach(cube => {
                        drawCube(ctx, cube.x, cube.y, cube.size, cube.rotationX, cube.rotationY, cube.opacity);

                        // Rotate
                        cube.rotationX += cube.rotationSpeedX;
                        cube.rotationY += cube.rotationSpeedY;

                        // Float strictly vertically ? No, let's just float around slightly
                        cube.y += cube.floatSpeed;
                        if (cube.y < -100) cube.y = canvas.height + 100;
                        if (cube.y > canvas.height + 100) cube.y = -100;
                    });

                    // Vignette - skip in Max FPS Mode
                    if (!userSettings.performance.maxFpsMode) {
                        const vignette = ctx.createRadialGradient(
                            canvas.width / 2, canvas.height / 2, canvas.width * 0.4,
                            canvas.width / 2, canvas.height / 2, canvas.width
                        );
                        vignette.addColorStop(0, 'transparent');
                        vignette.addColorStop(1, 'rgba(0, 5, 20, 0.8)');
                        ctx.fillStyle = vignette;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }

                    time += 0.016;
                    animationId = requestAnimationFrame(animateCyberspace);
                }

                animateCyberspace();

                const resizeHandler = () => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                };
                window.addEventListener('resize', resizeHandler);

                activeWeatherInterval = {
                    isMultiple: true,
                    intervals: intervals,
                    animationId: animationId,
                    resizeHandler: resizeHandler,
                    clear: function () {
                        this.intervals.forEach(i => clearInterval(i));
                        cancelAnimationFrame(animationId);
                        window.removeEventListener('resize', this.resizeHandler);
                        const c = document.getElementById('cyberspace-canvas');
                        if (c) c.remove();
                    }
                };
            }

            // DREAMSPACE - Floating objects and pink dreamy atmosphere
            if (currentBiome.name === 'DREAMSPACE' && !activeWeatherInterval) {
                const intervals = [];

                // Create dreamspace canvas
                const canvas = document.createElement('canvas');
                canvas.id = 'dreamspace-canvas';
                canvas.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    z-index: 1;
                `;
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                container.appendChild(canvas);

                const ctx = canvas.getContext('2d');
                let time = 0;
                let animationId;

                // Floating object types with drawing functions
                const objectTypes = {
                    table: (ctx, x, y, size, alpha) => {
                        ctx.fillStyle = `rgba(200, 100, 180, ${alpha})`;
                        // Table top
                        ctx.fillRect(x - size, y, size * 2, size * 0.2);
                        // Legs
                        ctx.fillRect(x - size * 0.8, y + size * 0.2, size * 0.15, size * 0.8);
                        ctx.fillRect(x + size * 0.65, y + size * 0.2, size * 0.15, size * 0.8);
                    },
                    chair: (ctx, x, y, size, alpha) => {
                        ctx.fillStyle = `rgba(180, 80, 160, ${alpha})`;
                        // Seat
                        ctx.fillRect(x - size * 0.5, y, size, size * 0.15);
                        // Back
                        ctx.fillRect(x - size * 0.5, y - size * 0.6, size * 0.15, size * 0.6);
                        // Legs
                        ctx.fillRect(x - size * 0.4, y + size * 0.15, size * 0.1, size * 0.5);
                        ctx.fillRect(x + size * 0.3, y + size * 0.15, size * 0.1, size * 0.5);
                    },
                    sign: (ctx, x, y, size, alpha) => {
                        ctx.fillStyle = `rgba(150, 70, 180, ${alpha})`;
                        // Sign board
                        ctx.fillRect(x - size * 0.8, y - size * 0.5, size * 1.6, size);
                        // Pole
                        ctx.fillRect(x - size * 0.1, y + size * 0.5, size * 0.2, size * 0.8);
                        // Text lines
                        ctx.fillStyle = `rgba(255, 200, 255, ${alpha * 0.5})`;
                        ctx.fillRect(x - size * 0.6, y - size * 0.3, size * 1.2, size * 0.1);
                        ctx.fillRect(x - size * 0.6, y - size * 0.1, size * 0.8, size * 0.1);
                        ctx.fillRect(x - size * 0.6, y + size * 0.1, size, size * 0.1);
                    },
                    cube: (ctx, x, y, size, alpha) => {
                        ctx.fillStyle = `rgba(220, 100, 200, ${alpha})`;
                        ctx.fillRect(x - size * 0.5, y - size * 0.5, size, size);
                        // Highlight
                        ctx.fillStyle = `rgba(255, 180, 255, ${alpha * 0.3})`;
                        ctx.fillRect(x - size * 0.5, y - size * 0.5, size * 0.3, size);
                    },
                    triangle: (ctx, x, y, size, alpha) => {
                        ctx.fillStyle = `rgba(200, 80, 220, ${alpha})`;
                        ctx.beginPath();
                        ctx.moveTo(x, y - size * 0.6);
                        ctx.lineTo(x + size * 0.6, y + size * 0.4);
                        ctx.lineTo(x - size * 0.6, y + size * 0.4);
                        ctx.closePath();
                        ctx.fill();
                    },
                    diamond: (ctx, x, y, size, alpha) => {
                        ctx.fillStyle = `rgba(255, 120, 200, ${alpha})`;
                        ctx.beginPath();
                        ctx.moveTo(x, y - size * 0.7);
                        ctx.lineTo(x + size * 0.5, y);
                        ctx.lineTo(x, y + size * 0.7);
                        ctx.lineTo(x - size * 0.5, y);
                        ctx.closePath();
                        ctx.fill();
                    },
                    lamp: (ctx, x, y, size, alpha) => {
                        ctx.fillStyle = `rgba(180, 100, 160, ${alpha})`;
                        // Shade
                        ctx.beginPath();
                        ctx.moveTo(x - size * 0.4, y);
                        ctx.lineTo(x + size * 0.4, y);
                        ctx.lineTo(x + size * 0.2, y - size * 0.5);
                        ctx.lineTo(x - size * 0.2, y - size * 0.5);
                        ctx.closePath();
                        ctx.fill();
                        // Pole
                        ctx.fillRect(x - size * 0.05, y, size * 0.1, size * 0.8);
                        // Base
                        ctx.fillRect(x - size * 0.2, y + size * 0.8, size * 0.4, size * 0.1);
                        // Glow
                        const glow = ctx.createRadialGradient(x, y - size * 0.25, 0, x, y - size * 0.25, size * 0.5);
                        glow.addColorStop(0, `rgba(255, 200, 255, ${alpha * 0.3})`);
                        glow.addColorStop(1, 'transparent');
                        ctx.fillStyle = glow;
                        ctx.beginPath();
                        ctx.arc(x, y - size * 0.25, size * 0.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                };

                const typeNames = Object.keys(objectTypes);

                // Create floating objects - uses getParticleMultiplier for Max FPS Mode
                const floatingObjects = [];
                const mult = typeof getParticleMultiplier === 'function' ? getParticleMultiplier() : 1;
                const objectCount = Math.max(2, Math.floor(8 * mult));
                for (let i = 0; i < objectCount; i++) {
                    floatingObjects.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        baseY: Math.random() * canvas.height,
                        size: 20 + Math.random() * 40,
                        type: typeNames[Math.floor(Math.random() * typeNames.length)],
                        bobSpeed: 0.5 + Math.random() * 1,
                        bobAmount: 10 + Math.random() * 20,
                        phase: Math.random() * Math.PI * 2,
                        rotation: Math.random() * 0.2 - 0.1,
                        driftX: (Math.random() - 0.5) * 0.2,
                        alpha: 0.3 + Math.random() * 0.4
                    });
                }

                // Energy streams - uses getParticleMultiplier for Max FPS Mode
                const energyStreams = [];
                const streamCount = Math.max(1, Math.floor(4 * mult));
                for (let i = 0; i < streamCount; i++) {
                    energyStreams.push({
                        x: Math.random() * canvas.width,
                        width: 20 + Math.random() * 40,
                        speed: 1 + Math.random() * 2,
                        phase: Math.random() * Math.PI * 2,
                        color: Math.random() > 0.5 ?
                            { r: 255, g: 107, b: 203 } :
                            { r: 224, g: 86, b: 253 }
                    });
                }

                // Dream particles - uses getParticleMultiplier for Max FPS Mode
                const dreamParticles = [];
                const particleCount = Math.max(5, Math.floor(35 * mult));
                for (let i = 0; i < particleCount; i++) {
                    dreamParticles.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        size: Math.random() * 4 + 1,
                        speedY: -(Math.random() * 0.5 + 0.2),
                        speedX: (Math.random() - 0.5) * 0.3,
                        opacity: Math.random() * 0.6 + 0.2,
                        pulse: Math.random() * Math.PI * 2,
                        color: Math.random() > 0.5 ? '#ff6bcb' : '#e056fd'
                    });
                }

                let frameSkip = 0;

                // Animation loop
                function animateDreamspace() {
                    // Frame skipping for Max FPS Mode
                    frameSkip++;
                    if (userSettings.performance.maxFpsMode && frameSkip % 2 !== 0) {
                        time += 0.016;
                        animationId = requestAnimationFrame(animateDreamspace);
                        return;
                    }

                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // Simplified background in Max FPS Mode, gradient in normal mode
                    if (userSettings.performance.maxFpsMode) {
                        ctx.fillStyle = 'rgba(200, 100, 200, 0.2)';
                    } else {
                        const bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                        bgGradient.addColorStop(0, 'rgba(180, 80, 180, 0.3)');
                        bgGradient.addColorStop(0.4, 'rgba(255, 107, 203, 0.2)');
                        bgGradient.addColorStop(0.7, 'rgba(224, 86, 253, 0.15)');
                        bgGradient.addColorStop(1, 'rgba(200, 100, 200, 0.25)');
                        ctx.fillStyle = bgGradient;
                    }
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw energy streams rising from below
                    energyStreams.forEach(stream => {
                        const waveX = Math.sin(time * stream.speed + stream.phase) * 30;

                        const streamGradient = ctx.createLinearGradient(
                            stream.x + waveX, canvas.height,
                            stream.x + waveX, 0
                        );
                        streamGradient.addColorStop(0, `rgba(${stream.color.r}, ${stream.color.g}, ${stream.color.b}, 0.4)`);
                        streamGradient.addColorStop(0.3, `rgba(${stream.color.r}, ${stream.color.g}, ${stream.color.b}, 0.2)`);
                        streamGradient.addColorStop(0.7, `rgba(${stream.color.r}, ${stream.color.g}, ${stream.color.b}, 0.1)`);
                        streamGradient.addColorStop(1, 'transparent');

                        ctx.beginPath();
                        ctx.moveTo(stream.x + waveX - stream.width / 2, canvas.height);

                        // Wavy path upward - increased step from 20 to 40 for performance
                        for (let y = canvas.height; y >= 0; y -= 40) {
                            const wave = Math.sin((y * 0.01) + time * stream.speed + stream.phase) * 20;
                            ctx.lineTo(stream.x + waveX + wave - stream.width / 2, y);
                        }

                        for (let y = 0; y <= canvas.height; y += 40) {
                            const wave = Math.sin((y * 0.01) + time * stream.speed + stream.phase) * 20;
                            ctx.lineTo(stream.x + waveX + wave + stream.width / 2, y);
                        }

                        ctx.closePath();
                        ctx.fillStyle = streamGradient;
                        ctx.fill();
                        // Removed blur filter for performance - it was very expensive
                    });

                    // Draw floating objects
                    floatingObjects.forEach(obj => {
                        const bobOffset = Math.sin(time * obj.bobSpeed + obj.phase) * obj.bobAmount;
                        const currentY = obj.baseY + bobOffset;

                        ctx.save();
                        ctx.translate(obj.x, currentY);
                        ctx.rotate(Math.sin(time * 0.5 + obj.phase) * obj.rotation);

                        // Draw the object
                        objectTypes[obj.type](ctx, 0, 0, obj.size, obj.alpha);

                        // Add glow under objects
                        const glow = ctx.createRadialGradient(0, obj.size * 0.5, 0, 0, obj.size * 0.5, obj.size);
                        glow.addColorStop(0, `rgba(255, 150, 220, ${obj.alpha * 0.3})`);
                        glow.addColorStop(1, 'transparent');
                        ctx.fillStyle = glow;
                        ctx.beginPath();
                        ctx.arc(0, obj.size * 0.5, obj.size, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.restore();

                        // Slow drift
                        obj.x += obj.driftX;
                        if (obj.x < -obj.size) obj.x = canvas.width + obj.size;
                        if (obj.x > canvas.width + obj.size) obj.x = -obj.size;
                    });

                    // Draw dream particles
                    dreamParticles.forEach(particle => {
                        const pulse = (Math.sin(time * 2 + particle.pulse) + 1) * 0.5;
                        const currentOpacity = particle.opacity * (0.5 + pulse * 0.5);

                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size * pulse, 0, Math.PI * 2);
                        ctx.fillStyle = particle.color;
                        ctx.globalAlpha = currentOpacity;
                        ctx.fill();

                        // Glow
                        const glow = ctx.createRadialGradient(
                            particle.x, particle.y, 0,
                            particle.x, particle.y, particle.size * 4
                        );
                        glow.addColorStop(0, particle.color);
                        glow.addColorStop(1, 'transparent');
                        ctx.fillStyle = glow;
                        ctx.globalAlpha = currentOpacity * 0.4;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size * 4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;

                        particle.x += particle.speedX;
                        particle.y += particle.speedY;

                        if (particle.y < -20) {
                            particle.y = canvas.height + 20;
                            particle.x = Math.random() * canvas.width;
                        }
                        if (particle.x < 0) particle.x = canvas.width;
                        if (particle.x > canvas.width) particle.x = 0;
                    });

                    // Dreamy vignette
                    const vignette = ctx.createRadialGradient(
                        canvas.width / 2, canvas.height / 2, canvas.width * 0.3,
                        canvas.width / 2, canvas.height / 2, canvas.width * 0.8
                    );
                    vignette.addColorStop(0, 'transparent');
                    vignette.addColorStop(1, 'rgba(180, 50, 150, 0.2)');
                    ctx.fillStyle = vignette;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Central dream glow
                    const dreamGlow = ctx.createRadialGradient(
                        canvas.width / 2, canvas.height * 0.4, 0,
                        canvas.width / 2, canvas.height * 0.4, canvas.width * 0.5
                    );
                    const glowPulse = (Math.sin(time * 0.3) + 1) * 0.02 + 0.02;
                    dreamGlow.addColorStop(0, `rgba(255, 150, 220, ${glowPulse})`);
                    dreamGlow.addColorStop(0.5, `rgba(224, 86, 253, ${glowPulse * 0.5})`);
                    dreamGlow.addColorStop(1, 'transparent');
                    ctx.fillStyle = dreamGlow;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    time += 0.016;
                    animationId = requestAnimationFrame(animateDreamspace);
                }

                animateDreamspace();

                // Handle resize
                const resizeHandler = () => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;

                    // Redistribute objects
                    floatingObjects.forEach(obj => {
                        obj.x = Math.random() * canvas.width;
                        obj.baseY = Math.random() * canvas.height;
                    });
                };
                window.addEventListener('resize', resizeHandler);

                activeWeatherInterval = {
                    isMultiple: true,
                    intervals: intervals,
                    animationId: animationId,
                    resizeHandler: resizeHandler,
                    clear: function () {
                        this.intervals.forEach(i => clearInterval(i));
                        cancelAnimationFrame(animationId);
                        window.removeEventListener('resize', this.resizeHandler);
                        const c = document.getElementById('dreamspace-canvas');
                        if (c) c.remove();
                    }
                };
            }

            // GLITCHED - Three.js animated grid background
            if (currentBiome.name === 'GLITCHED' && !activeWeatherInterval) {
                const intervals = [];

                // Create container for Three.js
                const glitchContainer = document.createElement('div');
                glitchContainer.id = 'glitched-container';
                glitchContainer.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    z-index: 1;
                `;
                container.appendChild(glitchContainer);

                // Initialize Three.js for the grid
                (async () => {
                    const THREE = await import('three');
                    const { EffectComposer } = await import('three/addons/postprocessing/EffectComposer.js');
                    const { RenderPass } = await import('three/addons/postprocessing/RenderPass.js');
                    const { UnrealBloomPass } = await import('three/addons/postprocessing/UnrealBloomPass.js');

                    const scene = new THREE.Scene();
                    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 150);
                    camera.position.z = 7;

                    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    renderer.setClearColor(0x000000, 1);
                    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                    glitchContainer.appendChild(renderer.domElement);

                    const composer = new EffectComposer(renderer);
                    composer.addPass(new RenderPass(scene, camera));
                    const bloomPass = new UnrealBloomPass(
                        new THREE.Vector2(window.innerWidth, window.innerHeight),
                        0.3, 0.4, 0.9
                    );
                    composer.addPass(bloomPass);

                    // Grid plane shader
                    const gridPlaneVertexShader = `
                        varying vec2 vUv;
                        varying vec3 vPosition;
                        void main() {
                            vUv = uv;
                            vPosition = position;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `;

                    const gridPlaneFragmentShader = `
                        varying vec2 vUv;
                        varying vec3 vPosition;
                        uniform float time;
                        uniform vec2 mouse;
                        uniform float mouseInfluence;
                        uniform vec2 resolution;

                        vec3 backgroundColor = vec3(0.0, 0.0, 0.0);
                        vec3 baseLineColor = vec3(0.08, 0.18, 0.5);
                        vec3 highlightLineColor = vec3(0.9, 0.95, 1.0);
                        vec3 waveColor = vec3(0.3, 0.8, 1.0);
                        vec3 waveHighlightColor = vec3(0.8, 0.4, 1.0);
                        vec3 energyColor = vec3(0.5, 1.0, 1.0);
                        vec3 accentColor = vec3(1.0, 0.4, 0.8);

                        float random(vec2 st) {
                            return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
                        }

                        float noise(vec2 st) {
                            vec2 i = floor(st);
                            vec2 f = fract(st);
                            float a = random(i);
                            float b = random(i + vec2(1.0, 0.0));
                            float c = random(i + vec2(0.0, 1.0));
                            float d = random(i + vec2(1.0, 1.0));
                            vec2 u = f * f * (3.0 - 2.0 * f);
                            return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
                        }

                        float drawGrid(vec2 uv, float density) {
                            vec2 gridUv = uv * density;
                            vec2 gridDeriv = fwidth(gridUv) * 0.5;
                            vec2 gridLines = abs(fract(gridUv) - 0.5);
                            vec2 gridLineAA = smoothstep(gridDeriv, gridDeriv * 2.0, gridLines);
                            return 1.0 - min(gridLineAA.x, gridLineAA.y);
                        }

                        void main() {
                            vec2 uv = vUv;
                            float elapsedTime = time;

                            // Subtle UV distortion based on noise
                            float flowNoise = noise(uv * 5.0 + elapsedTime * 0.2);
                            vec2 distortedUv = uv + vec2(sin(elapsedTime * 0.4 + flowNoise * 2.0), cos(elapsedTime * 0.35 + flowNoise * 1.5)) * 0.015;

                            float gridValue = drawGrid(distortedUv, 50.0);

                            // Visibility mask for flickering effect
                            float visibilityNoise1 = noise(uv * 2.5 + elapsedTime * 0.15);
                            float visibilityNoise2 = noise(uv * 5.0 - elapsedTime * 0.1);
                            float visibilityMask = smoothstep(0.15, 0.4, visibilityNoise1) * smoothstep(0.25, 0.55, visibilityNoise2);
                            visibilityMask = max(0.3, visibilityMask);

                            // Energy flows across the grid
                            float energyFlow1 = sin(uv.x * 30.0 - elapsedTime * 12.0 + noise(uv * 3.0) * 10.0) * 0.5 + 0.5;
                            float energyFlow2 = cos(uv.y * 35.0 + elapsedTime * 10.0 + noise(uv * 2.5) * 8.0) * 0.5 + 0.5;
                            float energyValue = pow(energyFlow1 * energyFlow2, 3.5);
                            energyValue = smoothstep(0.05, 0.6, energyValue);

                            // Accent pulses
                            float accentPulse = sin(elapsedTime * 2.0 + uv.x * 20.0) * sin(elapsedTime * 1.5 + uv.y * 15.0);
                            accentPulse = smoothstep(0.7, 0.9, accentPulse) * 0.5;

                            // Color mixing
                            vec3 energyPulseColor = mix(baseLineColor, energyColor * 1.5, energyValue);
                            energyPulseColor = mix(energyPulseColor, accentColor, accentPulse);

                            // Background noise
                            float bgNoise = noise(uv * 12.0 + elapsedTime * 0.1) * 0.04;

                            // Final color
                            vec3 gridCombined = energyPulseColor * gridValue * visibilityMask;
                            vec3 finalColor = backgroundColor + gridCombined + bgNoise * baseLineColor;
                            finalColor = max(finalColor, baseLineColor * gridValue * 0.1 * visibilityMask);

                            gl_FragColor = vec4(finalColor, 1.0);
                        }
                    `;

                    // Create grid plane
                    const aspect = window.innerWidth / window.innerHeight;
                    const vFov = camera.fov * Math.PI / 180;
                    const planeHeight = 2 * Math.tan(vFov / 2) * 35;
                    const planeWidth = planeHeight * aspect;

                    const gridGeometry = new THREE.PlaneGeometry(planeWidth * 1.5, planeHeight * 1.5, 1, 1);
                    const gridMaterial = new THREE.ShaderMaterial({
                        uniforms: {
                            time: { value: 0 },
                            mouse: { value: new THREE.Vector2(0, 0) },
                            mouseInfluence: { value: 0.5 },
                            resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
                        },
                        vertexShader: gridPlaneVertexShader,
                        fragmentShader: gridPlaneFragmentShader,
                        side: THREE.DoubleSide
                    });

                    const gridMesh = new THREE.Mesh(gridGeometry, gridMaterial);
                    gridMesh.position.z = -35;
                    scene.add(gridMesh);

                    // Animation variables
                    const clock = new THREE.Clock();
                    let mouseInfluence = 0.5;
                    let animationId;

                    // Animation loop
                    function animateGrid() {
                        const elapsed = clock.getElapsedTime();
                        gridMaterial.uniforms.time.value = elapsed;

                        composer.render();
                        animationId = requestAnimationFrame(animateGrid);
                    }
                    animateGrid();

                    // Resize handler
                    const resizeHandler = () => {
                        const w = window.innerWidth;
                        const h = window.innerHeight;
                        camera.aspect = w / h;
                        camera.updateProjectionMatrix();
                        renderer.setSize(w, h);
                        composer.setSize(w, h);
                        gridMaterial.uniforms.resolution.value.set(w, h);
                    };
                    window.addEventListener('resize', resizeHandler);

                    // Store cleanup info
                    glitchContainer.dataset.animationId = animationId;
                    glitchContainer._cleanup = () => {
                        cancelAnimationFrame(animationId);
                        window.removeEventListener('resize', resizeHandler);
                        renderer.dispose();
                        gridGeometry.dispose();
                        gridMaterial.dispose();
                    };
                })();

                activeWeatherInterval = {
                    isMultiple: true,
                    intervals: intervals,
                    clear: function () {
                        const c = document.getElementById('glitched-container');
                        if (c) {
                            if (c._cleanup) c._cleanup();
                            c.remove();
                        }
                    }
                };
            }

            // SANDSTORM - Intense layered dust effect
            if (currentBiome.name === 'SANDSTORM' && !activeWeatherInterval) {
                // Multiple particle systems running together
                const intervals = [];

                // Fast dust streaks (wind lines)
                intervals.push(setInterval(() => {
                    const streak = document.createElement('div');
                    streak.classList.add('dust-streak');
                    streak.style.top = Math.random() * 100 + 'vh';
                    streak.style.width = (150 + Math.random() * 300) + 'px';
                    streak.style.animationDuration = (0.3 + Math.random() * 0.4) + 's';
                    streak.style.opacity = 0.3 + Math.random() * 0.4;
                    container.appendChild(streak);
                    setTimeout(() => streak.remove(), 800);
                }, 15));

                // Floating dust particles
                intervals.push(setInterval(() => {
                    const particle = document.createElement('div');
                    particle.classList.add('dust-particle');
                    const size = 4 + Math.random() * 12;
                    particle.style.left = -50 + 'px';
                    particle.style.top = Math.random() * 100 + 'vh';
                    particle.style.width = size + 'px';
                    particle.style.height = size + 'px';
                    particle.style.animationDuration = (1.5 + Math.random() * 1.5) + 's';
                    particle.style.opacity = 0.4 + Math.random() * 0.4;
                    container.appendChild(particle);
                    setTimeout(() => particle.remove(), 3500);
                }, 40));

                // Large sand clouds
                intervals.push(setInterval(() => {
                    const cloud = document.createElement('div');
                    cloud.classList.add('sand-cloud');
                    const size = 100 + Math.random() * 200;
                    cloud.style.left = -size + 'px';
                    cloud.style.top = (Math.random() * 80 + 10) + 'vh';
                    cloud.style.width = size + 'px';
                    cloud.style.height = size * 0.6 + 'px';
                    cloud.style.animationDuration = (3 + Math.random() * 2) + 's';
                    container.appendChild(cloud);
                    setTimeout(() => cloud.remove(), 6000);
                }, 200));

                // Store all intervals for cleanup
                activeWeatherInterval = {
                    isMultiple: true,
                    intervals: intervals,
                    clear: function () {
                        this.intervals.forEach(i => clearInterval(i));
                    }
                };
            }

            // HELL - Optimized fire particles
            if (currentBiome.name === 'HELL' && !activeWeatherInterval) {
                // Add lava glow element
                const lavaGlow = document.createElement('div');
                lavaGlow.classList.add('lava-glow');
                lavaGlow.id = 'lava-glow';
                container.appendChild(lavaGlow);

                // Create fire canvas
                const canvas = document.createElement('canvas');
                canvas.id = 'fire-canvas';
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                container.appendChild(canvas);
                const ctx = canvas.getContext('2d');

                // Simple ember particle
                const particles = [];
                const maxParticles = 50;

                function createParticle() {
                    return {
                        x: Math.random() * canvas.width,
                        y: canvas.height + 10,
                        size: 2 + Math.random() * 4,
                        speedY: -(1 + Math.random() * 2),
                        speedX: (Math.random() - 0.5) * 1,
                        life: 1,
                        decay: 0.008 + Math.random() * 0.012,
                        r: 255,
                        g: Math.floor(80 + Math.random() * 100),
                        b: 0
                    };
                }

                // Initialize particles
                for (let i = 0; i < maxParticles; i++) {
                    const p = createParticle();
                    p.y = Math.random() * canvas.height; // Spread initially
                    p.life = Math.random();
                    particles.push(p);
                }

                let animationId;
                function animate() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.globalCompositeOperation = 'lighter';

                    for (let i = 0; i < particles.length; i++) {
                        const p = particles[i];

                        // Update
                        p.x += p.speedX;
                        p.y += p.speedY;
                        p.life -= p.decay;

                        // Reset if dead
                        if (p.life <= 0 || p.y < -20) {
                            particles[i] = createParticle();
                            continue;
                        }

                        // Draw simple circle
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(${p.r}, ${p.g}, ${p.b}, ${p.life * 0.8})`;
                        ctx.fill();
                    }

                    animationId = requestAnimationFrame(animate);
                }
                animate();

                // Handle resize
                const resizeHandler = () => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                };
                window.addEventListener('resize', resizeHandler);

                activeWeatherInterval = {
                    isMultiple: true,
                    intervals: [],
                    clear: function () {
                        cancelAnimationFrame(animationId);
                        window.removeEventListener('resize', resizeHandler);
                        const c = document.getElementById('fire-canvas');
                        if (c) c.remove();
                        const glow = document.getElementById('lava-glow');
                        if (glow) glow.remove();
                    }
                };
            }

            // SAKURA - Cherry Blossom biome with WebGL petal effect
            if (currentBiome.name === 'SAKURA' && !activeWeatherInterval) {
                // Get or create the sakura canvas
                let sakuraCanvas = document.getElementById('sakura-canvas');
                if (!sakuraCanvas) {
                    sakuraCanvas = document.createElement('canvas');
                    sakuraCanvas.id = 'sakura-canvas';
                    sakuraCanvas.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        pointer-events: none;
                        z-index: 1;
                        transition: opacity 0.5s ease;
                    `;
                    container.appendChild(sakuraCanvas);
                }

                // Initialize and start the Sakura WebGL effect
                if (window.sakuraEffect) {
                    if (!window.sakuraEffect.isActive()) {
                        window.sakuraEffect.init('sakura-canvas');
                    }
                    window.sakuraEffect.start();
                }

                activeWeatherInterval = {
                    isMultiple: true,
                    intervals: [],
                    clear: function () {
                        if (window.sakuraEffect) {
                            window.sakuraEffect.stop();
                        }
                        const c = document.getElementById('sakura-canvas');
                        if (c) c.remove();
                    }
                };
            }

            // DEEP SEA - Underwater biome with caustics, bubbles, and light rays
            if (currentBiome.name === 'DEEP SEA' && !activeWeatherInterval) {
                // Initialize and start the Deep Sea effect
                if (window.deepSeaEffect) {
                    window.deepSeaEffect.start();
                }

                activeWeatherInterval = {
                    isMultiple: true,
                    intervals: [],
                    clear: function () {
                        if (window.deepSeaEffect) {
                            window.deepSeaEffect.stop();
                        }
                    }
                };
            }

            // LIMBO - Black ink drip atmosphere
            if (currentBiome.name === 'LIMBO' && !activeWeatherInterval) {
                activeWeatherInterval = setInterval(() => {
                    const drip = document.createElement('div');
                    drip.classList.add('ink-drip');
                    drip.style.left = (Math.random() * 106 - 3) + 'vw';
                    drip.style.width = (3 + Math.random() * 8) + 'px';
                    drip.style.height = (45 + Math.random() * 130) + 'px';
                    drip.style.opacity = (0.35 + Math.random() * 0.55).toFixed(2);
                    drip.style.animationDuration = (2.2 + Math.random() * 2.1) + 's';
                    container.appendChild(drip);
                    setTimeout(() => drip.remove(), 5200);
                }, 70);
            }
        }

        function updateHUD() {
            // Track Biome Discovery
            if (!playerStats.biomesDiscovered[currentBiome.name]) {
                playerStats.biomesDiscovered[currentBiome.name] = true;

                // Track rarest biome
                if (!playerStats.rarestBiome) {
                    playerStats.rarestBiome = currentBiome.name;
                } else {
                    const currentRarest = BIOMES.find(b => b.name === playerStats.rarestBiome);
                    if (currentRarest && currentBiome.chance < currentRarest.chance) {
                        playerStats.rarestBiome = currentBiome.name;
                    }
                }
                updateStatsPanel();
                saveGame();
            }

            const versionEl = document.querySelector('.version');
            const biomeEl = document.querySelector('.biome');
            const timeEl = document.querySelector('.time');
            const biomeOverlay = document.getElementById('biome-overlay');

            // versionEl.textContent = 'v1.000'; // Already static or set

            // Special glitchy biome text for GLITCHED biome
            if (currentBiome.name === 'GLITCHED') {
                // Start glitch text interval if not already running
                if (!window.glitchTextInterval) {
                    const glitchChars = '01#$%^&*!@<>[]{}|/\\~`+-=*/!?';
                    window.glitchTextInterval = setInterval(() => {
                        const biomeEl = document.querySelector('.biome');
                        if (!biomeEl || currentBiome.name !== 'GLITCHED') {
                            clearInterval(window.glitchTextInterval);
                            window.glitchTextInterval = null;
                            return;
                        }
                        let glitchText = 'GLITCHED';
                        // Always corrupt some characters for continuous glitch effect
                        const chars = glitchText.split('');
                        const numCorrupt = Math.floor(Math.random() * 5) + 2; // 2-6 characters
                        for (let i = 0; i < numCorrupt; i++) {
                            const pos = Math.floor(Math.random() * chars.length);
                            chars[pos] = glitchChars[Math.floor(Math.random() * glitchChars.length)];
                        }
                        glitchText = chars.join('');
                        biomeEl.textContent = `[ ${glitchText} ]`;
                    }, 100); // Update every 100ms
                }
                biomeEl.style.color = '#00ffaa';
                biomeEl.style.textShadow = `
                    -2px 0 #ff0055,
                    2px 0 #00ffaa,
                    0 0 10px #00ffaa,
                    0 0 20px #00ffaa
                `;
                biomeEl.style.animation = 'glitch-text 0.1s infinite';
            } else {
                // Clear glitch interval if switching away from GLITCHED
                if (window.glitchTextInterval) {
                    clearInterval(window.glitchTextInterval);
                    window.glitchTextInterval = null;
                }
                biomeEl.textContent = `[ ${currentBiome.name} ]`;
                biomeEl.style.color = currentBiome.color || '#fff';
                biomeEl.style.textShadow = 'none';
                biomeEl.style.animation = 'none';
            }

            timeEl.textContent = currentTime;
            timeEl.style.color = (currentTime === 'DAYTIME') ? '#f1c40f' : '#8e44ad';

            // Biome Background Overlay with fade
            const useLiteBiomeEffects = shouldUseLiteBiomeEffects();
            const clearPumpkinEffects = () => {
                const particles = document.getElementById('pumpkin-particles');
                if (particles) particles.remove();
                if (window.pumpkinParticleInterval) {
                    clearInterval(window.pumpkinParticleInterval);
                    window.pumpkinParticleInterval = null;
                }
            };
            const clearBlazingSunEffects = () => {
                const sunRays = document.getElementById('sun-rays');
                if (sunRays) sunRays.remove();
            };
            if (currentBiome.name === 'NORMAL') {
                biomeOverlay.classList.remove('active');
                biomeOverlay.style.background = 'transparent';
                biomeOverlay.style.opacity = '0';
                clearPumpkinEffects();
                clearBlazingSunEffects();
            } else if (currentBiome.name === 'PUMPKIN MOON') {
                // Special Pumpkin Moon effects with electric particles
                biomeOverlay.style.background = 'radial-gradient(ellipse at center, rgba(255, 107, 26, 0.3) 0%, rgba(139, 69, 19, 0.4) 50%, rgba(20, 10, 5, 0.6) 100%)';
                biomeOverlay.style.opacity = '0.7';
                biomeOverlay.classList.add('active');
                clearBlazingSunEffects();

                if (useLiteBiomeEffects) {
                    clearPumpkinEffects();
                } else {
                // Add electric particle system if not already present
                let particleCanvas = document.getElementById('pumpkin-particles');
                if (!particleCanvas) {
                    particleCanvas = document.createElement('canvas');
                    particleCanvas.id = 'pumpkin-particles';
                    particleCanvas.width = window.innerWidth;
                    particleCanvas.height = window.innerHeight;
                    particleCanvas.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        pointer-events: none;
                        z-index: 1;
                    `;
                    document.body.appendChild(particleCanvas);

                    const ctx = particleCanvas.getContext('2d');
                    const particles = [];

                    // Simple particle creation (like Hell)
                    function createParticle() {
                        return {
                            x: Math.random() * particleCanvas.width,
                            y: particleCanvas.height + 10,
                            size: 2 + Math.random() * 4,
                            speedY: -(1.5 + Math.random() * 2.5),
                            speedX: (Math.random() - 0.5) * 1.5,
                            color: Math.random() > 0.5 ? '#ff6b1a' : '#222222',
                            life: 1,
                            decay: 0.006 + Math.random() * 0.008,
                            glow: Math.random() > 0.7 // 30% chance to glow
                        };
                    }

                    // Create 150 particles for dense effect
                    for (let i = 0; i < 150; i++) {
                        const p = createParticle();
                        p.y = Math.random() * particleCanvas.height; // Spread initially
                        p.life = Math.random();
                        particles.push(p);
                    }

                    // Animation loop
                    function animate() {
                        ctx.clearRect(0, 0, particleCanvas.width, particleCanvas.height);
                        ctx.globalCompositeOperation = 'lighter';

                        for (let i = 0; i < particles.length; i++) {
                            const p = particles[i];

                            // Update
                            p.x += p.speedX;
                            p.y += p.speedY;
                            p.life -= p.decay;

                            // Reset if dead
                            if (p.life <= 0 || p.y < -20) {
                                particles[i] = createParticle();
                                continue;
                            }

                            // Draw glow if enabled
                            if (p.glow) {
                                const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 3);
                                gradient.addColorStop(0, p.color === '#ff6b1a' ?
                                    `rgba(255, 107, 26, ${p.life * 0.6})` :
                                    `rgba(80, 80, 80, ${p.life * 0.4})`);
                                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                                ctx.fillStyle = gradient;
                                ctx.fillRect(p.x - p.size * 3, p.y - p.size * 3, p.size * 6, p.size * 6);
                            }

                            // Draw particle core
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                            ctx.fillStyle = p.color === '#ff6b1a' ?
                                `rgba(255, 107, 26, ${p.life * 0.9})` :
                                `rgba(50, 50, 50, ${p.life * 0.8})`;
                            ctx.fill();
                        }

                        if (currentBiome.name === 'PUMPKIN MOON' && !window.isCutsceneActive) {
                            requestAnimationFrame(animate);
                        }
                    }

                    animate();

                    // Handle window resize
                    window.addEventListener('resize', () => {
                        if (particleCanvas) {
                            particleCanvas.width = window.innerWidth;
                            particleCanvas.height = window.innerHeight;
                        }
                    });
                }
                }
            } else if (currentBiome.name === 'BLAZING SUN') {
                biomeOverlay.style.background = 'radial-gradient(ellipse at 50% 0%, rgba(255, 215, 0, 0.4) 0%, rgba(255, 165, 0, 0.3) 30%, rgba(135, 206, 250, 0.2) 100%)';
                biomeOverlay.style.opacity = '0.6';
                biomeOverlay.classList.add('active');
                clearPumpkinEffects();

                if (useLiteBiomeEffects) {
                    clearBlazingSunEffects();
                } else {
                    let sunRaysContainer = document.getElementById('sun-rays');
                    if (!sunRaysContainer) {
                        sunRaysContainer = document.createElement('div');
                        sunRaysContainer.id = 'sun-rays';
                        sunRaysContainer.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1; overflow: hidden;';


                    // Add atmospheric glow layer (soft background light)
                    const atmosphere = document.createElement('div');
                    atmosphere.style.cssText = `
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 60%;
                        background: radial-gradient(ellipse at 50% 0%, 
                            rgba(255, 220, 150, 0.4) 0%, 
                            rgba(255, 200, 100, 0.1) 60%, 
                            transparent 80%);
                        z-index: -1;
                        filter: blur(40px);
                    `;
                    sunRaysContainer.appendChild(atmosphere);

                    // Create 6 soft volumetric sun beams (conical and blurred)
                    for (let i = 0; i < 6; i++) {
                        const ray = document.createElement('div');
                        // Randomize angles slightly for natural look
                        const baseAngle = ((i / 6) * 120) - 60; // Spread across 120 degrees (-60 to +60)
                        const randomOffset = (Math.random() - 0.5) * 15;
                        const angle = baseAngle + randomOffset;

                        const width = 100 + Math.random() * 100;
                        const length = 120 + Math.random() * 30; // Percentage height

                        ray.style.cssText = `
                            position: absolute;
                            top: -20%;
                            left: 50%;
                            width: ${width}px;
                            height: ${length}%;
                            background: linear-gradient(180deg, 
                                rgba(255, 255, 255, 0) 0%, 
                                rgba(255, 250, 200, 0.3) 15%, 
                                rgba(255, 220, 100, 0.05) 50%, 
                                rgba(255, 220, 100, 0) 80%);
                            --angle: ${angle}deg;
                            transform-origin: top center;
                            transform: translateX(-50%) rotate(var(--angle));
                            filter: blur(15px); /* Strong blur to remove hard edges */
                            border-radius: 50%; /* Rounded shape to avoid boxiness */
                            animation: sunRayPulse ${5 + Math.random() * 5}s ease-in-out infinite;
                            animation-delay: ${Math.random() * 2}s;
                            opacity: 0.8;
                        `;
                        sunRaysContainer.appendChild(ray);
                    }

                    // Add bright, soft sun glow at top
                    const sunGlow = document.createElement('div');
                    sunGlow.style.cssText = `
                        position: absolute;
                        top: -100px;
                        left: 50%;
                        transform: translateX(-50%);
                        width: 600px;
                        height: 600px;
                        background: radial-gradient(circle, 
                            rgba(255, 255, 255, 0.8) 0%,
                            rgba(255, 235, 150, 0.4) 30%,
                            rgba(255, 200, 50, 0.1) 60%,
                            transparent 70%);
                        filter: blur(30px);
                        z-index: 2;
                        animation: sunGlowPulse 6s ease-in-out infinite;
                    `;
                    sunRaysContainer.appendChild(sunGlow);

                    // Add subtle floating dust particles for atmosphere
                    for (let i = 0; i < 30; i++) {
                        const speck = document.createElement('div');
                        speck.style.cssText = `
                            position: absolute;
                            left: ${Math.random() * 100}%;
                            top: ${Math.random() * 100}%;
                            width: ${2 + Math.random() * 3}px;
                            height: ${2 + Math.random() * 3}px;
                            background: rgba(255, 255, 200, 0.6);
                            border-radius: 50%;
                            box-shadow: 0 0 4px rgba(255, 215, 0, 0.8);
                            animation: dustFloat ${10 + Math.random() * 10}s linear infinite;
                            opacity: 0;
                        `;
                        sunRaysContainer.appendChild(speck);
                    }

                    // CSS Animations
                    if (!document.getElementById('sun-ray-animation')) {
                        const style = document.createElement('style');
                        style.id = 'sun-ray-animation';
                        style.textContent = `
                            @keyframes sunRayPulse {
                                0%, 100% { opacity: 0.5; transform: translateX(-50%) rotate(var(--angle)) scaleX(1); }
                                50% { opacity: 0.8; transform: translateX(-50%) rotate(var(--angle)) scaleX(1.1); }
                            }
                            @keyframes sunGlowPulse {
                                0%, 100% { opacity: 0.8; transform: translateX(-50%) scale(1); }
                                50% { opacity: 1; transform: translateX(-50%) scale(1.05); }
                            }
                            @keyframes dustFloat {
                                0% { transform: translateY(0) translateX(0); opacity: 0; }
                                20% { opacity: 0.8; }
                                80% { opacity: 0.8; }
                                100% { transform: translateY(100px) translateX(${Math.random() > 0.5 ? 50 : -50}px); opacity: 0; }
                            }
                        `;
                        document.head.appendChild(style);
                    }
                        document.body.appendChild(sunRaysContainer);
                    }
                }
            } else if (currentBiome.name === 'LIMBO') {
                biomeOverlay.style.background = 'radial-gradient(ellipse at 50% 10%, rgba(28, 28, 28, 0.45) 0%, rgba(0, 0, 0, 0.82) 62%, rgba(0, 0, 0, 0.95) 100%)';
                biomeOverlay.style.opacity = '0.78';
                biomeOverlay.classList.add('active');
                clearPumpkinEffects();
                clearBlazingSunEffects();
            } else {
                // Full screen color tint based on biome
                const color = currentBiome.color;
                biomeOverlay.style.background = color;
                biomeOverlay.style.opacity = '0.35';
                biomeOverlay.classList.add('active');
                clearPumpkinEffects();
                clearBlazingSunEffects();
            }

            // Check for weather updates
            renderWeather();
        }


        const STRICT_WEATHER_EXCLUSIVE_KEYS = new Set([
            'PUMPKIN MOON',
            'GRAVEYARD',
            'BLOOD RAIN',
            'BLAZING SUN'
        ]);

        function normalizeEnvKey(value) {
            return String(value || '')
                .toUpperCase()
                .replace(/[_\s]+/g, ' ')
                .trim();
        }

        function matchesCurrentBiome(valueOrList) {
            const currentBiomeKey = normalizeEnvKey(currentBiome?.name);
            if (!valueOrList) return false;

            if (Array.isArray(valueOrList)) {
                return valueOrList.some(entry => normalizeEnvKey(entry) === currentBiomeKey);
            }

            return normalizeEnvKey(valueOrList) === currentBiomeKey;
        }

        function isStrictWeatherExclusiveAura(aura) {
            if (!aura || !aura.weather) return false;
            const weatherList = Array.isArray(aura.weather) ? aura.weather : [aura.weather];
            return weatherList.some(entry => STRICT_WEATHER_EXCLUSIVE_KEYS.has(normalizeEnvKey(entry)));
        }

        function passesBiomeExclusiveRule(aura) {
            if (!aura || !aura.biomeExclusive) return true;
            if (Array.isArray(aura.biomeExclusive)) {
                return aura.biomeExclusive.some(entry => matchesCurrentBiome(entry));
            }
            return matchesCurrentBiome(aura.biomeExclusive);
        }

        function passesLimboAuraRule(aura) {
            if (normalizeEnvKey(currentBiome?.name) !== 'LIMBO') return true;
            if (!aura || !aura.biomeExclusive) return false;
            const exclusives = Array.isArray(aura.biomeExclusive) ? aura.biomeExclusive : [aura.biomeExclusive];
            return exclusives.some(entry => normalizeEnvKey(entry) === 'LIMBO');
        }

        function getAuraEffectiveChanceWithLuck(aura, playerLuck) {
            // 1. Check exclusivity/unrollable
            if (aura.unrollable) return 0;
            if (!passesLimboAuraRule(aura)) return 0;
            if (!passesBiomeExclusiveRule(aura)) return 0;
            if (isStrictWeatherExclusiveAura(aura) && !matchesCurrentBiome(aura.weather)) return 0;

            // 2. Determine Base Chance (Denominator)
            let baseChance = aura.chance;
            let biomeMultiplier = 1;

            // Check Native Conditions
            const isNative = isAuraNative(aura);

            if (isNative) {
                if (aura.nativeChance) baseChance = aura.nativeChance;
                biomeMultiplier = currentBiome.multiplier;
            }

            if (baseChance <= 0) return 0;

            // 3. Apply luck: Effective chance = baseChance / (playerLuck * biomeMultiplier)
            // This means higher luck = lower effective rarity = easier to get
            const effectiveChance = baseChance / (playerLuck * biomeMultiplier);
            return effectiveChance;
        }

        function calculateChance(aura) {
            // Display logic - shows the base rarity for the aura
            // For native auras, show the native chance
            // We do NOT apply biome multiplier here - that's for luck, not display

            let baseChance = aura.chance;

            // If native and has native chance, use that
            if (isAuraNative(aura) && aura.nativeChance) {
                baseChance = aura.nativeChance;
            }

            // Return the rarity as-is (no luck or biome multiplier for display)
            return Math.round(Math.max(1, baseChance));
        }

        // Check if aura is native to current biome/weather/time
        function isAuraNative(aura, allowRainy = false) {
            // Check if aura is excluded from current weather
            if (aura.excludeWeather && matchesCurrentBiome(aura.excludeWeather)) return false;

            // Tide Gauntlet special: Rainy auras are native during bonus rolls
            if (allowRainy) {
                const isRainy = (aura.biome && normalizeEnvKey(aura.biome) === 'RAINY') ||
                    (aura.weather && (Array.isArray(aura.weather) ?
                        aura.weather.some(w => normalizeEnvKey(w) === 'RAINY') :
                        normalizeEnvKey(aura.weather) === 'RAINY'));
                if (isRainy) return true;
            }

            if (aura.biome && matchesCurrentBiome(aura.biome)) return true;
            if (aura.weather && matchesCurrentBiome(aura.weather)) return true;
            if (aura.time && normalizeEnvKey(aura.time) === normalizeEnvKey(currentTime)) return true;
            return false;
        }

        // Check if aura is a "global" aura (no biome, weather, biomeExclusive, or time restriction)
        function isGlobalAura(aura) {
            return !aura.biome && !aura.weather && !aura.biomeExclusive && !aura.time;
        }

        // Sol's RNG Waterfall System: Priority-based selection from Rarest to Common
        function rollAura(baseLuckMultiplier = 1, oneTimeStats = null, allowRainy = false) {
            // Check for forced next roll (from admin panel)
            if (window.forcedNextRollAura) {
                const forcedAura = window.forcedNextRollAura;
                window.forcedNextRollAura = null; // Clear it after use
                if (window.DEBUG_LOGS) {
                    console.log(`[FORCE ROLL] Forcing aura: ${forcedAura.name} (1 in ${forcedAura.chance.toLocaleString()})`);
                }
                showNotification(`Forced: ${forcedAura.name}!`, forcedAura.color || '#00cec9');
                return forcedAura;
            }

            const axisBuff = activeBuffs['axis_potion'];
            let totalLuck = 1;

            if (axisBuff && axisBuff.isAxis && axisBuff.stats.axisLuck) {
                totalLuck = axisBuff.stats.axisLuck;
            } else {
                // OFFICIAL SOL'S RNG FORMULA:
                // Total Luck = ((1 + Basic Buffs) * Bonus Roll + Special Buffs) * VIP
                totalLuck = calculateLuckFromFormula(baseLuckMultiplier, oneTimeStats, true);

                // Unfathomable Ruins: Every 1000th roll grants x100 Luck for 10 rolls
                if (isUnfathomableRuinsEquipped()) {
                    // Check if we need to activate the buff (on the 1000th roll)
                    // Note: playerStats.totalRolls is incremented AFTER the roll usually, 
                    // but let's check current count. If it's 999, this is the 1000th roll.
                    // Or if we track it differently. Let's assume standard counter.
                    // Actually, simpler: if (playerStats.totalRolls % 1000 === 0) -> this is roll #1000? 
                    // No, usually initialized at 0. Roll 1 -> totalRolls=1. 
                    // So if (totalRolls % 1000 === 999) then NEXT is 1000? 
                    // Let's stick to: "Every 1000th roll". 
                    // If totalRolls is 999, we are ABOUT to roll the 1000th.
                    // Let's trigger it when `(playerStats.totalRolls + 1) % 1000 === 0`.
                    if ((playerStats.totalRolls + 1) % 1000 === 0) {
                        activateUnfathomableBuff();
                    }

                    // Apply buff if active
                    if (unfathomableBuffActive && unfathomableBuffRollsRemaining > 0) {
                        totalLuck *= 100;
                        unfathomableBuffRollsRemaining--;
                        updateRollCount();
                        if (unfathomableBuffRollsRemaining <= 0) {
                            unfathomableBuffActive = false;
                            if (typeof updateUnfathomableVignette === 'function') updateUnfathomableVignette(false);
                            updateRollCount();
                            showNotification("Unfathomable Power Faded", '#7f8c8d');
                        }
                    }
                }
            }

            if (window.DEBUG_LOGS) {
                console.log(`[ROLL] TOTAL LUCK: ${totalLuck.toLocaleString(undefined, { maximumFractionDigits: 1 })} | Multiplier: x${baseLuckMultiplier}`);
            }

            // 1. Initial filter for basic roll conditions
            const validAuras = AURAS.filter(aura => {
                if (aura.unrollable && (!oneTimeStats || oneTimeStats.sourceId !== aura.requiredPotion)) return false;
                if (aura.requiredUnlock && (!oneTimeStats || !oneTimeStats.unlockAuras || !oneTimeStats.unlockAuras.includes(aura.id))) return false;
                if (!passesLimboAuraRule(aura)) return false;
                if (!passesBiomeExclusiveRule(aura)) return false;
                if (isStrictWeatherExclusiveAura(aura) && !matchesCurrentBiome(aura.weather)) return false;
                return true;
            });

            const biomeMultiplier = currentBiome.multiplier || 1;

            // 2. SPECIAL: Roll for ignoreLuck auras FIRST (potion exclusives like Memory, Oblivion)
            // These are rolled separately and NOT affected by the floor/waterfall system
            const ignoreLuckAuras = validAuras.filter(a => a.ignoreLuck);

            // DEBUG: Log what's happening with potion auras
            if (oneTimeStats) {
                if (window.DEBUG_LOGS) {
                    console.log(`[DEBUG POTION] oneTimeStats:`, oneTimeStats);
                    console.log(`[DEBUG POTION] sourceId: ${oneTimeStats.sourceId}`);
                    console.log(`[DEBUG POTION] unlockAuras:`, oneTimeStats.unlockAuras);
                    console.log(`[DEBUG POTION] ignoreLuckAuras found: ${ignoreLuckAuras.length}`, ignoreLuckAuras.map(a => `${a.name} (${a.id})`));
                }
            }

            for (const aura of ignoreLuckAuras) {
                // Roll with pure chance (no luck applied)
                const roll = Math.random();
                const threshold = 1 / aura.chance;
                if (window.DEBUG_LOGS) {
                    console.log(`[DEBUG ROLL] Testing ${aura.name}: roll=${roll.toFixed(6)}, threshold=${threshold.toFixed(6)}, hit=${roll < threshold}`);
                }
                if (roll < threshold) {
                    console.log(`[ROLL SUCCESS - IGNORE LUCK] ${aura.name} | 1 in ${aura.chance.toLocaleString()}`);
                    return aura;
                }
            }

            // DEBUG: If skipToSpecialAuras is enabled and we have ignoreLuck auras available,
            // skip the normal waterfall and return Nothing (so we only see special aura hits)
            if (userSettings.debug?.skipToSpecialAuras && ignoreLuckAuras.length > 0) {
                if (window.DEBUG_LOGS) {
                    console.log(`[DEBUG] Skip mode active - no special aura hit this roll`);
                }
                return AURAS.find(a => a.id === 'nothing') || AURAS[0];
            }

            const hasVampireHunter = (playerInventory.equipped.right === 'vampire-hunter');
            const halloweenAuras = ['pump', 'lunar_nightfall', 'vital', 'moonflower', 'cryptfire', 'soul_hunter', 'dullahan', 'nightmare_sky', 'harvester', 'apostolos_veil', 'stingy_jack', 'jack_o_lantern_aura', 'guising', 'samhain', 'harvest'];

            const HALLOWEEN_BIOMES = new Set(['PUMPKIN MOON', 'GRAVEYARD', 'BLOOD RAIN']);
            const isHalloween = (a) => {
                const exclusives = Array.isArray(a.biomeExclusive) ? a.biomeExclusive : [a.biomeExclusive];
                const hasHalloweenBiome = exclusives.some(entry => HALLOWEEN_BIOMES.has(normalizeEnvKey(entry)));
                return hasHalloweenBiome || halloweenAuras.includes(a.id);
            };

            // 3. Prepare the Pool (Calculated Once)
            const normalAuras = validAuras.filter(a => !a.ignoreLuck);
            const auraPool = normalAuras.map(aura => {
                const isNative = isAuraNative(aura, allowRainy);
                let baseChance = (isNative && aura.nativeChance) ? aura.nativeChance : aura.chance;

                // Vampire Hunter: 20% rarity reduction for Halloween auras
                if (hasVampireHunter && isHalloween(aura)) {
                    baseChance *= 0.8;
                }

                const lucForThisAura = isNative ? (totalLuck * biomeMultiplier) : totalLuck;
                const effectiveRarity = baseChance / Math.max(lucForThisAura, Number.EPSILON);

                // Shared-odds model: per-aura hit chance is adjusted luck chance, capped at 50%.
                let probability = 1 / effectiveRarity;
                probability = Math.min(Math.max(probability, 0), 0.5);

                return { aura, baseChance, effectiveRarity, probability };
            }).sort((a, b) => b.effectiveRarity - a.effectiveRarity); // RAREST FIRST (after adjustments)

            if (auraPool.length === 0) {
                // Defensive fallback to avoid an infinite loop when all candidates are filtered out.
                return AURAS.find(a => a.id === 'nothing') || AURAS[0];
            }

            // 4. THE LOOPING WATERFALL
            // Explicitly loop until an aura is selected.
            // "It is important to note that odds cannot go higher than 1 in 2" -> 50% Cap
            // "if nothing is selected, the process starts again" -> Loop
            while (true) {
                for (const item of auraPool) {
                    const { aura, baseChance, probability } = item;
                    if (Math.random() < probability) {
                        const prob = (probability * 100).toFixed(4);
                        // console.log(`[ROLL SUCCESS] ${aura.name} | 1 in ${baseChance.toLocaleString()} | Hit Chance: ${prob}%`);
                        return aura;
                    }
                }
                // If we reach here, nothing was selected. Loop restarts automatically.
                // This replaces the "Floor" logic essentially with a statistical guarantee eventually.
            }
        }

        function getCurrentAuraChanceValue(aura) {
            if (!aura) return 0;
            if (isAuraNative(aura) && aura.nativeChance) return aura.nativeChance;
            return aura.chance || 0;
        }

        function rollAuraWithFatebreaker(baseLuckMultiplier = 1, oneTimeStats = null, allowRainy = false) {
            if (!isFatebreakerDeviceEquipped() || !fatebreakerCharged) {
                return rollAura(baseLuckMultiplier, oneTimeStats, allowRainy);
            }

            const rolls = [
                rollAura(baseLuckMultiplier, oneTimeStats, allowRainy),
                rollAura(baseLuckMultiplier, oneTimeStats, allowRainy),
                rollAura(baseLuckMultiplier, oneTimeStats, allowRainy)
            ];

            let best = rolls[0];
            let bestChance = getCurrentAuraChanceValue(best);
            for (let i = 1; i < rolls.length; i++) {
                const chance = getCurrentAuraChanceValue(rolls[i]);
                if (chance > bestChance) {
                    best = rolls[i];
                    bestChance = chance;
                }
            }

            fatebreakerCharged = false;
            showNotification(`SINGULARITY COLLAPSE! Picked ${best.name} from 3 outcomes.`, '#ff9f43');
            updateRollCount();
            return best;
        }


        function updateDisplay(aura, isFinal = false) {
            const overlay = document.getElementById('roll-overlay');
            const nameEl = document.getElementById('overlay-name');
            const chanceEl = document.getElementById('overlay-chance');

            if (!aura) return;

            // Check if aura is native
            const native = isAuraNative(aura) && aura.nativeChance;

            nameEl.textContent = aura.name;
            nameEl.setAttribute('data-text', aura.name);

            // Calculate display chance based on current environment state
            // calculateChance already handles native logic
            const oneInX = calculateChance(aura);

            // Show custom display rarity if it exists (for special potion auras)
            if (aura.displayRarity) {
                chanceEl.innerHTML = `<span style="color: #e056fd; font-size: 12px; display: block; font-style: italic;">${aura.displayRarity}</span>1 in ${oneInX.toLocaleString()}`;
            } else if (native) {
                // Show native indicator if applicable
                chanceEl.innerHTML = `<span style="color: #2ecc71; font-size: 10px; display: block;">* NATIVE *</span>1 in ${oneInX.toLocaleString()}`;
            } else {
                chanceEl.textContent = `1 in ${oneInX.toLocaleString()}`;
            }

            // Apply colors
            const mainColor = aura.color || '#ffffff';

            // Apply per-aura typography
            applyAuraTypography(nameEl, aura, "'Sarpanch', sans-serif", 'bold');

            // Apply gradient if specified, otherwise use solid color
            if (aura.gradient) {
                if (window.DEBUG_LOGS) {
                    console.log('[GRADIENT DEBUG] Applying gradient for:', aura.name, aura.gradient);
                }

                // Remove gradient classes first
                nameEl.classList.remove('has-gradient', 'has-gradient-outline');

                // Build the complete style string for gradient text
                let gradientStyles = `
                    background: ${aura.gradient} !important;
                    -webkit-background-clip: text !important;
                    background-clip: text !important;
                    background-size: ${aura.backgroundSize || '100% 100%'};
                    background-position: center center;
                `;

                // For gradient text with outline (has textShadow defined), use stroke method
                // Text-shadow doesn't work with gradient text - use -webkit-text-stroke instead
                if (aura.textShadow && !aura.blackFill && !aura.whiteFill) {
                    // Use paint-order to paint stroke behind fill
                    gradientStyles += `
                        color: transparent !important;
                        -webkit-text-fill-color: transparent !important;
                        -webkit-text-stroke: 2px #000000;
                        paint-order: stroke fill;
                    `;
                } else if (aura.blackFill) {
                    // For GARGANTUA-style effect: gradient background with black fill
                    // The gradient shows through via the background-clip
                    gradientStyles += `
                        -webkit-text-fill-color: #000000 !important;
                    `;
                    // Don't set color to black - let the gradient background show
                } else if (aura.whiteFill) {
                    // For GARGANTUA : WHITEHOLE effect: gradient background with white fill
                    // The inverse of blackFill - bright and radiant
                    gradientStyles += `
                        -webkit-text-fill-color: #ffffff !important;
                    `;
                    // Don't set color to white - let the gradient background show
                } else {
                    gradientStyles += `
                        color: transparent !important;
                        -webkit-text-fill-color: transparent !important;
                    `;
                }

                // Apply textStroke if defined (for GARGANTUA's transparent stroke)
                if (aura.textStroke) {
                    gradientStyles += `
                        -webkit-text-stroke: ${aura.textStroke} !important;
                    `;
                }

                // Don't apply text-shadow for gradient text - it doesn't render correctly
                gradientStyles += `text-shadow: none !important;`;

                // Apply all gradient styles at once via cssText
                const existingStyles = nameEl.getAttribute('style') || '';
                // Remove any old gradient-related styles first
                const cleanedStyles = existingStyles
                    .replace(/background[^;]*;?/gi, '')
                    .replace(/-webkit-background-clip[^;]*;?/gi, '')
                    .replace(/background-clip[^;]*;?/gi, '')
                    .replace(/background-size[^;]*;?/gi, '')
                    .replace(/background-position[^;]*;?/gi, '')
                    .replace(/-webkit-text-fill-color[^;]*;?/gi, '')
                    .replace(/-webkit-text-stroke[^;]*;?/gi, '')
                    .replace(/paint-order[^;]*;?/gi, '')
                    .replace(/text-shadow[^;]*;?/gi, '');

                nameEl.style.cssText = cleanedStyles + gradientStyles;

                if (window.DEBUG_LOGS) {
                    console.log('[GRADIENT DEBUG] Applied cssText:', nameEl.style.cssText);
                }
            } else {
                // Remove gradient classes and reset styles
                nameEl.classList.remove('has-gradient', 'has-gradient-outline');
                nameEl.style.removeProperty('--aura-stroke-width');
                nameEl.style.removeProperty('--aura-stroke-color');
                // Clear the !important values by removing the properties
                nameEl.style.removeProperty('background-image');
                nameEl.style.removeProperty('background-clip');
                nameEl.style.removeProperty('-webkit-background-clip');
                nameEl.style.removeProperty('background-color');
                nameEl.style.removeProperty('text-shadow');
                nameEl.style.removeProperty('-webkit-text-fill-color');
                // Set normal styles
                nameEl.style.color = mainColor;
                nameEl.style.textShadow = `0 0 20px ${mainColor}66`;
            }

            // Apply animation if specified
            if (aura.animation) {
                nameEl.style.display = 'inline-block'; // Required for transform animations
                if (aura.animation === 'equinox') {
                    // Equinox requires special dual-layer structure
                    // Create wrapper with two overlapping spans
                    nameEl.innerHTML = `
                        <span class="equinox-wrapper">
                            <span class="equinox-gradient">${aura.name}</span>
                            <span class="equinox-transition">${aura.name}</span>
                        </span>
                    `;
                    // Clear any conflicting styles
                    nameEl.style.color = '';
                    nameEl.style.webkitTextFillColor = '';
                    nameEl.style.textShadow = '';
                    nameEl.style.background = '';
                    nameEl.style.backgroundClip = '';
                    nameEl.style.webkitBackgroundClip = '';
                    nameEl.style.animation = '';
                } else if (aura.animation === 'abyssal-hunter') {
                    // Abyssal Hunter requires special dual-layer structure with outline and main gradients
                    const outlineGradient = aura.outlineGradient || 'linear-gradient(172deg, #000000 44%, #2878f8 48%, #2878f8 52%, #000000 56%)';
                    const mainGradient = aura.gradient || 'linear-gradient(172deg, #1d4edd 22%, #4ea6ff 33%, #2392ff 33%, #2392ff 44%, #78b4ff 48%, #78b4ff 52%, #5993ff 56%, #2b5ffc 63%, #3699ff 67%, #5faeff 67%, #3e97ff 71%)';

                    // Check if this is the Deep Sea variant for special glow effect
                    const isDeepSea = aura.id === 'abyssal_hunter_deepsea';
                    const wrapperAnimation = isDeepSea ? 'style="animation: deep-sea-glow 2s ease-in-out infinite;"' : '';

                    nameEl.innerHTML = `
                        <span class="abyssal-wrapper" ${wrapperAnimation}>
                            <span class="abyssal-outline" style="background: ${outlineGradient};">${aura.name}</span>
                            <span class="abyssal-main" style="background: ${mainGradient};">${aura.name}</span>
                        </span>
                    `;
                    // Clear any conflicting styles
                    nameEl.style.color = '';
                    nameEl.style.webkitTextFillColor = '';
                    nameEl.style.textShadow = '';
                    nameEl.style.background = '';
                    nameEl.style.backgroundClip = '';
                    nameEl.style.webkitBackgroundClip = '';
                    nameEl.style.animation = '';
                } else if (aura.animation === 'solstice') {
                    // SOLSTICE requires chromatic aberration effect with RGB split
                    nameEl.innerHTML = `
                        <span class="solstice-wrapper">
                            <span class="solstice-red">${aura.name}</span>
                            <span class="solstice-green">${aura.name}</span>
                            <span class="solstice-blue">${aura.name}</span>
                        </span>
                    `;
                    // Clear any conflicting styles
                    nameEl.style.color = '';
                    nameEl.style.webkitTextFillColor = '';
                    nameEl.style.textShadow = '';
                    nameEl.style.background = '';
                    nameEl.style.backgroundClip = '';
                    nameEl.style.webkitBackgroundClip = '';
                    nameEl.style.animation = '';
                } else if (aura.animation === 'shake') {
                    nameEl.style.animation = 'shake 0.5s linear infinite';
                } else if (aura.animation === 'pulse-slow') {
                    nameEl.style.animation = 'pulse-slow 2s ease-in-out infinite';
                } else if (aura.animation === 'bright-flash') {
                    nameEl.style.animation = 'bright-flash 1s ease-in-out infinite';
                } else if (aura.animation === 'black-hole') {
                    nameEl.style.animation = 'black-hole 3s ease-in-out infinite';
                } else if (aura.animation === 'white-hole') {
                    nameEl.style.animation = 'white-hole 3s ease-in-out infinite';
                } else {
                    // Generic animation support
                    nameEl.style.animation = `${aura.animation} 1s linear infinite`;
                }
            } else {
                nameEl.style.animation = 'none';
            }

            if (isFinal) {
                overlay.classList.add('active');
                if (!quickRollMode) {
                    nameEl.style.transform = 'scale(1.2)';
                    setTimeout(() => { nameEl.style.transform = 'scale(1)'; }, 200);
                }
            }
        }

        // Check if Darkshader is equipped
        function isDarkshaderEquipped() {
            return playerInventory.equipped.left === 'darkshader' || playerInventory.equipped.right === 'darkshader';
        }

        // Check if Lightcaster is equipped
        function isLightcasterEquipped() {
            return playerInventory.equipped.left === 'lightcaster' || playerInventory.equipped.right === 'lightcaster';
        }

        // Check if Chromatic Crusher is equipped
        function isChromaticCrusherEquipped() {
            return playerInventory.equipped.left === 'chromatic-crusher' || playerInventory.equipped.right === 'chromatic-crusher';
        }

        // Returns caster behavior profile when either Lightcaster or Chromatic Crusher is equipped.
        function getCasterProfile() {
            if (isChromaticCrusherEquipped()) {
                return {
                    mode: 'crusher',
                    threshold: 2,
                    normalBonusLuck: 5,
                    phaseLuck: 6,
                    phaseBonusLuck: 12,
                    phaseTriggerRolls: 10,
                    phaseDurationRolls: 12,
                    phaseRollSpeedBonus: 0.25,
                    phaseLabel: 'PRISMATIC'
                };
            }
            if (isLightcasterEquipped()) {
                return {
                    mode: 'lightcaster',
                    threshold: 3,
                    normalBonusLuck: 3.5,
                    phaseLuck: 4,
                    phaseBonusLuck: 8,
                    phaseTriggerRolls: 15,
                    phaseDurationRolls: 10,
                    phaseRollSpeedBonus: 0.15,
                    phaseLabel: 'RADIANT'
                };
            }
            return null;
        }

        // Check if Omega Drive is equipped
        function isOmegaDriveEquipped() {
            return playerInventory.equipped.left === 'omega-drive' || playerInventory.equipped.right === 'omega-drive';
        }

        // Check if Unfathomable Ruins is equipped
        function isUnfathomableRuinsEquipped() {
            return playerInventory.equipped.left === 'unfathomable-ruins' || playerInventory.equipped.right === 'unfathomable-ruins';
        }

        // Check if Chronowarden Gauntlet is equipped
        function isChronowardenGauntletEquipped() {
            return playerInventory.equipped.left === 'chronowarden-gauntlet' || playerInventory.equipped.right === 'chronowarden-gauntlet';
        }

        // Check if Cataclysm Device is equipped
        function isCataclysmDeviceEquipped() {
            return playerInventory.equipped.left === 'cataclysm-device' || playerInventory.equipped.right === 'cataclysm-device';
        }

        // Check if Paradox Gauntlet is equipped
        function isParadoxGauntletEquipped() {
            return playerInventory.equipped.left === 'paradox-gauntlet' || playerInventory.equipped.right === 'paradox-gauntlet';
        }

        // Check if Fatebreaker Device is equipped
        function isFatebreakerDeviceEquipped() {
            return playerInventory.equipped.left === 'fatebreaker-device' || playerInventory.equipped.right === 'fatebreaker-device';
        }

        function hasRemoveBonusRollGear() {
            const slots = ['left', 'right'];
            for (const slot of slots) {
                const gearId = playerInventory.equipped[slot];
                if (!gearId) continue;
                const gear = GEARS.find(g => g.id === gearId);
                if (gear && gear.stats && gear.stats.removeBonusRoll) {
                    return true;
                }
            }
            return false;
        }

        let unfathomableBuffActive = false;
        let unfathomableBuffRollsRemaining = 0;
        let chronowardenBuffActive = false;
        let chronowardenBuffRollsRemaining = 0;

        function activateUnfathomableBuff() {
            unfathomableBuffActive = true;
            unfathomableBuffRollsRemaining = 10;
            showNotification("100X LUCK READY for 10 rolls!", '#44ff88');
            if (typeof updateUnfathomableVignette === 'function') updateUnfathomableVignette(true);
            updateRollCount();
        }

        function activateChronowardenBuff() {
            chronowardenBuffActive = true;
            chronowardenBuffRollsRemaining = 6;
            showNotification("CHRONO BURST! x30 Luck for 6 rolls!", '#66ffe0');
            if (typeof updateChronowardenVignette === 'function') updateChronowardenVignette(true);
            updateRollCount();
        }

        // Get the bonus roll threshold (2 with Chromatic Crusher, 3 with Lightcaster, 5 with Darkshader, 6 with Blessed Tide, 10 default)
        function getBonusRollThreshold() {
            const casterProfile = getCasterProfile();
            if (casterProfile) return casterProfile.threshold;
            if (playerInventory.equipped.left === 'blessed-tide-gauntlet') return 6;
            return isDarkshaderEquipped() ? 5 : 10;
        }

        // --- VIDEO AND AUDIO PRELOADING SYSTEM ---
        // Cache for preloaded videos and audio
        const preloadedVideos = new Map();
        const preloadedAudios = new Map();

        // Preload a video by creating an offscreen video element
        function preloadVideo(src) {
            if (preloadedVideos.has(src)) return preloadedVideos.get(src);

            const video = document.createElement('video');
            video.preload = 'auto';
            video.muted = true; // Required for some browsers to allow preload
            video.src = src;
            video.load();

            preloadedVideos.set(src, video);
            return video;
        }

        // Preload an audio file
        function preloadAudio(src) {
            if (preloadedAudios.has(src)) return preloadedAudios.get(src);

            const audio = new Audio();
            audio.preload = 'auto';
            audio.src = src;
            audio.load();

            preloadedAudios.set(src, audio);
            return audio;
        }

        // Preload all cutscene videos and flashbang audio on page load
        function preloadCutsceneAssets() {
            if (window.__cutscenePreloadStarted) return;
            window.__cutscenePreloadStarted = true;

            // Keep startup smooth: preload only audio immediately.
            preloadAudio('cutscenes/1bil_trancend.mp3.mpeg');
            preloadAudio('cutscenes/100maura.ogg');

            // Stage video preload lazily in idle time and spaced batches.
            const queue = (typeof VIDEO_CUTSCENES !== 'undefined') ? Object.values(VIDEO_CUTSCENES) : [];
            let index = 0;

            const preloadStep = () => {
                if (index >= queue.length) return;
                preloadVideo(queue[index]);
                index++;
                setTimeout(preloadStep, 1200);
            };

            const startQueue = () => {
                // Warm a small subset first; defer the rest.
                const warmCount = Math.min(2, queue.length);
                for (let i = 0; i < warmCount; i++) {
                    preloadVideo(queue[index]);
                    index++;
                }
                setTimeout(preloadStep, 2000);
            };

            if ('requestIdleCallback' in window) {
                requestIdleCallback(startQueue, { timeout: 5000 });
            } else {
                setTimeout(startQueue, 3000);
            }

            console.log('[Preloader] Staged cutscene preload started');
        }

        // Call preloader after page loads
        if (document.readyState === 'complete') {
            setTimeout(preloadCutsceneAssets, 3500);
        } else {
            window.addEventListener('load', () => {
                setTimeout(preloadCutsceneAssets, 3500);
            });
        }

        // Play video cutscene for ultra-rare auras
        function playVideoCutscene(aura, callback, forcePlay = false) {
            // Respect global cutscene settings unless explicitly force-testing from admin.
            if (!forcePlay && !shouldShowCutscene(aura)) {
                if (callback) callback();
                return;
            }

            // Pause biome effects to improve performance
            if (window.pauseBiomeEffects) window.pauseBiomeEffects();

            const videoPath = getVideoCutscenePath(aura.id);
            if (!videoPath) {
                if (callback) callback();
                return;
            }

            const overlay = document.getElementById('video-cutscene-overlay');
            const video = document.getElementById('cutscene-video');
            const flashEl = document.getElementById('cutscene-flash');
            const transition = getCutsceneTransition(aura.id);

            // Hide the roll overlay during video cutscene
            const rollOverlay = document.getElementById('roll-overlay');
            if (rollOverlay) rollOverlay.style.visibility = 'hidden';

            // Wrap callback to restore roll overlay visibility when cutscene ends
            const wrappedCallback = () => {
                // Resume biome effects
                if (window.resumeBiomeEffects) window.resumeBiomeEffects();

                if (rollOverlay) rollOverlay.style.visibility = 'visible';
                if (callback) callback();
            };

            // Set video source - use preloaded video if available
            const preloadedVid = preloadedVideos.get(videoPath);
            if (preloadedVid && preloadedVid.readyState >= 3) {
                // Copy data from preloaded video for instant playback
                video.src = videoPath;
            } else {
                video.src = videoPath;
                video.load(); // Start loading immediately
            }

            // Apply custom transition if specified
            if (transition) {
                // Hide video initially so loading indicator isn't visible
                video.style.opacity = '0';

                // Set the fade color
                overlay.style.background = transition.fadeColor;
                overlay.style.opacity = '0';
                overlay.style.display = 'flex';
                overlay.style.transition = `opacity ${transition.fadeDuration}ms ease-in-out`;

                // Start fade in to the color
                setTimeout(() => {
                    overlay.style.opacity = '1';
                }, 10);

                // Wait for video to be ready AND fade to complete
                const playWhenReady = () => {
                    const fadeComplete = transition.fadeDuration + transition.holdDuration;

                    // Helper to execute the visual reveal
                    const runReveal = () => {
                        // If video is not playing (and not ended), try to play it
                        const playPromise = video.paused && !video.ended ? video.play() : Promise.resolve();

                        playPromise.then(() => {
                            if (transition.videoFadeInDuration) {
                                video.style.transition = `opacity ${transition.videoFadeInDuration}ms ease-in-out`;
                                requestAnimationFrame(() => {
                                    video.style.opacity = '1';
                                });
                            } else {
                                video.style.opacity = '1';
                            }
                        }).catch(err => {
                            console.error('Video playback failed:', err);
                            overlay.style.display = 'none';
                            wrappedCallback();
                        });
                    };

                    // If audio should play during transition, start it immediately when ready
                    if (transition.playAudioDuringTransition) {
                        if (video.readyState >= 3) {
                            video.play().catch(err => console.warn('Early audio playback blocked:', err));
                        } else {
                            video.addEventListener('canplay', () => {
                                video.play().catch(err => console.warn('Early audio playback blocked:', err));
                            }, { once: true });
                        }
                    }

                    // Schedule the visual reveal to happen after fadeComplete
                    if (video.readyState >= 3) { // HAVE_FUTURE_DATA or better
                        setTimeout(runReveal, fadeComplete);
                    } else {
                        // Video not ready yet, wait for it
                        video.addEventListener('canplay', () => {
                            setTimeout(runReveal, Math.max(0, fadeComplete - (Date.now() - startTime)));
                        }, { once: true });
                    }
                };

                const startTime = Date.now();
                playWhenReady();
            } else {
                // No transition, show immediately with black background
                video.style.opacity = '1';
                overlay.style.background = '#000';
                overlay.style.opacity = '1';
                overlay.style.transition = 'none';
                overlay.style.display = 'flex';

                // Wait for video to be ready before playing
                if (video.readyState >= 3) {
                    video.play().catch(err => {
                        console.error('Video playback failed:', err);
                        overlay.style.display = 'none';
                        wrappedCallback();
                    });
                } else {
                    video.addEventListener('canplay', () => {
                        video.play().catch(err => {
                            console.error('Video playback failed:', err);
                            overlay.style.display = 'none';
                            wrappedCallback();
                        });
                    }, { once: true });
                }
            }

            // Detect when video is near the end to apply greyscale effect
            let endEffectTriggered = false;

            const triggerEnding = () => {
                if (endEffectTriggered) return;
                endEffectTriggered = true;

                // Get flashbang type from cutscenes.js (supports overrides for special auras like Memory/Oblivion)
                const flashbangType = getFlashbangType(aura.id, aura.chance);
                if (flashbangType === 'none') {
                    // For non-100M+ videos, preserve legacy post-video burst chain by rarity.
                    const effectiveChance = getAuraEffectiveChance(aura) || 1;

                    video.pause();
                    overlay.style.display = 'none';
                    overlay.style.background = '#000';
                    overlay.style.opacity = '1';

                    video.style.opacity = '1';
                    video.style.filter = 'none';
                    video.style.transition = 'none';
                    video.currentTime = 0;
                    video.ontimeupdate = null;

                    // 100K-1M: cyan legendary burst + legend sound
                    if (effectiveChance >= 100000 && effectiveChance < 1000000) {
                        playLegendaryFlash(aura, wrappedCallback);
                        return;
                    }
                    // 1M-10M: pink mythic burst + 1M sound
                    if (effectiveChance >= 1000000 && effectiveChance < 10000000) {
                        playMythicFlash(aura, wrappedCallback);
                        return;
                    }
                    // 10M-100M: blue exalted burst + exalted sound
                    if (effectiveChance >= 10000000 && effectiveChance < 100000000) {
                        playExaltedFlash(aura, wrappedCallback);
                        return;
                    }

                    wrappedCallback();
                    return;
                }

                const isTranscendent = flashbangType === 'transcendent';

                if (isTranscendent) {
                    // Use preloaded 1 billion transcend audio (or create new if not preloaded)
                    const audioSrc = 'cutscenes/1bil_trancend.mp3.mpeg';
                    let transcendAudio = preloadedAudios.get(audioSrc);
                    if (!transcendAudio) {
                        transcendAudio = new Audio(audioSrc);
                    } else {
                        // Clone the preloaded audio so we can play it multiple times
                        transcendAudio = transcendAudio.cloneNode();
                    }
                    transcendAudio.volume = (userSettings.audio.sfx / 100) * 0.7 || 0.7;
                    transcendAudio.play().catch(console.error);

                    // Hide video
                    video.pause();
                    video.style.opacity = '0';
                    overlay.style.background = 'transparent';

                    // Apply EXTREME Deep Fried Effect
                    const body = document.body;
                    body.style.transition = 'filter 0.05s ease-out, transform 0.05s ease-out';
                    body.style.filter = 'grayscale(35%) contrast(920%) brightness(165%) saturate(620%) hue-rotate(170deg) drop-shadow(0 0 30px rgba(255,0,255,0.85))';
                    body.style.transform = 'scale(1.055) rotate(0.6deg)';
                    body.style.animation = 'body-distort 2s ease-in-out infinite';

                    const { prismLayer, riftLayer } = createTranscendentAtmosphereLayers('data-1b-effect');
                    prismLayer.style.transition = 'opacity 4s ease-in';
                    prismLayer.style.opacity = '0.9';
                    riftLayer.style.transition = 'opacity 4s ease-in';
                    riftLayer.style.opacity = '0.55';

                    // Use chromatic gradient flash
                    if (flashEl) {
                        flashEl.style.background = 'radial-gradient(circle at 50% 45%, rgba(255,255,255,0.98) 0%, rgba(194,132,255,0.78) 24%, rgba(84,255,255,0.58) 48%, rgba(255,170,70,0.45) 72%, rgba(5,0,20,0.92) 100%)';
                        flashEl.style.mixBlendMode = 'screen';
                        flashEl.style.transition = 'none';
                        flashEl.style.opacity = '0';
                        flashEl.offsetHeight;
                        flashEl.style.transition = 'opacity 4s ease-in';
                        flashEl.style.opacity = '1';
                        flashEl.style.animation = 'reality-shatter 8s ease-in-out';
                    }

                    // HUGE EXPLOSION at 5 seconds
                    setTimeout(() => {
                        // Create explosion flash
                        const explosionFlash = document.createElement('div');
                        explosionFlash.setAttribute('data-1b-effect', 'true');
                        explosionFlash.style.cssText = `
                            position: fixed;
                            top: 0;
                            left: 0;
                            width: 100%;
                            height: 100%;
                            background: radial-gradient(circle, #ffffff 0%, #ffff00 20%, #ff6600 40%, #ff0000 60%, transparent 80%);
                            opacity: 0;
                            z-index: 10001;
                            pointer-events: none;
                            mix-blend-mode: screen;
                        `;
                        document.body.appendChild(explosionFlash);

                        // Intense screen shake
                        body.style.animation = 'explosion-shake 0.5s ease-out';

                        // Add shake keyframes if not exists
                        if (!document.getElementById('explosion-shake-keyframes')) {
                            const shakeStyle = document.createElement('style');
                            shakeStyle.id = 'explosion-shake-keyframes';
                            shakeStyle.textContent = `
                                @keyframes explosion-shake {
                                    0%, 100% { transform: translate(0, 0) scale(1.05) rotate(0.5deg); }
                                    10% { transform: translate(-20px, 15px) scale(1.1) rotate(-2deg); }
                                    20% { transform: translate(20px, -15px) scale(1.08) rotate(2deg); }
                                    30% { transform: translate(-15px, -20px) scale(1.12) rotate(-1deg); }
                                    40% { transform: translate(15px, 20px) scale(1.06) rotate(1deg); }
                                    50% { transform: translate(-10px, 10px) scale(1.1) rotate(-0.5deg); }
                                    60% { transform: translate(10px, -10px) scale(1.07) rotate(0.5deg); }
                                    70% { transform: translate(-5px, -5px) scale(1.05) rotate(0deg); }
                                    80% { transform: translate(5px, 5px) scale(1.03) rotate(0deg); }
                                    90% { transform: translate(-2px, 2px) scale(1.02) rotate(0deg); }
                                }
                            `;
                            document.head.appendChild(shakeStyle);
                        }

                        // Flash in explosion
                        explosionFlash.offsetHeight;
                        explosionFlash.style.transition = 'opacity 0.1s ease-out';
                        explosionFlash.style.opacity = '1';

                        // Intensify body filter momentarily
                        body.style.filter = 'grayscale(0%) contrast(1000%) brightness(200%) saturate(800%) hue-rotate(0deg) drop-shadow(0 0 50px rgba(255,255,0,1))';

                        // After explosion flash, begin slow fade out
                        setTimeout(() => {
                            // Slow fade out everything
                            explosionFlash.style.transition = 'opacity 3s ease-out';
                            explosionFlash.style.opacity = '0';

                            if (flashEl) {
                                flashEl.style.transition = 'opacity 3s ease-out';
                                flashEl.style.opacity = '0';
                                flashEl.style.animation = '';
                            }
                            prismLayer.style.transition = 'opacity 3s ease-out';
                            prismLayer.style.opacity = '0';
                            riftLayer.style.transition = 'opacity 3s ease-out';
                            riftLayer.style.opacity = '0';

                            body.style.animation = '';
                            body.style.transition = 'filter 3s ease-out, transform 3s ease-out';
                            body.style.filter = 'none';
                            body.style.transform = 'none';

                            // Cleanup after slow fade
                            setTimeout(() => {
                                explosionFlash.remove();

                                overlay.style.display = 'none';
                                overlay.style.background = '#000';
                                overlay.style.opacity = '1';
                                if (flashEl) flashEl.style.background = '#fff';
                                if (flashEl) flashEl.style.mixBlendMode = '';

                                video.style.opacity = '1';
                                video.style.filter = 'none';
                                video.style.transition = 'none';

                                prismLayer.remove();
                                riftLayer.remove();
                                body.style.transition = '';
                                body.style.filter = '';
                                body.style.transform = '';

                                video.ontimeupdate = null;

                                wrappedCallback();
                            }, 3000);
                        }, 500); // Hold explosion for 0.5s then slow fade
                    }, 5000);
                } else {
                    // Standard 100M+ deep fried effect
                    try {
                        const audio = new Audio('cutscenes/100maura.ogg');
                        audio.volume = 0.6;
                        audio.play().catch(console.error);
                    } catch (e) { console.error("Audio error", e); }

                    video.pause();
                    video.style.opacity = '0';
                    overlay.style.background = 'transparent';

                    const body = document.body;
                    body.style.transition = 'none';
                    body.style.filter = 'grayscale(100%) contrast(500%) brightness(120%) drop-shadow(0 0 10px rgba(0,0,0,0.5))';
                    body.style.transform = 'scale(1.02)';

                    if (flashEl) {
                        flashEl.style.background = '#fff';
                        flashEl.style.transition = 'none';
                        flashEl.style.opacity = '0';
                        flashEl.offsetHeight;
                        flashEl.style.transition = 'opacity 2.5s ease-in';
                        flashEl.style.opacity = '1';
                    }

                    setTimeout(() => {
                        if (flashEl) {
                            flashEl.style.transition = 'opacity 3s ease-out';
                            flashEl.style.opacity = '0';
                        }

                        body.style.transition = 'filter 3s ease-out, transform 3s ease-out';
                        body.style.filter = 'none';
                        body.style.transform = 'none';

                        setTimeout(() => {
                            overlay.style.display = 'none';
                            overlay.style.background = '#000';
                            overlay.style.opacity = '1';

                            video.style.opacity = '1';
                            video.style.filter = 'none';
                            video.style.transition = 'none';

                            body.style.transition = '';
                            body.style.filter = '';
                            body.style.transform = '';

                            video.ontimeupdate = null;
                            wrappedCallback();
                        }, 3000);

                    }, 3500);
                }
            };
            video.ontimeupdate = () => {
                // Trigger effect 0.25 seconds before video ends to ensure we catch it
                if (!endEffectTriggered && video.duration > 0 && video.currentTime >= video.duration - 0.25) {
                    triggerEnding();
                }
            };

            // Fallback if timeupdate doesn't trigger
            video.onended = () => {
                if (!endEffectTriggered) {
                    triggerEnding();
                }
            };

            // Allow skipping with click
            overlay.onclick = () => {
                if (endEffectTriggered) return;
                triggerEnding();
                overlay.onclick = null;
            };
        }

        // Mini pink flash cutscene for 1M-10M rarity auras
        function playMythicFlash(aura, callback) {
            const flashOverlay = document.createElement('div');
            flashOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: #ff69b4;
                opacity: 0;
                z-index: 10000;
                pointer-events: none;
                transition: opacity 0.15s ease-in;
            `;
            document.body.appendChild(flashOverlay);

            // Play sound
            const sound = new Audio('cutscenes/1M Sound.mpeg');
            sound.volume = (userSettings.audio.sfx / 100) || 0.8;
            sound.play().catch(() => { }); // Ignore autoplay errors

            // Flash in
            flashOverlay.offsetWidth; // Trigger reflow
            requestAnimationFrame(() => {
                flashOverlay.style.opacity = '1';
            });

            // Hold for 0.3s, then fade out over 0.5s
            setTimeout(() => {
                flashOverlay.style.transition = 'opacity 0.5s ease-out';
                flashOverlay.style.opacity = '0';

                // Cleanup and callback
                setTimeout(() => {
                    flashOverlay.remove();
                    if (callback) callback();
                }, 500);
            }, 300);
        }

        // Check if aura should have unique flash (10K to 100K-1 rarity)
        // Uses effective chance (native if applicable)
        function shouldPlayUniqueFlash(aura) {
            const isNative = isAuraNative(aura) && aura.nativeChance;
            const effectiveChance = isNative ? aura.nativeChance : (aura.chance || 1);
            return effectiveChance >= 10000 && effectiveChance < 100000 && !hasVideoCutscene(aura.id);
        }

        // Tiny orange flash for Unique tier (10K-100K rarity)
        function playUniqueFlash(aura, callback) {
            const flashOverlay = document.createElement('div');
            flashOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: radial-gradient(circle, #ff9f43 0%, #e67e22 50%, #d35400 100%);
                opacity: 0;
                z-index: 10000;
                pointer-events: none;
                transition: opacity 0.08s ease-in;
            `;
            document.body.appendChild(flashOverlay);

            // Play legend sound but quieter
            const audioSrc = 'cutscenes/legend.ogg';
            let sound = preloadedAudios.get(audioSrc);
            if (sound) {
                sound = sound.cloneNode();
            } else {
                sound = new Audio(audioSrc);
            }
            sound.volume = (userSettings.audio.sfx / 100) * 0.35 || 0.35;
            sound.play().catch(() => { });

            // Flash in (very dim)
            flashOverlay.offsetWidth; // Trigger reflow
            requestAnimationFrame(() => {
                flashOverlay.style.opacity = '0.35'; // Much dimmer flash
            });

            // Hold for 0.1s (very short), then fade out over 0.2s
            setTimeout(() => {
                flashOverlay.style.transition = 'opacity 0.2s ease-out';
                flashOverlay.style.opacity = '0';

                // Cleanup and callback
                setTimeout(() => {
                    flashOverlay.remove();
                    if (callback) callback();
                }, 200);
            }, 100);
        }

        // Check if aura should have legendary flash (100K to 1M-1 rarity)
        // Uses effective chance (native if applicable)
        function shouldPlayLegendaryFlash(aura) {
            const isNative = isAuraNative(aura) && aura.nativeChance;
            const effectiveChance = isNative ? aura.nativeChance : (aura.chance || 1);
            return effectiveChance >= 100000 && effectiveChance < 1000000 && !hasVideoCutscene(aura.id) && !hasTextCutscene(aura.id);
        }

        // Small cyan flash for Legendary tier (100K-1M rarity)
        function playLegendaryFlash(aura, callback) {
            const flashOverlay = document.createElement('div');
            flashOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: #00ffff;
                opacity: 0;
                z-index: 10000;
                pointer-events: none;
                transition: opacity 0.1s ease-in;
            `;
            document.body.appendChild(flashOverlay);

            // Play sound
            const sound = new Audio('cutscenes/legend.ogg');
            sound.volume = (userSettings.audio.sfx / 100) || 0.8;
            sound.play().catch(() => { }); // Ignore autoplay errors

            // Flash in
            flashOverlay.offsetWidth; // Trigger reflow
            requestAnimationFrame(() => {
                flashOverlay.style.opacity = '1';
            });

            // Hold for 0.2s (shorter than mythic), then fade out over 0.3s
            setTimeout(() => {
                flashOverlay.style.transition = 'opacity 0.3s ease-out';
                flashOverlay.style.opacity = '0';

                // Cleanup and callback
                setTimeout(() => {
                    flashOverlay.remove();
                    if (callback) callback();
                }, 300);
            }, 200);
        }

        // Check if aura should have mythic flash (1M to 10M-1 rarity)
        // Uses effective chance (native if applicable)
        function shouldPlayMythicFlash(aura) {
            // Get the actual rolled rarity (native if applicable)
            const isNative = isAuraNative(aura) && aura.nativeChance;
            const effectiveChance = isNative ? aura.nativeChance : (aura.chance || 1);
            return effectiveChance >= 1000000 && effectiveChance < 10000000 && !hasVideoCutscene(aura.id) && !hasTextCutscene(aura.id);
        }

        // Check if aura should use the generic 1M star video (1M to 100M-1 rarity without specific video)
        function shouldPlay1MStarVideo(aura) {
            const isNative = isAuraNative(aura) && aura.nativeChance;
            const effectiveChance = isNative ? aura.nativeChance : (aura.chance || 1);
            // 1M to 100M (just under Chromatic Genesis), no specific video cutscene, no text cutscene
            return effectiveChance >= 1000000 && effectiveChance < 100000000 && !hasVideoCutscene(aura.id) && !hasTextCutscene(aura.id);
        }

        // Convert hex color to hue rotation angle
        function colorToHueRotate(hexColor) {
            // Parse hex color
            const hex = hexColor.replace('#', '');
            const r = parseInt(hex.substr(0, 2), 16) / 255;
            const g = parseInt(hex.substr(2, 2), 16) / 255;
            const b = parseInt(hex.substr(4, 2), 16) / 255;

            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h = 0;

            if (max !== min) {
                const d = max - min;
                switch (max) {
                    case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                    case g: h = ((b - r) / d + 2) / 6; break;
                    case b: h = ((r - g) / d + 4) / 6; break;
                }
            }

            return Math.round(h * 360);
        }

        // Play the 1M star video with aura color tint, then chain to flash
        function play1MStarVideo(aura, callback) {
            const overlay = document.getElementById('video-cutscene-overlay');
            const video = document.getElementById('cutscene-video');

            // Hide the roll overlay during video cutscene
            const rollOverlay = document.getElementById('roll-overlay');
            if (rollOverlay) rollOverlay.style.visibility = 'hidden';

            // Wrap callback to restore roll overlay visibility
            const wrappedCallback = () => {
                if (rollOverlay) rollOverlay.style.visibility = 'visible';
                if (callback) callback();
            };

            // Get aura color for tinting
            const auraColor = aura.color || '#ffffff';

            // Determine rarity tier for styling
            const isNative = isAuraNative(aura) && aura.nativeChance;
            const effectiveChance = isNative ? aura.nativeChance : (aura.chance || 1);
            const isTenMillionPlus = effectiveChance >= 10000000;

            // Create a color overlay element for tinting the video
            let colorOverlay = document.getElementById('video-color-overlay');
            if (!colorOverlay) {
                colorOverlay = document.createElement('div');
                colorOverlay.id = 'video-color-overlay';
                colorOverlay.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    z-index: 1;
                    transform: translateZ(0);
                `;
                overlay.appendChild(colorOverlay);
            }

            // Apply coloration based on rarity
            if (isTenMillionPlus) {
                // 10M+ PREMIUM SHIMMER EFFECT (Monochromatic)
                // Cycles through the aura's main color with high-intensity "glow" passes
                const glowColor = auraColor.length === 7 ? auraColor + 'ff' : auraColor; // Ensure full opacity for highlights

                colorOverlay.style.background = `linear-gradient(
                    -45deg, 
                    ${auraColor}dd 0%, 
                    ${auraColor}aa 25%, 
                    #ffffffaa 45%, 
                    #ffffffcc 50%, 
                    #ffffffaa 55%, 
                    ${auraColor}aa 75%, 
                    ${auraColor}dd 100%
                )`;
                colorOverlay.style.backgroundSize = '300% 300%';
                colorOverlay.style.mixBlendMode = 'overlay';
                colorOverlay.style.opacity = '0.85';

                // Focused Shimmer Animation (No Hue Rotate)
                if (!document.getElementById('rarity-shimmer-style-v2')) {
                    const style = document.createElement('style');
                    style.id = 'rarity-shimmer-style-v2';
                    style.textContent = `
                        @keyframes rarity-sweep {
                            0% { background-position: 0% 50%; filter: brightness(1) contrast(1); }
                            50% { background-position: 100% 50%; filter: brightness(1.4) contrast(1.1); }
                            100% { background-position: 0% 50%; filter: brightness(1) contrast(1); }
                        }
                    `;
                    document.head.appendChild(style);
                }
                colorOverlay.style.animation = 'rarity-sweep 2s ease-in-out infinite';

                // Keep the grain for texture but remove the aggressive hue-shift
                let textureLayer = document.getElementById('video-texture-overlay');
                if (!textureLayer) {
                    textureLayer = document.createElement('div');
                    textureLayer.id = 'video-texture-overlay';
                    textureLayer.style.cssText = `
                        position: absolute;
                        top: 0; left: 0; width: 100%; height: 100%;
                        pointer-events: none; z-index: 2;
                        opacity: 0.12;
                        background: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
                    `;
                    overlay.appendChild(textureLayer);
                }
                textureLayer.style.display = 'block';

                // Video filter: Saturation and Drop Shadow only (to keep the pure aura color)
                video.style.filter = `saturate(2) brightness(1.1) drop-shadow(0 0 20px ${auraColor})`;
            } else {
                // 1M-9M Standard Tint: Static Radial Gradient
                colorOverlay.style.background = `radial-gradient(circle, ${auraColor}88 0%, ${auraColor}cc 50%, ${auraColor} 100%)`;
                colorOverlay.style.backgroundSize = '100% 100%';
                colorOverlay.style.animation = 'none';
                colorOverlay.style.mixBlendMode = 'color';
                colorOverlay.style.opacity = '0.65';

                const textureLayer = document.getElementById('video-texture-overlay');
                if (textureLayer) textureLayer.style.display = 'none';

                video.style.filter = '';
            }

            // GPU acceleration for video
            video.style.transform = 'translateZ(0)';
            video.style.opacity = '1';

            overlay.style.background = '#000';
            overlay.style.display = 'flex';
            overlay.offsetHeight; // Trigger reflow
            overlay.style.opacity = '1';
            overlay.style.transition = 'none';

            // Clear any previous event handlers BEFORE setting source
            video.onended = null;
            video.ontimeupdate = null;
            video.oncanplay = null;
            video.oncanplaythrough = null;

            // Remove any stale event listeners by cloning the element
            const oldVideo = video;
            const newVideo = oldVideo.cloneNode(true);
            oldVideo.parentNode.replaceChild(newVideo, oldVideo);

            // Update reference
            const freshVideo = document.getElementById('cutscene-video');
            freshVideo.style.transform = 'translateZ(0)';
            freshVideo.style.opacity = '1';
            if (isTenMillionPlus) {
                freshVideo.style.filter = `saturate(2) brightness(1.1) drop-shadow(0 0 20px ${auraColor})`;
            }

            // PRELOAD entire video as blob to prevent buffering stutters
            fetch('cutscenes/1MSTAR.mp4')
                .then(response => response.blob())
                .then(blob => {
                    const blobUrl = URL.createObjectURL(blob);
                    freshVideo.src = blobUrl;

                    // Clean up blob URL when video ends
                    freshVideo.addEventListener('ended', () => {
                        URL.revokeObjectURL(blobUrl);
                    }, { once: true });

                    freshVideo.load();

                    // Wait for video to be ready before playing
                    freshVideo.addEventListener('canplay', () => {
                        freshVideo.play().catch(err => {
                            console.error('1M Star video playback failed:', err);
                            overlay.style.display = 'none';
                            colorOverlay.style.opacity = '0';
                            wrappedCallback();
                        });
                    }, { once: true });
                })
                .catch(err => {
                    console.error('Failed to preload 1M Star video:', err);
                    // Fallback to direct load
                    freshVideo.src = 'cutscenes/1MSTAR.mp4';
                    freshVideo.load();
                    freshVideo.addEventListener('canplay', () => {
                        freshVideo.play().catch(err => {
                            console.error('1M Star video playback failed:', err);
                            overlay.style.display = 'none';
                            colorOverlay.style.opacity = '0';
                            wrappedCallback();
                        });
                    }, { once: true });
                });

            // When video ends, chain to appropriate flash
            const handleVideoEnd = () => {
                console.log('1M Star video ended, chaining to flash. effectiveChance:', effectiveChance);
                overlay.style.display = 'none';
                colorOverlay.style.opacity = '0';
                freshVideo.style.filter = ''; // Reset filters

                const textureLayer = document.getElementById('video-texture-overlay');
                if (textureLayer) textureLayer.style.display = 'none';

                // Chain to pink flash (1M-10M) or blue flash (10M-100M)
                if (effectiveChance >= 1000000 && effectiveChance < 10000000) {
                    // Pink flash for 1M-9.9M
                    console.log('Playing Mythic Flash');
                    playMythicFlash(aura, wrappedCallback);
                } else if (effectiveChance >= 10000000 && effectiveChance < 100000000) {
                    // Blue flash for 10M-99M
                    console.log('Playing Exalted Flash');
                    playExaltedFlash(aura, wrappedCallback);
                } else {
                    console.log('No flash needed for this rarity');
                    wrappedCallback();
                }
            };

            // Use addEventListener for more reliable event handling
            freshVideo.addEventListener('ended', handleVideoEnd, { once: true });
        }

        // Stronger blue flash cutscene for Exalted tier (10M-100M rarity)
        function playExaltedFlash(aura, callback) {
            const flashOverlay = document.createElement('div');
            flashOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: radial-gradient(circle, #00d4ff 0%, #0066ff 50%, #001a66 100%);
                opacity: 0;
                z-index: 10000;
                pointer-events: none;
                transition: opacity 0.1s ease-in;
            `;
            document.body.appendChild(flashOverlay);

            // Play sound
            const sound = new Audio('cutscenes/EXALTED.ogg');
            sound.volume = (userSettings.audio.sfx / 100) || 0.8;
            sound.play().catch(() => { }); // Ignore autoplay errors

            // Flash in (faster, more impactful)
            requestAnimationFrame(() => {
                flashOverlay.style.opacity = '1';
            });

            // Hold for 0.5s (longer than mythic), then fade out over 0.7s
            setTimeout(() => {
                flashOverlay.style.transition = 'opacity 0.7s ease-out';
                flashOverlay.style.opacity = '0';

                // Cleanup and callback
                setTimeout(() => {
                    flashOverlay.remove();
                    if (callback) callback();
                }, 700);
            }, 500);
        }

        // Decide if cutscene should play:
        // - Honors debug "Only Potion Auras"
        // - Honors rarity skip threshold as global gate
        // - "Play New Aura Cutscene" still applies, except high-rarity rolls that pass the threshold
        function shouldShowCutscene(auraOrId) {
            const aura = (typeof auraOrId === 'object' && auraOrId)
                ? auraOrId
                : AURAS.find(a => a.id === auraOrId);
            const auraId = aura?.id || auraOrId;
            const potionCutsceneAura = (typeof isPotionCutsceneAura === 'function')
                ? isPotionCutsceneAura(auraId)
                : (typeof isSpecialPotionAura === 'function' ? isSpecialPotionAura(auraId) : false);

            // Global rarity gate for cutscenes (applies to quick roll and normal roll).
            const effectiveChance = aura ? getAuraEffectiveChance(aura) : 0;
            const passesRarityGate =
                !userSettings.rolling.skipCutsceneEnabled ||
                effectiveChance >= userSettings.rolling.skipCutsceneRarity;
            if (!passesRarityGate) return false;

            // If "Only Potion Auras" setting is enabled, only show cutscenes for potion-linked auras.
            if (userSettings.debug?.onlyPotionAuraCutscenes) {
                return potionCutsceneAura;
            }

            // "Play New Aura Cutscene" means repeats are hidden by default.
            // Exception: high-rarity rolls that pass the cutscene rarity gate should still play.
            if (userSettings.rolling.playNewAuraCutscene) {
                const alreadyRolled = !!(playerStats.collectedAuras && playerStats.collectedAuras[auraId]);
                const keepRepeatBecauseHighRarity = userSettings.rolling.skipCutsceneEnabled &&
                    effectiveChance >= userSettings.rolling.skipCutsceneRarity;
                if (alreadyRolled && !potionCutsceneAura && !keepRepeatBecauseHighRarity) return false;
            }

            return true;
        }

        function getAuraEffectiveChance(aura) {
            if (!aura) return 0;
            const isNative = isAuraNative(aura) && aura.nativeChance;
            return isNative ? aura.nativeChance : (aura.chance || 0);
        }

        function tryAutoEquipAura(aura, source = 'Auto Equip') {
            if (!aura) return false;
            const newChance = getAuraEffectiveChance(aura);
            const currentChance = getAuraEffectiveChance(currentEquippedAura);

            if (userSettings.rolling.swapWarnEnabled && currentEquippedAura && currentChance >= userSettings.rolling.swapWarnRarity) {
                showNotification(`${source} blocked by Swap Warning (${currentEquippedAura.name})`, '#ff7675');
                return false;
            }

            currentEquippedAura = aura;
            updateEquippedDisplay();
            return true;
        }

        // Check if aura should have exalted flash (10M to 100M-1 rarity)
        // Uses effective chance (native if applicable)
        function shouldPlayExaltedFlash(aura) {
            // Get the actual rolled rarity (native if applicable)
            const isNative = isAuraNative(aura) && aura.nativeChance;
            const effectiveChance = isNative ? aura.nativeChance : (aura.chance || 1);
            return effectiveChance >= 10000000 && effectiveChance < 100000000 && !hasVideoCutscene(aura.id) && !hasTextCutscene(aura.id);
        }

        // Check if aura should get the deep-fried flashbang (Glorious+ tier, 100M+)
        // Now triggers for ALL 100M+ auras without specific video/text cutscenes (not just global)
        function shouldPlayGlobalFlash(aura) {
            // Skip if aura has a specific video OR text cutscene
            if (hasVideoCutscene(aura.id) || hasTextCutscene(aura.id)) return false;
            // Only trigger for Glorious tier and above (100M+ rarity)
            const effectiveChance = aura.chance || 1;
            return effectiveChance >= 99999998; // 100M+
        }

        // Check if aura should get the standalone 1 Billion transcend cutscene
        function shouldPlay1BillionTranscend(aura) {
            // Used when aura has no dedicated video/text handler.
            const effectiveChance = aura.chance || 1;
            return effectiveChance >= 999999998; // 1B+
        }

        // Deep-fried flashbang for Glorious+ global auras (same effect as video cutscene ending)
        let is1BEffectPlaying = false; // Guard against overlapping 1B effects
        let isGloriousEffectPlaying = false; // Guard against overlapping 100M effects

        // Initialize flashbang keyframes on page load to prevent animation glitches
        (function initFlashbangKeyframes() {
            if (document.getElementById('flashbang-keyframes')) return;

            const style = document.createElement('style');
            style.id = 'flashbang-keyframes';
            style.textContent = `
                @keyframes reality-shatter {
                    0% { opacity: 0; filter: blur(0px); }
                    10% { opacity: 0.3; filter: blur(5px) hue-rotate(0deg); }
                    25% { opacity: 0.7; filter: blur(10px) hue-rotate(90deg); }
                    40% { opacity: 1; filter: blur(15px) hue-rotate(180deg); }
                    60% { opacity: 1; filter: blur(20px) hue-rotate(270deg); }
                    75% { opacity: 0.9; filter: blur(10px) hue-rotate(360deg); }
                    100% { opacity: 1; filter: blur(0px) hue-rotate(0deg); }
                }
                @keyframes body-distort {
                    0%, 100% { transform: scale(1) rotate(0deg); }
                    25% { transform: scale(1.03) rotate(-1deg); }
                    50% { transform: scale(1.06) rotate(1deg); }
                    75% { transform: scale(1.03) rotate(-0.5deg); }
                }
                @keyframes explosion-shake {
                    0%, 100% { transform: translate(0, 0) scale(1.05) rotate(0.5deg); }
                    10% { transform: translate(-20px, 15px) scale(1.1) rotate(-2deg); }
                    20% { transform: translate(20px, -15px) scale(1.08) rotate(2deg); }
                    30% { transform: translate(-15px, -20px) scale(1.12) rotate(-1deg); }
                    40% { transform: translate(15px, 20px) scale(1.06) rotate(1deg); }
                    50% { transform: translate(-10px, 10px) scale(1.1) rotate(-0.5deg); }
                    60% { transform: translate(10px, -10px) scale(1.07) rotate(0.5deg); }
                    70% { transform: translate(-5px, -5px) scale(1.05) rotate(0deg); }
                    80% { transform: translate(5px, 5px) scale(1.03) rotate(0deg); }
                    90% { transform: translate(-2px, 2px) scale(1.02) rotate(0deg); }
                }
                @keyframes transcendent-prism {
                    0% { opacity: 0; transform: scale(1) rotate(0deg); filter: blur(0px) hue-rotate(0deg); }
                    20% { opacity: 0.45; transform: scale(1.04) rotate(14deg); filter: blur(2px) hue-rotate(60deg); }
                    50% { opacity: 0.8; transform: scale(1.1) rotate(36deg); filter: blur(6px) hue-rotate(150deg); }
                    80% { opacity: 0.65; transform: scale(1.16) rotate(64deg); filter: blur(3px) hue-rotate(250deg); }
                    100% { opacity: 0.8; transform: scale(1.2) rotate(84deg); filter: blur(1px) hue-rotate(360deg); }
                }
                @keyframes transcendent-rift {
                    0% { background-position: 0 0, 0 0; opacity: 0.12; }
                    50% { background-position: 220px -120px, -180px 90px; opacity: 0.42; }
                    100% { background-position: 440px -240px, -360px 180px; opacity: 0.12; }
                }
            `;
            document.head.appendChild(style);
        })();

        // Clean up any existing flashbang effects
        function cleanupFlashbangEffects() {
            document.querySelectorAll('[data-flashbang-effect]').forEach(el => el.remove());
            document.body.style.filter = '';
            document.body.style.transform = '';
            document.body.style.animation = '';
            document.body.style.transition = '';
            is1BEffectPlaying = false;
            isGloriousEffectPlaying = false;
        }

        function createTranscendentAtmosphereLayers(markerAttribute) {
            const prismLayer = document.createElement('div');
            if (markerAttribute) prismLayer.setAttribute(markerAttribute, 'true');
            prismLayer.style.cssText = `
                position: fixed;
                top: -10%;
                left: -10%;
                width: 120%;
                height: 120%;
                background:
                    radial-gradient(circle at 20% 30%, rgba(124, 255, 255, 0.4) 0%, transparent 45%),
                    radial-gradient(circle at 80% 20%, rgba(255, 120, 255, 0.35) 0%, transparent 50%),
                    radial-gradient(circle at 50% 80%, rgba(255, 193, 94, 0.3) 0%, transparent 55%),
                    conic-gradient(from 0deg at 50% 50%, rgba(255,255,255,0.35), rgba(0,255,255,0.2), rgba(255,0,255,0.25), rgba(255,255,120,0.2), rgba(255,255,255,0.35));
                opacity: 0;
                z-index: 10000;
                pointer-events: none;
                mix-blend-mode: screen;
                animation: transcendent-prism 8s linear infinite;
            `;
            document.body.appendChild(prismLayer);

            const riftLayer = document.createElement('div');
            if (markerAttribute) riftLayer.setAttribute(markerAttribute, 'true');
            riftLayer.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background:
                    repeating-linear-gradient(115deg, rgba(255,255,255,0.0) 0 14px, rgba(255,255,255,0.14) 14px 17px, rgba(255,255,255,0.0) 17px 34px),
                    repeating-linear-gradient(25deg, rgba(0,255,255,0.0) 0 18px, rgba(0,255,255,0.1) 18px 22px, rgba(255,0,255,0.0) 22px 40px);
                opacity: 0;
                z-index: 10000;
                pointer-events: none;
                mix-blend-mode: color-dodge;
                filter: blur(1.5px);
                animation: transcendent-rift 4.5s linear infinite;
            `;
            document.body.appendChild(riftLayer);

            return { prismLayer, riftLayer };
        }

        function playGlobalFlash(aura, callback) {
            // Hide the roll overlay during flash
            const rollOverlay = document.getElementById('roll-overlay');
            if (rollOverlay) rollOverlay.style.visibility = 'hidden';

            // Wrap callback to restore roll overlay visibility
            const wrappedCallback = () => {
                if (rollOverlay) rollOverlay.style.visibility = 'visible';
                if (callback) callback();
            };

            // Check if this is a 1B+ aura for enhanced effect
            const is1BillionPlus = (aura.chance || 1) >= 999999998;

            if (is1BillionPlus) {
                // Prevent overlapping effects - clean up any existing ones
                if (is1BEffectPlaying || isGloriousEffectPlaying) {
                    cleanupFlashbangEffects();
                }
                is1BEffectPlaying = true;

                // Use preloaded 1 billion transcend audio
                const audioSrc = 'cutscenes/1bil_trancend.mp3.mpeg';
                let transcendAudio = preloadedAudios.get(audioSrc);
                if (transcendAudio) {
                    transcendAudio = transcendAudio.cloneNode();
                } else {
                    transcendAudio = new Audio(audioSrc);
                }
                transcendAudio.volume = (userSettings.audio.sfx / 100) * 0.7 || 0.7;
                transcendAudio.play().catch(console.error);

                // Apply EXTREME Deep Fried Effect
                const body = document.body;
                body.style.transition = 'filter 0.05s ease-out, transform 0.05s ease-out';
                body.style.filter = 'grayscale(35%) contrast(920%) brightness(165%) saturate(620%) hue-rotate(170deg) drop-shadow(0 0 30px rgba(255,0,255,0.85))';
                body.style.transform = 'scale(1.055) rotate(0.6deg)';
                body.style.animation = 'body-distort 2s ease-in-out infinite';

                const { prismLayer, riftLayer } = createTranscendentAtmosphereLayers('data-flashbang-effect');
                prismLayer.style.transition = 'opacity 4s ease-in';
                prismLayer.style.opacity = '0.9';
                riftLayer.style.transition = 'opacity 4s ease-in';
                riftLayer.style.opacity = '0.55';

                // Create chromatic flash overlay
                const flashEl = document.createElement('div');
                flashEl.setAttribute('data-flashbang-effect', 'true');
                flashEl.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: radial-gradient(circle at 50% 45%, rgba(255,255,255,0.98) 0%, rgba(194,132,255,0.78) 24%, rgba(84,255,255,0.58) 48%, rgba(255,170,70,0.45) 72%, rgba(5,0,20,0.92) 100%);
                    opacity: 0;
                    z-index: 10000;
                    pointer-events: none;
                    mix-blend-mode: screen;
                    animation: reality-shatter 8s ease-in-out;
                `;
                document.body.appendChild(flashEl);

                flashEl.offsetHeight;
                flashEl.style.transition = 'opacity 4s ease-in';
                flashEl.style.opacity = '1';

                // HUGE EXPLOSION at 5 seconds
                setTimeout(() => {
                    // Create explosion flash
                    const explosionFlash = document.createElement('div');
                    explosionFlash.setAttribute('data-flashbang-effect', 'true');
                    explosionFlash.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: radial-gradient(circle, #ffffff 0%, #ffff00 20%, #ff6600 40%, #ff0000 60%, transparent 80%);
                        opacity: 0;
                        z-index: 10001;
                        pointer-events: none;
                        mix-blend-mode: screen;
                    `;
                    document.body.appendChild(explosionFlash);

                    // Intense screen shake
                    body.style.animation = 'explosion-shake 0.5s ease-out';

                    // Flash in explosion
                    explosionFlash.offsetHeight;
                    explosionFlash.style.transition = 'opacity 0.1s ease-out';
                    explosionFlash.style.opacity = '1';

                    // Intensify body filter momentarily
                    body.style.filter = 'grayscale(0%) contrast(1000%) brightness(200%) saturate(800%) hue-rotate(0deg) drop-shadow(0 0 50px rgba(255,255,0,1))';

                    // After explosion flash, begin slow fade out
                    setTimeout(() => {
                        // Slow fade out everything
                        explosionFlash.style.transition = 'opacity 3s ease-out';
                        explosionFlash.style.opacity = '0';

                        flashEl.style.transition = 'opacity 3s ease-out';
                        flashEl.style.opacity = '0';
                        flashEl.style.animation = '';
                        prismLayer.style.transition = 'opacity 3s ease-out';
                        prismLayer.style.opacity = '0';
                        riftLayer.style.transition = 'opacity 3s ease-out';
                        riftLayer.style.opacity = '0';

                        body.style.animation = '';
                        body.style.transition = 'filter 3s ease-out, transform 3s ease-out';
                        body.style.filter = '';
                        body.style.transform = '';

                        // Cleanup after slow fade
                        setTimeout(() => {
                            explosionFlash.remove();
                            flashEl.remove();
                            prismLayer.remove();
                            riftLayer.remove();
                            body.style.transition = '';
                            is1BEffectPlaying = false; // Reset flag

                            wrappedCallback();
                        }, 3000);
                    }, 500); // Hold explosion for 0.5s then slow fade
                }, 5000);
            } else {
                // Standard 100M+ deep fried effect
                // Prevent overlapping effects
                if (isGloriousEffectPlaying || is1BEffectPlaying) {
                    cleanupFlashbangEffects();
                }
                isGloriousEffectPlaying = true;

                // Use preloaded audio if available
                const audioSrc = 'cutscenes/100maura.ogg';
                try {
                    let audio = preloadedAudios.get(audioSrc);
                    if (audio) {
                        audio = audio.cloneNode();
                    } else {
                        audio = new Audio(audioSrc);
                    }
                    audio.volume = (userSettings.audio.sfx / 100) * 0.6 || 0.6;
                    audio.play().catch(console.error);
                } catch (e) { console.error("Audio error", e); }

                const body = document.body;
                body.style.transition = 'filter 0.1s ease-out, transform 0.1s ease-out';
                body.style.filter = 'grayscale(100%) contrast(500%) brightness(120%) drop-shadow(0 0 10px rgba(0,0,0,0.5))';
                body.style.transform = 'scale(1.02)';

                const flashEl = document.createElement('div');
                flashEl.setAttribute('data-flashbang-effect', 'true');
                flashEl.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: #fff;
                    opacity: 0;
                    z-index: 10000;
                    pointer-events: none;
                `;
                document.body.appendChild(flashEl);

                flashEl.style.transition = 'opacity 2.5s ease-in';
                requestAnimationFrame(() => {
                    flashEl.style.opacity = '1';
                });

                setTimeout(() => {
                    body.style.transition = 'filter 0.5s ease-out, transform 0.5s ease-out';
                    body.style.filter = '';
                    body.style.transform = '';

                    flashEl.style.transition = 'opacity 2s ease-out';
                    flashEl.style.opacity = '0';

                    setTimeout(() => {
                        flashEl.remove();
                        body.style.transition = '';
                        isGloriousEffectPlaying = false;
                        wrappedCallback();
                    }, 2000);

                }, 3500);
            }
        }

        // Ultra-enhanced transcend cutscene for 1 Billion+ auras
        function play1BillionTranscend(aura, callback) {
            // Play the transcend audio
            const transcendAudio = new Howl({
                src: ['cutscenes/1bil_trancend.mp3.mpeg'],
                volume: (userSettings.audio.sfx / 100) * 0.7 || 0.7,
                onload: function () {
                    transcendAudio.play();
                }
            });

            // Apply EXTREME Deep Fried Effect to the BODY
            const body = document.body;
            body.style.transition = 'filter 0.05s ease-out, transform 0.05s ease-out';
            body.style.filter = 'grayscale(35%) contrast(920%) brightness(165%) saturate(620%) hue-rotate(170deg) drop-shadow(0 0 30px rgba(255,0,255,0.85))';
            body.style.transform = 'scale(1.055) rotate(0.6deg)';

            const { prismLayer, riftLayer } = createTranscendentAtmosphereLayers('data-flashbang-effect');
            prismLayer.style.transition = 'opacity 4s ease-in';
            prismLayer.style.opacity = '0.9';
            riftLayer.style.transition = 'opacity 4s ease-in';
            riftLayer.style.opacity = '0.55';

            // Create multi-layered flash overlay
            const flashEl = document.createElement('div');
            flashEl.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: radial-gradient(circle at 50% 45%, rgba(255,255,255,0.98) 0%, rgba(194,132,255,0.78) 24%, rgba(84,255,255,0.58) 48%, rgba(255,170,70,0.45) 72%, rgba(5,0,20,0.92) 100%);
                opacity: 0;
                z-index: 10000;
                pointer-events: none;
                mix-blend-mode: screen;
                animation: reality-shatter 8s ease-in-out;
            `;
            flashEl.setAttribute('data-flashbang-effect', 'true');
            document.body.appendChild(flashEl);

            // Add reality shatter keyframes if not exists
            if (!document.getElementById('reality-shatter-keyframes')) {
                const style = document.createElement('style');
                style.id = 'reality-shatter-keyframes';
                style.textContent = `
                    @keyframes reality-shatter {
                        0% { opacity: 0; filter: blur(0px); }
                        10% { opacity: 0.3; filter: blur(5px) hue-rotate(0deg); }
                        25% { opacity: 0.7; filter: blur(10px) hue-rotate(90deg); }
                        40% { opacity: 1; filter: blur(15px) hue-rotate(180deg); }
                        60% { opacity: 1; filter: blur(20px) hue-rotate(270deg); }
                        75% { opacity: 0.9; filter: blur(10px) hue-rotate(360deg); }
                        100% { opacity: 1; filter: blur(0px) hue-rotate(0deg); }
                    }
                    @keyframes body-distort {
                        0%, 100% { transform: scale(1) rotate(0deg); }
                        25% { transform: scale(1.03) rotate(-1deg); }
                        50% { transform: scale(1.06) rotate(1deg); }
                        75% { transform: scale(1.03) rotate(-0.5deg); }
                    }
                `;
                document.head.appendChild(style);
            }

            // Apply body distortion animation
            body.style.animation = 'body-distort 2s ease-in-out infinite';

            // Slow fade to chromatic white
            flashEl.offsetHeight; // Trigger reflow
            flashEl.style.transition = 'opacity 4s ease-in';
            requestAnimationFrame(() => {
                flashEl.style.opacity = '1';
            });

            // After fade completes, hold and then fade out
            setTimeout(() => {
                // Reset body filters and animations
                body.style.animation = '';
                body.style.transition = 'filter 1s ease-out, transform 1s ease-out';
                body.style.filter = '';
                body.style.transform = '';

                // Fade the overlay out over 3 seconds
                flashEl.style.transition = 'opacity 3s ease-out';
                flashEl.style.opacity = '0';
                prismLayer.style.transition = 'opacity 3s ease-out';
                prismLayer.style.opacity = '0';
                riftLayer.style.transition = 'opacity 3s ease-out';
                riftLayer.style.opacity = '0';

                // Cleanup after fade out
                setTimeout(() => {
                    flashEl.remove();
                    prismLayer.remove();
                    riftLayer.remove();
                    transcendAudio.fade(transcendAudio.volume(), 0, 1000);
                    setTimeout(() => {
                        transcendAudio.stop();
                        transcendAudio.unload();
                    }, 1000);
                    if (callback) callback();
                }, 3000);

            }, 8000); // 4s fade in + 4s hold
        }


        function performRoll() {
            if (isRolling || isOnCooldown) return;
            const storageFullPopup = document.getElementById('storage-full-popup');
            if (storageFullPopup?.classList.contains('active')) {
                showNotification('Resolve Aura Storage prompt first.', '#ffcc66');
                return;
            }

            const threshold = getBonusRollThreshold();
            let isBonusRoll = (rollCounter === threshold);
            const hasDarkshader = isDarkshaderEquipped();

            // Bonus-roll removal gears disable bonus roll state directly.
            if (hasRemoveBonusRollGear()) isBonusRoll = false;

            // --- GEAR COUNTERS & PROCS ---
            playerStats.gemstoneRollCounter = (playerStats.gemstoneRollCounter || 0) + 1;
            playerStats.presentRollCounter = (playerStats.presentRollCounter || 0) + 1;
            playerStats.xmasRollCounter = (playerStats.xmasRollCounter || 0) + 1;
            playerStats.poleRollCounter = (playerStats.poleRollCounter || 0) + 1;

            // Fatebreaker Device: charge every 100 rolls, consume on next roll
            if (isFatebreakerDeviceEquipped() && !fatebreakerCharged) {
                fatebreakerRollTracker++;
                if (fatebreakerRollTracker >= 100) {
                    fatebreakerRollTracker = 0;
                    fatebreakerCharged = true;
                    showNotification('SINGULARITY READY! Next roll samples 3 outcomes.', '#ff9f43');
                    updateRollCount();
                }
            }

            // Gemstone Proc (Every 10)
            if (playerInventory.equipped.left === 'gemstone-gauntlet' && playerStats.gemstoneRollCounter % 10 === 0) {
                const id = 'gemstone_' + Date.now();
                if (Math.random() < 0.5) {
                    activeBuffs[id] = { name: 'Gemstone Luck', type: 'roll_duration', duration: 10, stats: { luckMultiplier: 1.3 }, sourceId: 'gemstone' };
                    showNotification('Gemstone: +30% Luck!', '#9b59b6');
                } else {
                    activeBuffs[id] = { name: 'Gemstone Speed', type: 'roll_duration', duration: 10, stats: { rollSpeed: 0.3 }, sourceId: 'gemstone' };
                    showNotification('Gemstone: +30% Speed!', '#3498db');
                }
                if (typeof updateBuffsHUD === 'function') updateBuffsHUD();
            }

            // Pole Light Core (Every 30)
            if (playerInventory.equipped.left === 'pole-light-core' && playerStats.poleRollCounter % 30 === 0) {
                const id = 'pole_warp_' + Date.now();
                activeBuffs[id] = {
                    name: 'Sky-Warp',
                    type: 'roll_duration',
                    duration: 5,
                    stats: { rollSpeed: 999.0 },
                    sourceId: 'pole-light-core'
                };
                showNotification('Pole Light Core: 5 Sky-Warp Rolls!', '#00fffa');
                if (typeof updateBuffsHUD === 'function') updateBuffsHUD();
            }

            // Omega Drive OVERDRIVE Phase Logic (Every 25 rolls, 8 rolls of x2 Luck + 50% Speed)
            if (isOmegaDriveEquipped()) {
                if (omegaBuffActive && omegaBuffRollsRemaining > 0) {
                    omegaBuffRollsRemaining--;
                    if (omegaBuffRollsRemaining <= 0) {
                        omegaBuffActive = false;
                        showNotification('Overdrive phase ended!', '#ff6b35');
                        if (typeof updateOmegaVignette === 'function') updateOmegaVignette(false);
                    }
                } else {
                    omegaRollTracker++;
                    if (omegaRollTracker >= 25) {
                        omegaRollTracker = 0;
                        omegaBuffActive = true;
                        omegaBuffRollsRemaining = 8;
                        showNotification('OVERDRIVE! x2 Luck + 50% Speed for 8 rolls!', '#ff4500');
                        if (typeof updateOmegaVignette === 'function') updateOmegaVignette(true);
                    }
                }
            }

            // Calculate luck multiplier
            let luck = 1;

            const hasFlesh = (playerInventory.equipped.left === 'flesh-device');
            if (hasFlesh) {
                luck = 1.3;
                playerStats.bonusRollsHit++;
            } else if (hasDarkshader) {
                // Darkshader bonus roll logic
                if (isBonusRoll) {
                    playerStats.bonusRollsHit++;
                    if (darkshaderBuffActive && darkshaderBuffRollsRemaining > 0) {
                        luck = 5;
                    } else {
                        luck = 2.5;
                    }
                } else if (darkshaderBuffActive && darkshaderBuffRollsRemaining > 0) {
                    luck = 2.5;
                }

                // Darkshader Phase Logic
                if (darkshaderBuffActive && darkshaderBuffRollsRemaining > 0) {
                    darkshaderBuffRollsRemaining--;
                    if (darkshaderBuffRollsRemaining <= 0) {
                        darkshaderBuffActive = false;
                        showNotification('Encroached phase ended!', '#9b59b6');
                        if (typeof updateDarkshaderVignette === 'function') updateDarkshaderVignette(false);
                    }
                } else {
                    darkshaderRollTracker++;
                    if (darkshaderRollTracker >= 20) {
                        darkshaderRollTracker = 0;
                        darkshaderBuffActive = true;
                        darkshaderBuffRollsRemaining = 10;
                        showNotification('ENCROACHED! x2.5 Luck for 10 rolls!', '#e056fd');
                        if (typeof updateDarkshaderVignette === 'function') updateDarkshaderVignette(true);
                    }
                }
            } else if (getCasterProfile()) {
                // Lightcaster/Chromatic Crusher bonus roll logic
                const casterProfile = getCasterProfile();
                if (isBonusRoll) {
                    playerStats.bonusRollsHit++;
                    if (lightcasterBuffActive && lightcasterBuffRollsRemaining > 0) {
                        luck = casterProfile.phaseBonusLuck; // boosted bonus luck during active phase
                    } else {
                        luck = casterProfile.normalBonusLuck;
                    }
                } else if (lightcasterBuffActive && lightcasterBuffRollsRemaining > 0) {
                    luck = casterProfile.phaseLuck;
                } else {
                    luck = casterProfile.normalBonusLuck; // keeps caster gloves strong even outside bonus rolls
                }

                // Caster phase logic
                if (lightcasterBuffActive && lightcasterBuffRollsRemaining > 0) {
                    lightcasterBuffRollsRemaining--;
                    if (lightcasterBuffRollsRemaining <= 0) {
                        lightcasterBuffActive = false;
                        if (casterProfile.mode === 'crusher') {
                            showNotification('Prismatic phase ended!', '#ff66cc');
                        } else {
                            showNotification('Radiant phase ended!', '#f1c40f');
                        }
                        if (typeof updateLightcasterVignette === 'function') updateLightcasterVignette(false);
                    }
                } else {
                    lightcasterRollTracker++;
                    if (lightcasterRollTracker >= casterProfile.phaseTriggerRolls) {
                        lightcasterRollTracker = 0;
                        lightcasterBuffActive = true;
                        lightcasterBuffRollsRemaining = casterProfile.phaseDurationRolls;
                        if (casterProfile.mode === 'crusher') {
                            showNotification('PRISMATIC! x6 Luck + 25% Speed for 12 rolls!', '#ff66cc');
                        } else {
                            showNotification('RADIANT! x4 Luck + 15% Speed for 10 rolls!', '#ffd700');
                        }
                        if (typeof updateLightcasterVignette === 'function') updateLightcasterVignette(true);
                    }
                }
            } else {
                // Normal (non-Darkshader/Lightcaster) bonus roll logic
                if (isBonusRoll) {
                    playerStats.bonusRollsHit++;

                    if (playerInventory.equipped.left === 'gravitational-device') {
                        luck = 6;
                    } else if (playerInventory.equipped.left === 'blessed-tide-gauntlet') {
                        luck = 3;
                    } else {
                        luck = 2;
                    }
                }
            }

            // Present Giver / X-Mas Champion Pulse
            if (playerInventory.equipped.left === 'present-giver' && playerStats.presentRollCounter % 11 === 0) {
                luck *= 5;
                showNotification('Present Giver: x5 Luck!', '#ff6b6b');
            }
            if (playerInventory.equipped.left === 'xmas-champion' && playerStats.xmasRollCounter % 6 === 0) {
                luck *= 4;
                showNotification('X-Mas Champion: x4 Luck!', '#2ecc71');
            }

            // Paradox Gauntlet pulse (every 12th roll)
            if (isParadoxGauntletEquipped() && ((playerStats.totalRolls + 1) % 12 === 0)) {
                luck *= 4;
                showNotification('PARADOX PULSE! x4 Luck!', '#5dade2');
            }

            // Omega Drive OVERDRIVE x2 Luck Multiplier
            if (isOmegaDriveEquipped() && omegaBuffActive && omegaBuffRollsRemaining > 0) {
                luck *= 2;
            }

            // Cataclysm Device x3 Luck multiplier during phase
            if (isCataclysmDeviceEquipped() && cataclysmBuffActive && cataclysmBuffRollsRemaining > 0) {
                luck *= 3;
            }

            // Store the bonus multiplier for stats display
            currentBonusRollMultiplier = luck;
            updateStatsPanel(); // Update to show bonus roll multiplier

            // Handle Tide Gauntlet allowRainy flag
            const allowRainy = (isBonusRoll && (playerInventory.equipped.left === 'tide-gauntlet' || playerInventory.equipped.left === 'blessed-tide-gauntlet'));


            // --- CONSUME ONE-TIME BUFFS ---
            // Consume only ONE queued one-time buff per roll.
            // This allows multi-use queueing without stacking buff strength.
            let aggregatedOneTimeStats = null;
            if (userSettings.rolling.buffsEnabled && oneTimeBuffs.length > 0) {
                aggregatedOneTimeStats = normalizeOneTimeStats(oneTimeBuffs.shift());
                updateBuffsHUD();
            }

            // Decrement Roll-Based Duration Buffs (Warp Potions)
            if (userSettings.rolling.buffsEnabled) {
                Object.keys(activeBuffs).forEach(key => {
                    const buff = activeBuffs[key];
                    if (buff.type === 'roll_duration') {
                        buff.duration--;
                        if (buff.duration <= 0) {
                            delete activeBuffs[key];
                            showNotification(`${buff.name} worn off.`, '#95a5a6');
                            updateBuffsHUD();
                        }
                    }
                });
            }

            if (rollCounter >= threshold) {
                rollCounter = 1;
            } else {
                rollCounter++;
            }
            updateRollCount();
            checkAchievements(); // Check for roll achievements

            const overlay = document.getElementById('roll-overlay');
            const rollBtn = document.getElementById('roll-button');

            if (quickRollMode) {
                const finalAura = rollAuraWithFatebreaker(luck, aggregatedOneTimeStats, allowRainy); // Pass aggregated stats

                // Check if this aura has a video cutscene - Override Quick Roll
                // Also respects "Only Potion Auras" cutscene setting
                if (hasVideoCutscene(finalAura.id) && shouldShowCutscene(finalAura)) {
                    // Stop quick roll flow and play cutscene
                    isRolling = true;
                    rollBtn.classList.add('disabled');

                    const completeRoll = () => {
                        updateDisplay(finalAura, true);
                        addMaterial(finalAura.name);
                        if (Math.random() < 0.1) addMaterial('Gear Basing');
                        if (Math.random() < 0.2) addPotion('lucky_potion', 1);
                        if (Math.random() < 0.1) addPotion('speed_potion', 1);
                        recordRoll(finalAura, aggregatedOneTimeStats);
                        isRolling = false;
                        rollBtn.classList.remove('disabled');
                        startCooldown(1500);
                    };

                    playVideoCutscene(finalAura, completeRoll);
                    return;
                }

                // Check if this aura has a text cutscene - Override Quick Roll
                if (hasTextCutscene(finalAura.id) && shouldShowCutscene(finalAura)) {
                    isRolling = true;
                    rollBtn.classList.add('disabled');

                    const completeRoll = () => {
                        updateDisplay(finalAura, true);
                        addMaterial(finalAura.name);
                        if (Math.random() < 0.1) addMaterial('Gear Basing');
                        if (Math.random() < 0.2) addPotion('lucky_potion', 1);
                        if (Math.random() < 0.1) addPotion('speed_potion', 1);
                        recordRoll(finalAura, aggregatedOneTimeStats);
                        isRolling = false;
                        rollBtn.classList.remove('disabled');
                        startCooldown(2000); // Longer cooldown for text cutscenes
                    };

                    playTextCutscene(finalAura, completeRoll);
                    return;
                }

                // Check if aura should play the 1M star video (1M-100M rarity without specific video)
                if (shouldPlay1MStarVideo(finalAura) && shouldShowCutscene(finalAura)) {
                    isRolling = true;
                    rollBtn.classList.add('disabled');

                    const completeRoll = () => {
                        updateDisplay(finalAura, true);
                        addMaterial(finalAura.name);
                        if (Math.random() < 0.1) addMaterial('Gear Basing');
                        if (Math.random() < 0.2) addPotion('lucky_potion', 1);
                        if (Math.random() < 0.1) addPotion('speed_potion', 1);
                        recordRoll(finalAura, aggregatedOneTimeStats);
                        isRolling = false;
                        rollBtn.classList.remove('disabled');
                        startCooldown(1500);
                    };

                    play1MStarVideo(finalAura, completeRoll);
                    return;
                }

                // Check for global Glorious+ flash (100M+ global auras without video cutscenes)
                if (shouldPlayGlobalFlash(finalAura) && shouldShowCutscene(finalAura)) {
                    isRolling = true;
                    rollBtn.classList.add('disabled');

                    const completeRoll = () => {
                        updateDisplay(finalAura, true);
                        addMaterial(finalAura.name);
                        if (Math.random() < 0.1) addMaterial('Gear Basing');
                        if (Math.random() < 0.2) addPotion('lucky_potion', 1);
                        if (Math.random() < 0.1) addPotion('speed_potion', 1);
                        recordRoll(finalAura, aggregatedOneTimeStats);
                        isRolling = false;
                        rollBtn.classList.remove('disabled');
                        startCooldown(1500);
                    };

                    playGlobalFlash(finalAura, completeRoll);
                    return;
                }

                // Note: Mythic (1M-10M) and Exalted (10M-100M) flashes are now handled
                // by the 1M star video chain above, which plays the video first then the flash

                // Check for legendary flash (100K-1M rarity) - Override Quick Roll
                if (shouldPlayLegendaryFlash(finalAura) && shouldShowCutscene(finalAura)) {
                    isRolling = true;
                    rollBtn.classList.add('disabled');

                    const completeRoll = () => {
                        updateDisplay(finalAura, true);
                        addMaterial(finalAura.name);
                        if (Math.random() < 0.1) addMaterial('Gear Basing');
                        if (Math.random() < 0.2) addPotion('lucky_potion', 1);
                        if (Math.random() < 0.1) addPotion('speed_potion', 1);
                        recordRoll(finalAura, aggregatedOneTimeStats);
                        isRolling = false;
                        rollBtn.classList.remove('disabled');
                        startCooldown(800);
                    };

                    playLegendaryFlash(finalAura, completeRoll);
                    return;
                }

                // Check for unique flash (10K-100K rarity) - Override Quick Roll
                if (shouldPlayUniqueFlash(finalAura) && shouldShowCutscene(finalAura)) {
                    isRolling = true;
                    rollBtn.classList.add('disabled');

                    const completeRoll = () => {
                        updateDisplay(finalAura, true);
                        addMaterial(finalAura.name);
                        if (Math.random() < 0.1) addMaterial('Gear Basing');
                        if (Math.random() < 0.2) addPotion('lucky_potion', 1);
                        if (Math.random() < 0.1) addPotion('speed_potion', 1);
                        recordRoll(finalAura, aggregatedOneTimeStats);
                        isRolling = false;
                        rollBtn.classList.remove('disabled');
                        startCooldown(500);
                    };

                    playUniqueFlash(finalAura, completeRoll);
                    return;
                }

                updateDisplay(finalAura, true);

                // Add to materials
                addMaterial(finalAura.name);
                if (Math.random() < 0.1) addMaterial('Gear Basing');

                // --- NATURAL POTION SPAWNS ---
                // Lucky Potion (1/5)
                if (Math.random() < 0.2) addPotion('lucky_potion', 1);
                // Speed Potion (1/10)
                if (Math.random() < 0.1) addPotion('speed_potion', 1);

                recordRoll(finalAura, aggregatedOneTimeStats);

                startCooldown(1000);
            } else {
                // Temp Aura
                // Pass aggregatedOneTimeStats to show potential high rolls during cutscene
                const tempFinalAura = rollAuraWithFatebreaker(luck, aggregatedOneTimeStats, allowRainy);
                const auraChance = (tempFinalAura.nativeChance && (tempFinalAura.biome === currentBiome.name || tempFinalAura.weather === currentBiome.name || tempFinalAura.time === currentTime)) ? tempFinalAura.nativeChance : tempFinalAura.chance;

                const filterStatus = userSettings.filters[tempFinalAura.id] || 'disabled';
                if (filterStatus === 'skip') {
                    addMaterial(tempFinalAura.name);
                    if (Math.random() < 0.1) addMaterial('Gear Basing');
                    recordRoll(tempFinalAura, aggregatedOneTimeStats);
                    startCooldown(150);
                    return;
                }

                isRolling = true;
                rollBtn.classList.add('disabled');
                document.body.classList.add('dimmed');
                overlay.classList.add('active', 'cycling');

                let cycleCount = 0;
                const maxCycles = 6; // Reduced from 8 for faster rolls
                let lastTime = performance.now();
                let accumulated = 0;

                function doCycle(timestamp) {
                    // const gearBonuses = calculateGearBonuses();
                    // const speedMult = 1 + gearBonuses.rollSpeed;
                    const speedMult = 1 + calculateTotalRollSpeed();

                    const isFastPhase = cycleCount < 3;
                    const baseDuration = isFastPhase ? 140 : 220; // Faster durations (was 180/320)
                    const duration = baseDuration / speedMult;

                    if (cycleCount >= maxCycles) {
                        // FINAL REVEAL (Use the result we pre-rolled)
                        const finalAura = tempFinalAura;

                        // Respect Aura Filters
                        const filterStatus = userSettings.filters[finalAura.id] || 'disabled';

                        if (filterStatus === 'skip') {
                            // Automatically skip this roll result
                            isRolling = false;
                            rollBtn.classList.remove('disabled');
                            document.body.classList.remove('dimmed');
                            overlay.classList.remove('active', 'cycling');
                            startCooldown(500);
                            return;
                        }

                        // Handle Auto-Equip/Keep Logic
                        if (filterStatus === 'keep') {
                            currentEquippedAura = finalAura;
                            updateEquippedDisplay();
                        } else if (userSettings.rolling.autoEquipEnabled) {
                            if (auraChance >= userSettings.rolling.autoEquipRarity) {
                                tryAutoEquipAura(finalAura, 'Auto Equip');
                            }
                        }

                        const nameEl = document.getElementById('overlay-name');
                        const chanceEl = document.getElementById('overlay-chance');

                        // Cancel any running animations and reset visibility
                        nameEl.getAnimations().forEach(a => a.cancel());
                        chanceEl.getAnimations().forEach(a => a.cancel());
                        nameEl.style.opacity = '1';
                        nameEl.style.transform = 'translateY(0)';
                        chanceEl.style.opacity = '1';
                        chanceEl.style.transform = 'translateY(0)';


                        updateDisplay(finalAura, true);

                        // Check if this aura has a video cutscene
                        const completeRoll = () => {
                            addMaterial(finalAura.name);
                            if (Math.random() < 0.1) addMaterial('Gear Basing');

                            // --- NATURAL POTION SPAWNS (End of Cutscene) ---
                            if (Math.random() < 0.2) addPotion('lucky_potion', 1);
                            if (Math.random() < 0.1) addPotion('speed_potion', 1);

                            recordRoll(finalAura, aggregatedOneTimeStats);

                            overlay.classList.remove('cycling');

                            // Set isRolling false immediately but start cooldown
                            isRolling = false;
                            rollBtn.classList.remove('disabled');
                            document.body.classList.remove('dimmed');

                            // Start cooldown to prevent immediate re-roll
                            startCooldown(1500);
                        };

                        if (hasVideoCutscene(finalAura.id) && shouldShowCutscene(finalAura)) {
                            // Video cutscene internally handles 1B+ transcendent ending for that aura.
                            playVideoCutscene(finalAura, completeRoll);
                        } else if (hasTextCutscene(finalAura.id) && shouldShowCutscene(finalAura)) {
                            // Text cutscene internally handles 1B+ transcendent ending for that aura.
                            playTextCutscene(finalAura, completeRoll);
                        } else if (shouldPlay1MStarVideo(finalAura) && shouldShowCutscene(finalAura)) {
                            // Play 1M star video for 1M-100M rarity auras without specific video
                            // This will chain to the appropriate flash (mythic/exalted) after the video
                            play1MStarVideo(finalAura, completeRoll);
                        } else if (shouldPlay1BillionTranscend(finalAura) && shouldShowCutscene(finalAura)) {
                            // Play ultra-enhanced transcend cutscene for 1B+ auras
                            play1BillionTranscend(finalAura, completeRoll);
                        } else if (shouldPlayGlobalFlash(finalAura) && shouldShowCutscene(finalAura)) {
                            // Play deep-fried flash for Glorious+ global auras (100M+)
                            playGlobalFlash(finalAura, completeRoll);
                        } else if (shouldPlayLegendaryFlash(finalAura) && shouldShowCutscene(finalAura)) {
                            // Play cyan flash for 100K-1M rarity
                            playLegendaryFlash(finalAura, completeRoll);
                        } else if (shouldPlayUniqueFlash(finalAura) && shouldShowCutscene(finalAura)) {
                            // Play tiny cyan flash for 10K-100K rarity
                            playUniqueFlash(finalAura, completeRoll);
                        } else {
                            // No video, complete immediately
                            completeRoll();
                        }


                        // Overlay stays visible until next roll starts
                        return;
                    }

                    // Temp Aura
                    const tempAura = rollAuraWithFatebreaker(luck, aggregatedOneTimeStats, allowRainy); // Pass one-time stats to temp logic?
                    // Actually, usually temp rolls during cutscene DON'T use the powerful consumeables visually to prevent spoilers?
                    // Or they do to generate excitement?
                    // Standard: Temp rolls usually just use basic luck.
                    // But if we pass it, we might spoil the 'Heavenly' effect early if it rolls Glitch immediately.
                    // Let's pass basic luck for animation temp rolls.
                    // updateDisplay(tempAura, false); 
                    // No, wait, if I use a Heavenly Potion, I expect to see high rarity stuff flying by?
                    // Let's pass it for consistency.
                    updateDisplay(tempAura, false);

                    const nameEl = document.getElementById('overlay-name');
                    const chanceEl = document.getElementById('overlay-chance');

                    // Check if this is the LAST cycle before final reveal
                    const isLastCycleBeforeFinal = (cycleCount === maxCycles - 1);

                    // Use Web Animations API
                    // On last cycle, don't fade out - stay visible for smooth transition to final
                    const keyframes = isLastCycleBeforeFinal ? [
                        { opacity: 0, transform: 'translateY(-25px)' },
                        { opacity: 1, transform: 'translateY(0)', offset: 0.25 },
                        { opacity: 1, transform: 'translateY(0)' }
                    ] : [
                        { opacity: 0, transform: 'translateY(-25px)' },
                        { opacity: 1, transform: 'translateY(0)', offset: 0.25 },
                        { opacity: 1, transform: 'translateY(0)', offset: 0.75 },
                        { opacity: 0, transform: 'translateY(25px)' }
                    ];

                    const options = {
                        duration: duration,
                        easing: 'cubic-bezier(0.25, 0.1, 0.25, 1)', // Smoother easing
                        fill: 'forwards'
                    };

                    nameEl.animate(keyframes, options);
                    chanceEl.animate(keyframes, options);

                    cycleCount++;

                    // Schedule next cycle using rAF for smooth timing
                    const targetTime = timestamp + duration;
                    function checkTime(now) {
                        if (now >= targetTime) {
                            doCycle(now);
                        } else {
                            requestAnimationFrame(checkTime);
                        }
                    }
                    requestAnimationFrame(checkTime);
                }

                requestAnimationFrame(doCycle);
            }
        }

        function startCooldown(baseDuration) {
            // const gearBonuses = calculateGearBonuses();
            // const speedMult = 1 + gearBonuses.rollSpeed;
            const rawSpeedMult = 1 + calculateTotalRollSpeed();
            // Cap speed multiplier at 30x to prevent performance issues with warp/transcendent potions
            const speedMult = Math.min(rawSpeedMult, 30);
            // Calculate duration with minimum floor of 50ms to prevent too-rapid rolling
            const duration = Math.max(50, baseDuration / speedMult);

            isOnCooldown = true;
            const rollBtn = document.getElementById('roll-button');
            const progressFill = rollBtn.querySelector('.button-progress-fill');
            rollBtn.classList.add('disabled', 'cooldown-active');

            let startTime = null;
            function animateCooldown(timestamp) {
                if (!startTime) startTime = timestamp;
                const progress = timestamp - startTime;
                const remaining = Math.max(0, duration - progress);
                const percent = (remaining / duration) * 100;
                progressFill.style.width = `${percent}%`;

                if (progress < duration) {
                    requestAnimationFrame(animateCooldown);
                } else {
                    isOnCooldown = false;
                    rollBtn.classList.remove('disabled', 'cooldown-active');
                    progressFill.style.width = '0%';
                }
            }
            requestAnimationFrame(animateCooldown);
        }

        function updateRollCount() {
            const countElement = document.querySelector('.roll-count');
            if (!countElement) return;

            if (isFatebreakerDeviceEquipped()) {
                if (fatebreakerCharged) {
                    countElement.textContent = 'SINGULARITY READY';
                    countElement.style.color = '#ff9f43';
                } else {
                    countElement.textContent = `SINGULARITY IN ${100 - fatebreakerRollTracker}`;
                    countElement.style.color = '#ffcf8a';
                }
                return;
            }

            if (isCataclysmDeviceEquipped() && cataclysmBuffActive && cataclysmBuffRollsRemaining > 0) {
                countElement.textContent = `CATACLYSM (${cataclysmBuffRollsRemaining})`;
                countElement.style.color = '#ff7a45';
                return;
            }

            if (hasRemoveBonusRollGear()) {
                if (isUnfathomableRuinsEquipped()) {
                    if (unfathomableBuffActive && unfathomableBuffRollsRemaining > 0) {
                        countElement.textContent = `100X LUCK READY (${unfathomableBuffRollsRemaining})`;
                        countElement.style.color = '#44ff88';
                    } else {
                        const rollsUntilProc = 1000 - (playerStats.totalRolls % 1000);
                        countElement.textContent = `100X IN ${rollsUntilProc}`;
                        countElement.style.color = '#7bed9f';
                    }
                } else if (isChronowardenGauntletEquipped()) {
                    if (chronowardenBuffActive && chronowardenBuffRollsRemaining > 0) {
                        countElement.textContent = `30X LUCK READY (${chronowardenBuffRollsRemaining})`;
                        countElement.style.color = '#66ffe0';
                    } else {
                        const rollsUntilProc = 300 - (playerStats.totalRolls % 300);
                        countElement.textContent = `30X IN ${rollsUntilProc}`;
                        countElement.style.color = '#6ee7ff';
                    }
                } else {
                    countElement.textContent = 'BONUS DISABLED';
                    countElement.style.color = '#95a5a6';
                }
                return;
            }

            const threshold = getBonusRollThreshold();
            const hasDarkshader = isDarkshaderEquipped();
            const casterProfile = getCasterProfile();
            const hasLightcaster = !!casterProfile;

            if (rollCounter === threshold) {
                if (hasLightcaster) {
                    if (lightcasterBuffActive && lightcasterBuffRollsRemaining > 0) {
                        countElement.textContent = `X${casterProfile.phaseBonusLuck} LUCK READY`;
                        countElement.style.color = "#ffffff";
                    } else {
                        countElement.textContent = `X${casterProfile.normalBonusLuck} LUCK READY`;
                        countElement.style.color = casterProfile.mode === 'crusher' ? "#ff66cc" : "#ffd700";
                    }
                } else if (hasDarkshader) {
                    if (darkshaderBuffActive && darkshaderBuffRollsRemaining > 0) {
                        // Encroached bonus roll = 5x
                        countElement.textContent = "X5 LUCK READY";
                        countElement.style.color = "#e056fd"; // Purple for encroached
                    } else {
                        // Normal Darkshader bonus roll = 2.5x
                        countElement.textContent = "X2.5 LUCK READY";
                        countElement.style.color = "#ffd700"; // Yellow like normal
                    }
                } else {
                    if (playerInventory.equipped.left === 'gravitational-device') {
                        countElement.textContent = "X6 LUCK READY";
                        countElement.style.color = "#ff0066";
                    } else {
                        countElement.textContent = "X2 LUCK READY";
                        countElement.style.color = "#00fffa";
                    }
                }
            } else {
                const displayText = `${rollCounter}/${threshold}`;
                countElement.textContent = displayText;
                // White during caster active phase, purple during ENCROACHED, gold otherwise
                if (hasLightcaster && lightcasterBuffActive && lightcasterBuffRollsRemaining > 0) {
                    countElement.style.color = "#ffffff";
                } else if (hasDarkshader && darkshaderBuffActive && darkshaderBuffRollsRemaining > 0) {
                    countElement.style.color = "#e056fd";
                } else {
                    countElement.style.color = (hasLightcaster && casterProfile.mode === 'crusher') ? "#ff66cc" : "#ffd700";
                }
            }
        }

        // Darkshader purple vignette effect
        function updateDarkshaderVignette(active) {
            let container = document.getElementById('darkshader-container');

            if (!container) {
                // Create container for fade transition
                container = document.createElement('div');
                container.id = 'darkshader-container';
                container.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    z-index: 100;
                    opacity: 0;
                    transition: opacity 1.5s cubic-bezier(0.4, 0, 0.2, 1);
                `;

                // Inner vignette with the pulse animation
                const vignette = document.createElement('div');
                vignette.style.cssText = `
                    width: 100%;
                    height: 100%;
                    background: radial-gradient(ellipse at center, 
                        transparent 40%, 
                        rgba(128, 0, 255, 0.15) 70%, 
                        rgba(80, 0, 180, 0.35) 100%);
                    animation: darkshader-pulse 2s ease-in-out infinite;
                `;

                container.appendChild(vignette);
                document.body.appendChild(container);

                // Add keyframes if not already added
                if (!document.getElementById('darkshader-keyframes')) {
                    const style = document.createElement('style');
                    style.id = 'darkshader-keyframes';
                    style.textContent = `
                        @keyframes darkshader-pulse {
                            0%, 100% { opacity: 0.8; }
                            50% { opacity: 1; }
                        }
                    `;
                    document.head.appendChild(style);
                }
            }

            // Cleanup legacy element if it exists
            const oldVignette = document.getElementById('darkshader-vignette');
            if (oldVignette) oldVignette.remove();

            if (active) {
                // Ensure it's in the DOM/visible before fading
                container.style.display = 'block';
                // Force reflow
                container.offsetHeight;
                container.style.opacity = '1';
            } else {
                container.style.opacity = '0';
                // Do not set display none immediately to allow fade out
            }
        }

        // Lightcaster/Chromatic Crusher vignette effect for caster phase
        function updateLightcasterVignette(active) {
            const casterProfile = getCasterProfile();
            const isCrusher = casterProfile && casterProfile.mode === 'crusher';
            const containerId = isCrusher ? 'chromatic-crusher-container' : 'lightcaster-container';
            const oldContainerId = isCrusher ? 'lightcaster-container' : 'chromatic-crusher-container';

            const oldContainer = document.getElementById(oldContainerId);
            if (oldContainer) oldContainer.remove();

            let container = document.getElementById(containerId);
            if (!container) {
                container = document.createElement('div');
                container.id = containerId;
                container.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    z-index: 100;
                    opacity: 0;
                    transition: opacity 1.5s cubic-bezier(0.4, 0, 0.2, 1);
                `;

                const vignette = document.createElement('div');
                if (isCrusher) {
                    vignette.style.cssText = `
                        width: 100%;
                        height: 100%;
                        background:
                            radial-gradient(ellipse at center,
                                transparent 34%,
                                rgba(255, 255, 255, 0.08) 52%,
                                rgba(255, 60, 60, 0.23) 70%,
                                rgba(80, 255, 120, 0.25) 84%,
                                rgba(80, 140, 255, 0.34) 100%);
                        mix-blend-mode: screen;
                        filter: saturate(2.2) contrast(1.22);
                        animation: chromatic-rgb-hueshift 0.28s linear infinite, chromatic-rgb-vignette-pulse 0.18s steps(2, end) infinite;
                    `;
                } else {
                    vignette.style.cssText = `
                        width: 100%;
                        height: 100%;
                        background: radial-gradient(ellipse at center, 
                            transparent 35%, 
                            rgba(255, 255, 200, 0.12) 50%,
                            rgba(255, 215, 0, 0.20) 70%, 
                            rgba(255, 255, 255, 0.35) 100%);
                        animation: lightcaster-pulse 1.5s ease-in-out infinite;
                    `;
                }

                container.appendChild(vignette);
                document.body.appendChild(container);

                if (!document.getElementById('lightcaster-keyframes')) {
                    const style = document.createElement('style');
                    style.id = 'lightcaster-keyframes';
                    style.textContent = `
                        @keyframes lightcaster-pulse {
                            0%, 100% { opacity: 0.7; }
                            50% { opacity: 1; }
                        }
                    `;
                    document.head.appendChild(style);
                }

                if (!document.getElementById('chromatic-crusher-keyframes')) {
                    const style = document.createElement('style');
                    style.id = 'chromatic-crusher-keyframes';
                    style.textContent = `
                        @keyframes chromatic-rgb-hueshift {
                            0% { filter: saturate(2.2) contrast(1.22) hue-rotate(0deg); }
                            100% { filter: saturate(2.2) contrast(1.22) hue-rotate(360deg); }
                        }
                        @keyframes chromatic-rgb-vignette-pulse {
                            0%, 100% { opacity: 0.74; }
                            50% { opacity: 0.98; }
                        }
                    `;
                    document.head.appendChild(style);
                }
            }

            if (active) {
                container.style.display = 'block';
                container.offsetHeight;
                container.style.opacity = '1';
            } else {
                container.style.opacity = '0';
            }
        }

        // Omega Drive orange/red vignette effect for OVERDRIVE phase
        function updateOmegaVignette(active) {
            let container = document.getElementById('omega-container');

            if (!container) {
                // Create container for fade transition
                container = document.createElement('div');
                container.id = 'omega-container';
                container.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    z-index: 100;
                    opacity: 0;
                    transition: opacity 1s cubic-bezier(0.4, 0, 0.2, 1);
                `;

                // Inner vignette with orange/red gradient and pulse animation
                const vignette = document.createElement('div');
                vignette.style.cssText = `
                    width: 100%;
                    height: 100%;
                    background: radial-gradient(ellipse at center, 
                        transparent 30%, 
                        rgba(255, 100, 50, 0.15) 50%,
                        rgba(255, 69, 0, 0.25) 70%, 
                        rgba(255, 30, 0, 0.40) 100%);
                    animation: omega-pulse 1s ease-in-out infinite;
                `;

                container.appendChild(vignette);
                document.body.appendChild(container);

                // Add keyframes if not already added
                if (!document.getElementById('omega-keyframes')) {
                    const style = document.createElement('style');
                    style.id = 'omega-keyframes';
                    style.textContent = `
                        @keyframes omega-pulse {
                            0%, 100% { opacity: 0.6; }
                            50% { opacity: 1; }
                        }
                    `;
                    document.head.appendChild(style);
                }
            }

            if (active) {
                // Ensure it's in the DOM/visible before fading
                container.style.display = 'block';
                // Force reflow
                container.offsetHeight;
                container.style.opacity = '1';
            } else {
                container.style.opacity = '0';
                // Do not set display none immediately to allow fade out
            }
        }

        // Unfathomable Ruins green vignette effect for 100X window
        function updateUnfathomableVignette(active) {
            let container = document.getElementById('unfathomable-container');

            if (!container) {
                container = document.createElement('div');
                container.id = 'unfathomable-container';
                container.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    z-index: 100;
                    opacity: 0;
                    transition: opacity 0.8s cubic-bezier(0.4, 0, 0.2, 1);
                `;

                const vignette = document.createElement('div');
                vignette.style.cssText = `
                    width: 100%;
                    height: 100%;
                    background: radial-gradient(ellipse at center,
                        transparent 35%,
                        rgba(60, 255, 130, 0.14) 55%,
                        rgba(20, 200, 90, 0.25) 75%,
                        rgba(0, 120, 45, 0.40) 100%);
                    animation: unfathomable-pulse 1.2s ease-in-out infinite;
                `;

                container.appendChild(vignette);
                document.body.appendChild(container);

                if (!document.getElementById('unfathomable-keyframes')) {
                    const style = document.createElement('style');
                    style.id = 'unfathomable-keyframes';
                    style.textContent = `
                        @keyframes unfathomable-pulse {
                            0%, 100% { opacity: 0.75; }
                            50% { opacity: 1; }
                        }
                    `;
                    document.head.appendChild(style);
                }
            }

            if (active) {
                container.style.display = 'block';
                container.offsetHeight;
                container.style.opacity = '1';
            } else {
                container.style.opacity = '0';
            }
        }

        // Chronowarden Gauntlet teal vignette effect for x30 burst window
        function updateChronowardenVignette(active) {
            let container = document.getElementById('chronowarden-container');

            if (!container) {
                container = document.createElement('div');
                container.id = 'chronowarden-container';
                container.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    z-index: 100;
                    opacity: 0;
                    transition: opacity 0.8s cubic-bezier(0.4, 0, 0.2, 1);
                `;

                const vignette = document.createElement('div');
                vignette.style.cssText = `
                    width: 100%;
                    height: 100%;
                    background: radial-gradient(ellipse at center,
                        transparent 35%,
                        rgba(80, 255, 220, 0.12) 55%,
                        rgba(45, 220, 200, 0.22) 75%,
                        rgba(0, 125, 140, 0.35) 100%);
                    animation: chronowarden-pulse 1.1s ease-in-out infinite;
                `;

                container.appendChild(vignette);
                document.body.appendChild(container);

                if (!document.getElementById('chronowarden-keyframes')) {
                    const style = document.createElement('style');
                    style.id = 'chronowarden-keyframes';
                    style.textContent = `
                        @keyframes chronowarden-pulse {
                            0%, 100% { opacity: 0.72; }
                            50% { opacity: 1; }
                        }
                    `;
                    document.head.appendChild(style);
                }
            }

            if (active) {
                container.style.display = 'block';
                container.offsetHeight;
                container.style.opacity = '1';
            } else {
                container.style.opacity = '0';
            }
        }

        function toggleAutoRoll() {
            const btn = document.getElementById('auto-roll');
            const span = btn.querySelector('span');
            if (autoRollInterval) {
                clearInterval(autoRollInterval);
                autoRollInterval = null;
                span.textContent = 'Auto Roll : Off';
                btn.setAttribute('aria-pressed', 'false');
            } else {
                autoRollInterval = setInterval(() => {
                    if (!isRolling && !isOnCooldown) performRoll();
                }, 100);
                span.textContent = 'Auto Roll : On';
                btn.setAttribute('aria-pressed', 'true');
            }
        }

        function toggleQuickRoll() {
            const btn = document.getElementById('quick-roll');
            const span = btn.querySelector('span');
            quickRollMode = !quickRollMode;
            span.textContent = `Quick Roll : ${quickRollMode ? 'On' : 'Off'}`;
            btn.setAttribute('aria-pressed', quickRollMode ? 'true' : 'false');
        }

        // --- Admin Panel ---
        function toggleAdminPanel() {
            const panel = document.getElementById('admin-panel');
            const rollOverlay = document.getElementById('roll-overlay');
            updateAdminChromaticEffect();
            panel.classList.toggle('active');
            if (panel.classList.contains('active')) {
                if (rollOverlay) rollOverlay.style.visibility = 'hidden';
            } else {
                if (rollOverlay) rollOverlay.style.visibility = 'visible';
            }
        }

        function initAdminPanel() {
            const grid = document.getElementById('biome-grid');
            grid.innerHTML = '';

            BIOMES.forEach((biome, index) => {
                const btn = document.createElement('button');
                btn.classList.add('biome-btn');
                btn.setAttribute('data-biome', biome.name);
                if (currentBiome.name === biome.name) btn.classList.add('active');
                btn.textContent = biome.name;

                // Apply biome color to button
                if (biome.color) {
                    btn.style.color = biome.color;
                    btn.style.borderColor = biome.color;
                    btn.style.boxShadow = `0 0 5px ${biome.color}40`;
                }

                btn.addEventListener('click', () => {
                    // Set biome
                    currentBiome = biome;
                    biomeTimeLeft = biome.duration || 9999; // Long duration for admin override
                    updateHUD();
                    saveGame(); // Save immediately when biome is manually changed

                    // Update active state
                    document.querySelectorAll('.biome-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                });
                grid.appendChild(btn);
            });
        }

        function populateAdminGears() {
            const grid = document.getElementById('admin-gear-grid');
            const searchQuery = document.getElementById('admin-gear-search').value.toLowerCase();
            grid.innerHTML = '';

            GEARS.forEach(gear => {
                if (gear.isMaterial) return; // Skip materials
                if (searchQuery && !gear.name.toLowerCase().includes(searchQuery)) return;

                const btn = document.createElement('button');
                btn.classList.add('admin-gear-btn');
                if (playerInventory.craftedGears[gear.id]) btn.classList.add('owned');
                btn.textContent = gear.name;
                btn.style.color = getTierColor(gear.tier);
                btn.style.borderColor = getTierColor(gear.tier);

                btn.addEventListener('click', () => {
                    playerInventory.craftedGears[gear.id] = true;
                    showNotification(`Added ${gear.name} to inventory!`, getTierColor(gear.tier));
                    populateAdminGears(); // Refresh to show owned state
                });

                grid.appendChild(btn);
            });
        }

        function giveAdminMaterial() {
            const nameInput = document.getElementById('admin-material-name');
            const countInput = document.getElementById('admin-material-count');
            const name = nameInput.value.trim();
            const count = parseInt(countInput.value) || 1;

            if (!name) {
                showNotification('Enter a material name!', '#ff6b6b');
                return;
            }

            addMaterial(name, count);
            showNotification(`Added ${count}x ${name} to inventory!`, '#2ecc71');
            nameInput.value = '';
        }

        // Tab Switching
        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.admin-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.tab === tabName);
            });

            // Update sections
            document.querySelectorAll('.admin-section').forEach(section => {
                section.style.display = 'none';
            });
            document.getElementById(`section-${tabName}`).style.display = 'block';

            // Populate content when switching to specific tabs
            if (tabName === 'items') {
                populateAdminGears();
                populateAdminPotions();
                populateAdminChests();
            } else if (tabName === 'testing') {
                populateCutsceneList();
            }
        }

        // Admin Potions
        function populateAdminPotions() {
            const container = document.getElementById('admin-potion-grid');
            if (!container) return;

            container.innerHTML = '';
            POTIONS.forEach(potion => {
                const btn = document.createElement('button');
                btn.classList.add('admin-gear-btn');
                btn.textContent = potion.name;
                btn.style.color = '#e056fd'; // Potion color
                btn.addEventListener('click', () => {
                    const countInput = document.getElementById('admin-potion-count');
                    const count = parseInt(countInput?.value) || 1;
                    addPotion(potion.id, count);
                });
                container.appendChild(btn);
            });
        }

        // Admin Chests
        function populateAdminChests() {
            const container = document.getElementById('admin-chest-grid');
            if (!container) return;

            container.innerHTML = '';

            Object.keys(CHEST_TYPES).forEach(id => {
                const chest = CHEST_TYPES[id];
                const btn = document.createElement('button');
                btn.classList.add('admin-gear-btn');
                btn.textContent = chest.name;
                btn.style.color = chest.color;
                btn.style.borderColor = chest.color;

                btn.addEventListener('click', () => {
                    const countInput = document.getElementById('admin-chest-count');
                    const count = parseInt(countInput?.value) || 10;
                    playerInventory.chests[id] = (playerInventory.chests[id] || 0) + count;
                    showNotification(`Added ${count}x ${chest.name} to inventory!`, chest.color);
                    saveGame();
                });
                container.appendChild(btn);
            });
        }

        // Cutscene List for Testing Tab
        function populateCutsceneList() {
            const container = document.getElementById('admin-cutscene-list');
            if (!container) return;

            container.innerHTML = '';

            // Get all auras that have video or text cutscenes
            const cutsceneAuras = AURAS.filter(aura =>
                (typeof hasVideoCutscene === 'function' && hasVideoCutscene(aura.id)) ||
                (typeof hasTextCutscene === 'function' && hasTextCutscene(aura.id))
            ).sort((a, b) => b.chance - a.chance); // Sort by rarity (rarest first)

            cutsceneAuras.forEach(aura => {
                const btn = document.createElement('button');
                btn.classList.add('admin-gear-btn');
                btn.textContent = aura.name;
                btn.style.color = aura.color || '#fff';
                btn.style.fontFamily = aura.fontFamily || "'Sarpanch', sans-serif";
                btn.title = `1 in ${aura.chance.toLocaleString()}`;

                btn.addEventListener('click', () => {
                    // Set the input field and trigger test
                    const inputField = document.getElementById('admin-cutscene-aura');
                    if (inputField) inputField.value = aura.id;
                    // Auto-trigger the test
                    testAdminCutscene(aura.id);
                });
                container.appendChild(btn);
            });
        }

        // Test cutscene function - plays cutscene ONLY, does not give aura
        function testAdminCutscene(auraId) {
            const id = auraId || document.getElementById('admin-cutscene-aura').value.trim();
            if (!id) {
                showNotification('Enter an aura ID!', '#ff6b6b');
                return;
            }

            const aura = AURAS.find(a => a.id === id || a.name.toLowerCase() === id.toLowerCase());
            if (!aura) {
                showNotification('Aura not found!', '#ff6b6b');
                return;
            }

            const hasVideo = typeof hasVideoCutscene === 'function' && hasVideoCutscene(aura.id);
            const hasText = typeof hasTextCutscene === 'function' && hasTextCutscene(aura.id);

            if (!hasVideo && !hasText) {
                showNotification('This aura has no cutscene!', '#ff6b6b');
                return;
            }

            // Close admin panel
            document.getElementById('admin-panel').classList.remove('active');

            showNotification(`Testing cutscene: ${aura.name}`, aura.color || '#00d4ff');

            // Play cutscene without recording the aura
            if (hasVideo && typeof playVideoCutscene === 'function') {
                playVideoCutscene(aura, () => {
                    showNotification('Cutscene test complete!', '#2ecc71');
                }, true);
            } else if (hasText && typeof playTextCutscene === 'function') {
                playTextCutscene(aura, () => {
                    showNotification('Cutscene test complete!', '#2ecc71');
                });
            } else {
                showNotification('Cutscene system not available', '#ff6b6b');
            }
        }

        // Time Controls
        let autoTimeCycle = true;

        function setTime(time) {
            currentTime = time;
            timeCycleTimer = 0; // Reset timer
            updateHUD();
            updateTimeButtons();
        }

        function updateTimeButtons() {
            const dayBtn = document.getElementById('time-day');
            const nightBtn = document.getElementById('time-night');

            dayBtn.classList.toggle('active', currentTime === 'DAYTIME');
            nightBtn.classList.toggle('active', currentTime === 'NIGHTTIME');
        }

        function toggleAutoTimeCycle() {
            autoTimeCycle = !autoTimeCycle;
            const btn = document.getElementById('time-auto-toggle');
            btn.textContent = autoTimeCycle ? 'ON' : 'OFF';
            btn.classList.toggle('off', !autoTimeCycle);
        }
        function calculateGearBonuses() {
            let totalLuck = 0;
            let totalRollSpeed = 0;
            let duplicateChance = 0;
            const slots = ['left', 'right'];
            slots.forEach(slot => {
                const gearId = playerInventory.equipped[slot];
                if (gearId) {
                    const gear = GEARS.find(g => g.id === gearId);
                    if (gear && gear.stats) {
                        totalLuck += gear.stats.luck || 0;
                        totalRollSpeed += gear.stats.rollSpeed || 0;
                        if (gear.stats.duplicateChance) duplicateChance += gear.stats.duplicateChance;

                        // Rainy Bonus (Legacy Check)
                        if (gear.stats.rainyBonus && (currentWeatherType === 'RAINY' || (currentBiome && currentBiome.name === 'RAINY'))) {
                            totalLuck += (gear.stats.rainyBonus.luck || 0);
                            totalRollSpeed += (gear.stats.rainyBonus.rollSpeed || 0);
                        }
                        // Starfall Bonus (Legacy Check)
                        if (gear.stats.starfallBonus && currentBiome && currentBiome.name === 'STARFALL') {
                            totalLuck += (gear.stats.starfallBonus.luck || 0);
                            totalRollSpeed += (gear.stats.starfallBonus.rollSpeed || 0);
                        }
                        // Weather Bonus (Ragnaroker)
                        if (gear.stats.weatherBonus) {
                            const wb = gear.stats.weatherBonus;
                            const matched = (currentWeatherType && wb.biomes.includes(currentWeatherType)) || (currentBiome && wb.biomes.includes(currentBiome.name));
                            if (matched) {
                                totalLuck += (wb.luck || 0);
                                totalRollSpeed += (wb.rollSpeed || 0);
                            }
                        }
                        // Biome Bonus (Ominous Coffin)
                        if (gear.stats.biomeBonus) {
                            const bb = gear.stats.biomeBonus;
                            const matched = (currentBiome && bb.biomes.includes(currentBiome.name));
                            if (matched) {
                                totalLuck += (bb.luck || 0);
                                totalRollSpeed += (bb.rollSpeed || 0);
                        }
                    }
                }

                // Chronowarden Gauntlet: Every 300th roll grants x30 Luck for 6 rolls
                if (isChronowardenGauntletEquipped()) {
                    if ((playerStats.totalRolls + 1) % 300 === 0) {
                        activateChronowardenBuff();
                    }

                    if (chronowardenBuffActive && chronowardenBuffRollsRemaining > 0) {
                        totalLuck *= 30;
                        chronowardenBuffRollsRemaining--;
                        updateRollCount();
                        if (chronowardenBuffRollsRemaining <= 0) {
                            chronowardenBuffActive = false;
                            if (typeof updateChronowardenVignette === 'function') updateChronowardenVignette(false);
                            updateRollCount();
                            showNotification("Chrono Burst Ended", '#7f8c8d');
                        }
                    }
                }
            }

            // Cataclysm Device Phase Logic (Every 50 rolls, 5 rolls of x3 Luck + 80% Speed)
            if (isCataclysmDeviceEquipped()) {
                if (cataclysmBuffActive && cataclysmBuffRollsRemaining > 0) {
                    cataclysmBuffRollsRemaining--;
                    updateRollCount();
                    if (cataclysmBuffRollsRemaining <= 0) {
                        cataclysmBuffActive = false;
                        updateRollCount();
                        showNotification('CATACLYSM phase ended!', '#c0392b');
                    }
                } else {
                    cataclysmRollTracker++;
                    if (cataclysmRollTracker >= 50) {
                        cataclysmRollTracker = 0;
                        cataclysmBuffActive = true;
                        cataclysmBuffRollsRemaining = 5;
                        updateRollCount();
                        showNotification('CATACLYSM! x3 Luck + 80% Speed for 5 rolls!', '#ff5733');
                    }
                }
            }
            });
            return { luck: totalLuck, rollSpeed: totalRollSpeed, duplicateChance };
        }

        function showNotification(message, color = '#fff') {
            if (!userSettings.notifications.enabled) return;
            const container = document.getElementById('notification-container');
            if (!container) return;

            const notif = document.createElement('div');
            notif.classList.add('notification');
            notif.innerHTML = `
                    <div class="corner tl"></div><div class="corner tr"></div>
                    <div class="corner bl"></div><div class="corner br"></div>
                    <span style="color: ${color}">${message}</span>
                    <div class="notif-bar" style="background: ${color}"></div>
                `;

            container.appendChild(notif);

            // Auto remove after 3s
            setTimeout(() => {
                notif.classList.add('fade-out');
                setTimeout(() => notif.remove(), 500);
            }, 3000);
        }

        function addMaterial(materialName, count = 1) {
            // Hologrammer Duplication Check
            const bonuses = calculateGearBonuses();
            if (bonuses.duplicateChance && Math.random() < bonuses.duplicateChance) {
                count *= 2;
                showNotification(`Hologrammer Duplicated ${materialName}!`, '#00fffa');
            }

            if (!playerInventory.materials[materialName]) {
                playerInventory.materials[materialName] = 0;
            }
            const currentAmount = playerInventory.materials[materialName];
            const nextAmount = currentAmount + count;
            if (nextAmount > Number.MAX_SAFE_INTEGER) {
                playerInventory.materials[materialName] = Number.MAX_SAFE_INTEGER;
                if (userSettings.rolling.storageWarning) {
                    showNotification(`Storage full warning: ${materialName} reached max safe value`, '#ff6b6b');
                }
            } else {
                playerInventory.materials[materialName] = nextAmount;
            }
            playerStats.totalMaterialsCollected += count;

            // Show notification only when adding to a gear (not storage)
            if (userSettings.notifications && userSettings.notifications.autoAdd) {
                if (autoDepositGear && autoDepositGear.recipe && autoDepositGear.recipe[materialName]) {
                    const required = autoDepositGear.recipe[materialName];
                    const currentAmount = playerInventory.materials[materialName] || 0;
                    const aura = AURAS.find(a => a.name === materialName);
                    const color = aura ? aura.color : '#fff';

                    if (currentAmount <= required) {
                        // Still need more, show notification
                        showNotification(`Your ${materialName} has been added to ${autoDepositGear.name}`, color);
                    }
                    if (currentAmount === required) {
                        // Just completed this material requirement
                        showNotification(`${materialName} complete for ${autoDepositGear.name}!`, '#2ecc71');
                    }
                }
            }

            // Check if this material is needed for auto-deposit gear
            checkAutoDeposit(materialName);

            // Check for Auto Gear Progression
            checkAutoGear();

            // Auto-update workshop preview if open and gear is selected
            if (selectedGear) {
                selectGear(selectedGear);
            }
        }

        // --- Throttled Save System ---
        let _savePending = false;
        let _lastSaveTime = 0;
        const _minSaveInterval = 3000; // Minimum 3 seconds between saves
        let _isResetting = false; // Flag to prevent saving during reset

        function saveGame() {
            if (_isResetting) return; // Don't save if we're resetting
            const now = Date.now();

            // If we saved recently, queue a delayed save instead
            if (now - _lastSaveTime < _minSaveInterval) {
                if (!_savePending) {
                    _savePending = true;
                    setTimeout(() => {
                        _savePending = false;
                        if (!_isResetting) _doSaveGame();
                    }, _minSaveInterval - (now - _lastSaveTime));
                }
                return;
            }

            _doSaveGame();
        }

        function _doSaveGame() {
            if (_isResetting) return; // Don't save if we're resetting
            _lastSaveTime = Date.now();
            const saveData = {
                rollCounter,
                currentEquippedAura: currentEquippedAura ? currentEquippedAura.id : 'nothing',
                userSettings,
                playerInventory,
                currentBiome: currentBiome.name,
                biomeTimeLeft,
                activeBuffs, // Save active potion effects
                // oneTimeBuffs: oneTimeBuffs, // Optional: Save queued buffs? usually short lived so maybe not, but user asked for "full game". Let's include it.
                oneTimeBuffs,
                playerStats: {
                    totalRolls: playerStats.totalRolls,
                    bestAura: playerStats.bestAura,
                    collectedAuras: playerStats.collectedAuras,
                    playtimeSeconds: playerStats.playtimeSeconds,
                    // Extended stats
                    biomesDiscovered: playerStats.biomesDiscovered,
                    rarestBiome: playerStats.rarestBiome,
                    potionsUsed: playerStats.potionsUsed,
                    gearsCrafted: playerStats.gearsCrafted,
                    tierCounts: playerStats.tierCounts,
                    nativeAurasRolled: playerStats.nativeAurasRolled,
                    bonusRollsHit: playerStats.bonusRollsHit,
                    luckyStreak: playerStats.luckyStreak,
                    dryStreak: playerStats.dryStreak,
                    totalMaterialsCollected: playerStats.totalMaterialsCollected,
                    // Convert Set to Array for storage
                    biomesVisited: playerStats.biomesVisited ? Array.from(playerStats.biomesVisited) : []
                },
                // Persist VIP Status
                hasVIP,
                hasVIPPlus,
                // Persist Darkshader progress
                darkshaderRollTracker,
                darkshaderBuffActive,
                darkshaderBuffRollsRemaining,
                // Persist achievements
                playerAchievements
            };
            localStorage.setItem('solsRngSave', JSON.stringify(saveData));
        }

        // Force immediate save on page unload
        window.addEventListener('beforeunload', () => {
            _doSaveGame();
        });

        function loadGame() {
            const saved = localStorage.getItem('solsRngSave');
            if (!saved) return;
            try {
                const data = JSON.parse(saved);
                rollCounter = data.rollCounter || 1;
                if (data.currentEquippedAura) {
                    currentEquippedAura = AURAS.find(a => a.id === data.currentEquippedAura) || AURAS[0];
                }

                // Restore Biome
                if (data.currentBiome) {
                    const savedBiome = BIOMES.find(b => b.name === data.currentBiome);
                    if (savedBiome) {
                        currentBiome = savedBiome;
                        biomeTimeLeft = data.biomeTimeLeft || 0;
                    }
                }

                if (data.userSettings) {
                    Object.assign(userSettings.rolling, data.userSettings.rolling);
                    Object.assign(userSettings.audio, data.userSettings.audio);
                    if (data.userSettings.filters) userSettings.filters = data.userSettings.filters;
                    if (data.userSettings.notifications) Object.assign(userSettings.notifications, data.userSettings.notifications);
                }

                // Restore buffs
                if (data.activeBuffs) {
                    activeBuffs = data.activeBuffs;
                }
                if (data.oneTimeBuffs) {
                    oneTimeBuffs = data.oneTimeBuffs;
                }
                if (data.playerInventory) {
                    Object.assign(playerInventory.materials, data.playerInventory.materials || {});
                    Object.assign(playerInventory.craftedGears, data.playerInventory.craftedGears || {});
                    Object.assign(playerInventory.equipped, data.playerInventory.equipped || {});
                    // Legacy-save compatibility: any equipped gear should be treated as owned.
                    ['left', 'right'].forEach(slot => {
                        const equippedId = playerInventory.equipped[slot];
                        if (equippedId) playerInventory.craftedGears[equippedId] = true;
                    });
                    if (data.playerInventory.potions) Object.assign(playerInventory.potions, data.playerInventory.potions);
                    if (data.playerInventory.chests) Object.assign(playerInventory.chests, data.playerInventory.chests);
                    if (data.playerInventory.auraStorage) {
                        playerInventory.auraStorage.level = Number.isFinite(data.playerInventory.auraStorage.level)
                            ? Math.max(0, Math.floor(data.playerInventory.auraStorage.level))
                            : 0;
                        playerInventory.auraStorage.capacity = Number.isFinite(data.playerInventory.auraStorage.capacity)
                            ? Math.max(1, Math.floor(data.playerInventory.auraStorage.capacity))
                            : getAuraStorageCapacityForLevel(playerInventory.auraStorage.level);
                        playerInventory.auraStorage.nextId = Number.isFinite(data.playerInventory.auraStorage.nextId)
                            ? Math.max(1, Math.floor(data.playerInventory.auraStorage.nextId))
                            : 1;
                        playerInventory.auraStorage.items = Array.isArray(data.playerInventory.auraStorage.items)
                            ? data.playerInventory.auraStorage.items
                            : [];
                    }
                }
                ensureAuraStorageState();
                if (data.playerAchievements) {
                    playerAchievements.completed = data.playerAchievements.completed || {};
                    playerAchievements.unlockedTitles = data.playerAchievements.unlockedTitles || [];
                    playerAchievements.activeTitle = data.playerAchievements.activeTitle || null;
                    playerAchievements.coins = data.playerAchievements.coins || 0;
                    playerAchievements.voidCoins = data.playerAchievements.voidCoins || 0;
                    playerAchievements.highestRarityFound = data.playerAchievements.highestRarityFound || 0;
                    playerAchievements.breakthroughCount = data.playerAchievements.breakthroughCount || 0;
                    // Playtime is synced from playerStats, but we can load just in case
                }

                // Re-initialize Biomes Set
                if (data.playerStats && data.playerStats.biomesVisited) {
                    // Check if it was saved as array (JSON doesn't support Set)
                    if (Array.isArray(data.playerStats.biomesVisited)) {
                        playerStats.biomesVisited = new Set(data.playerStats.biomesVisited);
                    } else if (typeof data.playerStats.biomesVisited === 'object') {
                        // convert object keys or values? Likely array is best
                        playerStats.biomesVisited = new Set(Object.values(data.playerStats.biomesVisited));
                    }
                } else if (data.playerStats && data.playerStats.biomesDiscovered) {
                    // Legacy support
                    playerStats.biomesVisited = new Set(Object.keys(data.playerStats.biomesDiscovered));
                }

                if (data.playerStats) {
                    playerStats.totalRolls = data.playerStats.totalRolls || 0;
                    playerStats.bestAura = data.playerStats.bestAura || null;
                    playerStats.collectedAuras = data.playerStats.collectedAuras || {};
                    playerStats.playtimeSeconds = data.playerStats.playtimeSeconds || 0;
                    // Extended stats
                    playerStats.biomesDiscovered = data.playerStats.biomesDiscovered || {};
                    playerStats.rarestBiome = data.playerStats.rarestBiome || null;
                    playerStats.potionsUsed = data.playerStats.potionsUsed || 0;
                    playerStats.gearsCrafted = data.playerStats.gearsCrafted || 0;
                    if (data.playerStats.tierCounts) {
                        Object.assign(playerStats.tierCounts, data.playerStats.tierCounts);
                    }
                    playerStats.nativeAurasRolled = data.playerStats.nativeAurasRolled || 0;
                    playerStats.bonusRollsHit = data.playerStats.bonusRollsHit || 0;
                    playerStats.luckyStreak = data.playerStats.luckyStreak || 0;
                    playerStats.dryStreak = data.playerStats.dryStreak || 0;
                    playerStats.totalMaterialsCollected = data.playerStats.totalMaterialsCollected || 0;
                    if (data.playerInventory && data.playerInventory.potions) {
                        playerInventory.potions = data.playerInventory.potions;
                    }
                }

                // Restore VIP Status
                hasVIP = data.hasVIP || false;
                hasVIPPlus = data.hasVIPPlus || false;

                // Update Admin Buttons to match loaded state
                const vipBtn = document.getElementById('admin-toggle-vip');
                const vipPlusBtn = document.getElementById('admin-toggle-vip-plus');
                if (vipBtn) {
                    vipBtn.textContent = hasVIP ? 'VIP: ON' : 'VIP: OFF';
                    vipBtn.style.background = hasVIP ? 'rgba(255, 215, 0, 0.4)' : 'rgba(255, 215, 0, 0.2)';
                }
                if (vipPlusBtn) {
                    vipPlusBtn.textContent = hasVIPPlus ? 'VIP+: ON' : 'VIP+: OFF';
                    vipPlusBtn.style.background = hasVIPPlus ? 'rgba(147, 112, 219, 0.4)' : 'rgba(147, 112, 219, 0.2)';
                }

                // Restore Darkshader state
                darkshaderRollTracker = data.darkshaderRollTracker || 0;
                darkshaderBuffActive = data.darkshaderBuffActive || false;
                darkshaderBuffRollsRemaining = data.darkshaderBuffRollsRemaining || 0;
                if (darkshaderBuffActive) updateDarkshaderVignette(true);

                updateRollCount();
                updateEquippedDisplay();
                updateBuffsHUD();
                syncUIFromSettings();
            } catch (e) {
                console.error("Failed to load save:", e);
            }
        }

        // --- Potion System Functions ---

        function addPotion(potionId, count = 1) {
            if (!playerInventory.potions) playerInventory.potions = {};
            if (!playerInventory.potions[potionId]) playerInventory.potions[potionId] = 0;
            playerInventory.potions[potionId] += count;

            const potion = POTIONS.find(p => p.id === potionId);
            if (potion) {
                showNotification(`Added ${count}x ${potion.name}!`, '#2ecc71');
            }

            // Always refresh if inventory panel is open
            const invPanel = document.getElementById('inventory-panel');
            if (invPanel && invPanel.classList.contains('active')) {
                populateInventory();
            }

            // Update stats panel to reflect new buffs if applicable
            updateStatsPanel();
        }

        function usePotion(potionId) {
            const potion = POTIONS.find(p => p.id === potionId);
            if (!potion) return;

            if (!userSettings.rolling.buffsEnabled) {
                showNotification('Buffs are disabled in Roll Settings.', '#ff6b6b');
                return;
            }

            if (!playerInventory.potions[potionId] || playerInventory.potions[potionId] <= 0) {
                showNotification("You don't have this potion!", '#e74c3c');
                return;
            }

            // Checks
            if (potion.unusable) {
                showNotification("This potion cannot be used.", '#e74c3c');
                return;
            }

            if (potion.requirements && potion.requirements.rolls) {
                if (playerStats.totalRolls < potion.requirements.rolls) {
                    showNotification(`Requires ${potion.requirements.rolls.toLocaleString()} rolls!`, '#e74c3c');
                    return;
                }
            }

            if (potion.biomeRequirement && currentBiome.name !== potion.biomeRequirement.toUpperCase()) {
                showNotification(`Only usable in ${potion.biomeRequirement}!`, '#e74c3c');
                return;
            }

            // Consume
            playerInventory.potions[potionId]--;

            // Apply Effect
            if (potion.type === 'random') {
                // Pick random from pool
                const pick = potion.pool[Math.floor(Math.random() * potion.pool.length)];
                // Apply as a timed buff with specific name
                const buffId = potion.id + '_' + Date.now(); // Unique ID for strange effects? or stack?
                // Request said: "Strange Potion I ... Random effect"
                // Usually strange potions grant a specific named buff.
                // We'll treat the random result as a distinct buff type?
                // "The Chosen", "The Power I", etc.
                // Let's use the effect name as the ID ref??
                // No, sticking to robust map: Potion ID Key?
                // For Strange, we should probably add a buff with the NAME of the effect.
                const effectId = pick.name.replace(/\s+/g, '_').toLowerCase();

                activeBuffs[effectId] = {
                    name: pick.name,
                    duration: potion.duration,
                    stats: pick.stats,
                    type: 'duration',
                    sourceId: potion.id
                };
                showNotification(`Applied: ${pick.name}`, '#9b59b6');

            } else if (potion.type === 'axis') {
                // 53_Axis: Snapshot current stats and duplicate them for 5 rolls
                // Calculate current total luck using OFFICIAL formula
                const currentRollSpeed = calculateTotalRollSpeed();

                // Calculate the final values using official formula: ((1 + Basic) * Bonus + Special) * VIP
                // For snapshot, we use current bonus roll state and no special buff
                const snapshotLuck = calculateLuckFromFormula(currentBonusRollMultiplier, null, false);
                const snapshotSpeed = currentRollSpeed;

                // Clear all active buffs and one-time buffs
                const clearedBuffs = Object.keys(activeBuffs).length + oneTimeBuffs.length;
                activeBuffs = {};
                oneTimeBuffs = [];

                // Create the Axis buff with DOUBLED stats
                activeBuffs['axis_potion'] = {
                    name: '53_Axis',
                    duration: 5, // 5 rolls
                    stats: {
                        // Store the doubled snapshot as a flat override
                        axisLuck: snapshotLuck * 2,
                        axisSpeed: snapshotSpeed * 2
                    },
                    type: 'roll_duration',
                    sourceId: 'axis_potion',
                    isAxis: true // Flag to identify this special buff
                };

                showNotification(`53_Axis activated! ${snapshotLuck.toFixed(1)}x luck -> ${(snapshotLuck * 2).toFixed(1)}x for 5 rolls!`, '#ff00ff');
                if (clearedBuffs > 0) {
                    showNotification(`Disabled ${clearedBuffs} buff(s)`, '#ff6b6b');
                }

            } else if (potion.type === 'one_time') {
                // Stacking rules per Sols RNG wiki:
                // - One-time buffs can queue and combine for next roll
                // - Pump King's Blood remains non-stackable

                const nonStackablePotions = ['pump_kings_blood'];

                if (nonStackablePotions.includes(potion.id)) {
                    // Check if already in queue
                    const alreadyQueued = oneTimeBuffs.some(buff => buff.sourceId === potion.id);
                    if (alreadyQueued) {
                        // Refund the potion since we already consumed it
                        playerInventory.potions[potionId]++;
                        showNotification(`${potion.name} cannot stack! Already queued.`, '#e74c3c');
                        return;
                    }
                }

                if (oneTimeBuffs.length >= MAX_ONE_TIME_BUFF_QUEUE) {
                    playerInventory.potions[potionId]++;
                    showNotification(`One-time queue limit reached (${MAX_ONE_TIME_BUFF_QUEUE}).`, '#e67e22');
                    return;
                }

                // Add to one-time queue
                oneTimeBuffs.push({
                    name: potion.name,
                    stats: potion.stats,
                    sourceId: potion.id
                });
                showNotification(`${potion.name} queued (${oneTimeBuffs.length}) for next roll!`, '#e056fd');
            } else {
                // Duration or Roll Duration
                // Stacking Logic: "Same potion types don't stack... Duration can stack"
                // Key by potion.id
                const existing = activeBuffs[potion.id];
                if (existing) {
                    existing.duration += (potion.duration || potion.durationRolls);
                    showNotification(`Extended ${potion.name} duration!`, '#2ecc71');
                } else {
                    activeBuffs[potion.id] = {
                        name: potion.name,
                        duration: (potion.duration || potion.durationRolls),
                        stats: potion.stats,
                        type: potion.type, // 'duration' or 'roll_duration'
                        sourceId: potion.id
                    };
                    showNotification(`Used ${potion.name}!`, '#2ecc71');
                }
            }

            playerStats.potionsUsed++;
            checkAchievements(); // Check for potion usage achievements
            updateStatsPanel();

            updateBuffsHUD();
            updateStatsPanel();
            populateInventory(); // Refresh counts
            saveGame(); // Ensure usage and buffs are saved immediately
        }

        // Batch use potions - more efficient for using many at once
        function usePotionsBatch(potionId, count) {
            const potion = POTIONS.find(p => p.id === potionId);
            if (!potion) return 0;

            if (!userSettings.rolling.buffsEnabled) {
                showNotification('Buffs are disabled in Roll Settings.', '#ff6b6b');
                return 0;
            }

            const available = playerInventory.potions[potionId] || 0;
            if (available <= 0) {
                showNotification("No potions available!", '#e74c3c');
                return 0;
            }

            const toUse = Math.min(count, available);
            let usedCount = 0;

            for (let i = 0; i < toUse; i++) {
                // Check if can still use (some potions may have special restrictions)
                if (!playerInventory.potions[potionId] || playerInventory.potions[potionId] <= 0) break;

                if (potion.unusable) break;
                if (potion.requirements && potion.requirements.rolls && playerStats.totalRolls < potion.requirements.rolls) break;
                if (potion.biomeRequirement && currentBiome.name !== potion.biomeRequirement.toUpperCase()) break;

                // Consume silently
                playerInventory.potions[potionId]--;

                // Apply effect (simplified for batch - many potions stack)
                if (potion.type === 'duration' || potion.type === 'roll_duration') {
                    if (!activeBuffs[potion.id]) {
                        activeBuffs[potion.id] = {
                            name: potion.name,
                            duration: (potion.duration || potion.durationRolls),
                            stats: potion.stats,
                            type: potion.type,
                            sourceId: potion.id
                        };
                    } else {
                        // Stack duration
                        activeBuffs[potion.id].duration += (potion.duration || potion.durationRolls);
                    }
                } else if (potion.type === 'one_time') {
                    // Check non-stackable one-time potions
                    const nonStackablePotions = ['pump_kings_blood'];
                    if (nonStackablePotions.includes(potion.id)) {
                        const alreadyQueued = oneTimeBuffs.some(buff => buff.sourceId === potion.id);
                        if (alreadyQueued) {
                            // Refund and stop - can't stack
                            playerInventory.potions[potionId]++;
                            break;
                        }
                    }

                    if (oneTimeBuffs.length >= MAX_ONE_TIME_BUFF_QUEUE) {
                        // Refund and stop batch to prevent excessive memory/DOM/save load
                        playerInventory.potions[potionId]++;
                        break;
                    }

                    oneTimeBuffs.push({
                        name: potion.name,
                        stats: potion.stats,
                        sourceId: potion.id
                    });
                } else if (potion.type === 'random') {
                    // Random potions - apply one random effect from the pool per use, stacking duration
                    const buffId = potion.id + '_' + Date.now() + '_' + i;
                    if (potion.pool && potion.pool.length > 0) {
                        const randomEffect = potion.pool[Math.floor(Math.random() * potion.pool.length)];
                        activeBuffs[buffId] = {
                            name: randomEffect.name || potion.name,
                            duration: potion.duration || 600,
                            stats: randomEffect.stats || {},
                            type: 'duration',
                            sourceId: potion.id
                        };
                    }
                }

                playerStats.potionsUsed++;
                usedCount++;
            }

            if (usedCount > 0) {
                showNotification(`Used ${usedCount}x ${potion.name}!`, '#2ecc71');
                checkAchievements();
                updateStatsPanel();
                updateBuffsHUD();
                populateInventory();
                saveGame();
            }

            return usedCount;
        }

        // --- Active Buffs HUD ---
        function getBuffTileColor(buff, isOneTime = false) {
            if (isOneTime) return '#cf6cff';
            const potion = POTIONS.find(p => p.id === buff.sourceId);
            if (potion && potion.rarity) return getTierColor(potion.rarity);
            return '#2ecc71';
        }

        const BUFF_TILE_ICON_BY_KEY = Object.freeze({
            'abyssal_potion': 'fa-water',
            'aquatic_potion': 'fa-fish',
            'axis_potion': 'fa-crosshairs',
            'cosmic_potion': 'fa-atom',
            'crimson_potion': 'fa-heart-crack',
            'digital_potion': 'fa-microchip',
            'divine_potion': 'fa-hands',
            'ethereal_potion': 'fa-ghost',
            'forbidden_i': 'fa-lock',
            'forbidden_ii': 'fa-key',
            'forbidden_iii': 'fa-unlock',
            'fortune_i': 'fa-star',
            'fortune_ii': 'fa-gem',
            'fortune_iii': 'fa-crown',
            'frost_potion': 'fa-snowflake',
            'gemstone::luck': 'fa-ring',
            'gemstone::speed': 'fa-feather',
            'glitched_potion': 'fa-bug',
            'godlike_potion': 'fa-dragon',
            'godly_hades': 'fa-mask',
            'godly_poseidon': 'fa-droplet',
            'godly_zeus': 'fa-bolt-lightning',
            'haste_i': 'fa-wind',
            'haste_ii': 'fa-bolt',
            'haste_iii': 'fa-jet-fighter',
            'heavenly_potion': 'fa-cloud',
            'heavenly_potion_i': 'fa-feather-pointed',
            'huge_fortune_i': 'fa-sack-dollar',
            'infernal_potion': 'fa-fire',
            'lucky_potion': 'fa-clover',
            'lunar_potion': 'fa-moon',
            'midnight_potion': 'fa-eye',
            'mystical_potion': 'fa-wand-magic-sparkles',
            'obliterate_potion': 'fa-skull-crossbones',
            'oblivion_potion': 'fa-circle-radiation',
            'pole-light-core': 'fa-lightbulb',
            'potion_of_bound': 'fa-link',
            'potion_of_dune': 'fa-mountain',
            'prismatic_potion': 'fa-rainbow',
            'pump_kings_blood': 'fa-heart',
            'question_potion': 'fa-question',
            'sakura_potion': 'fa-leaf',
            'solar_potion': 'fa-sun',
            'speed_potion': 'fa-person-running',
            'stellar_potion': 'fa-meteor',
            'strange_i::the chosen': 'fa-bullseye',
            'strange_i::the knowledge i': 'fa-book',
            'strange_i::the power i': 'fa-hand-fist',
            'strange_i::the sloth i': 'fa-hourglass-half',
            'strange_i::the wrath i': 'fa-triangle-exclamation',
            'strange_ii::godlike': 'fa-hat-wizard',
            'strange_ii::the knowledge ii': 'fa-scroll',
            'strange_ii::the power ii': 'fa-hand-sparkles',
            'strange_ii::the sloth ii': 'fa-clock',
            'strange_ii::the wrath ii': 'fa-biohazard',
            'strange_potion': 'fa-flask',
            'tempest_potion': 'fa-cloud-bolt',
            'transcendent_potion': 'fa-arrows-spin',
            'undead_potion': 'fa-skull',
            'universe_potion_i': 'fa-globe',
            'warp_potion': 'fa-rocket',
            'wild_potion': 'fa-paw'
        });
        const BUFF_TILE_DEFAULT_ICON = 'fa-question';

        function getBuffIconKey(buff) {
            const id = String((buff && buff.sourceId) || '').toLowerCase();
            const name = String((buff && buff.name) || '').toLowerCase();

            if (id === 'gemstone') {
                if (name.includes('speed')) return 'gemstone::speed';
                return 'gemstone::luck';
            }

            if (id.startsWith('strange_') && name) {
                return `${id}::${name}`;
            }

            return id || name || 'unknown';
        }

        function getBuffTileIcon(buff) {
            const key = getBuffIconKey(buff);
            return BUFF_TILE_ICON_BY_KEY[key] || BUFF_TILE_DEFAULT_ICON;
        }

        function formatBuffTileTimer(buff, isOneTime = false) {
            if (isOneTime) return 'NEXT';

            if (buff.type === 'roll_duration') {
                return `R${Math.max(0, buff.duration || 0)}`;
            }

            const total = Math.max(0, Math.floor(buff.duration || 0));
            if (total >= 3600) {
                const hours = Math.floor(total / 3600);
                const minutes = Math.floor((total % 3600) / 60);
                return `${hours}:${minutes.toString().padStart(2, '0')}`;
            }

            const minutes = Math.floor(total / 60);
            const seconds = total % 60;
            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function formatBuffEffectSummary(buff) {
            const stats = buff.stats || {};
            const parts = [];

            if (typeof stats.luck === 'number' && stats.luck !== 0) {
                const sign = stats.luck >= 0 ? '+' : '-';
                parts.push(`Luck ${sign}${Math.abs(stats.luck * 100).toFixed(0)}%`);
            }

            if (typeof stats.rollSpeed === 'number' && stats.rollSpeed !== 0) {
                const sign = stats.rollSpeed >= 0 ? '+' : '-';
                parts.push(`Roll Speed ${sign}${Math.abs(stats.rollSpeed * 100).toFixed(0)}%`);
            }

            if (typeof stats.luckFlat === 'number' && stats.luckFlat !== 0) {
                const sign = stats.luckFlat >= 0 ? '+' : '-';
                parts.push(`Luck ${sign}${Math.abs(stats.luckFlat).toLocaleString()}`);
            }

            if (Array.isArray(stats.unlockAuras) && stats.unlockAuras.length > 0) {
                const labels = stats.unlockAuras.slice(0, 2).map(a => a.toUpperCase());
                const suffix = stats.unlockAuras.length > 2 ? ` +${stats.unlockAuras.length - 2}` : '';
                parts.push(`Aura Unlock: ${labels.join(', ')}${suffix}`);
            }

            return parts.join(' • ') || 'Active buff effect';
        }

        function formatBuffRemainingText(buff, isOneTime = false) {
            if (isOneTime) return 'Applies on your next roll';
            if (buff.type === 'roll_duration') return `${Math.max(0, buff.duration || 0)} rolls remaining`;
            return `${formatTime(Math.max(0, Math.floor(buff.duration || 0)))} remaining`;
        }

        function addBuffCornerBrackets(target) {
            ['tl', 'tr', 'bl', 'br'].forEach(pos => {
                const corner = document.createElement('div');
                corner.className = `corner ${pos} active-buff-corner`;
                target.appendChild(corner);
            });
        }

        function createBuffTile(buff, isOneTime = false) {
            const tile = document.createElement('div');
            tile.className = `active-buff-tile${isOneTime ? ' one-time' : ''}`;

            const accent = getBuffTileColor(buff, isOneTime);
            tile.style.setProperty('--buff-accent', accent);

            const timerText = formatBuffTileTimer(buff, isOneTime);
            const effectText = formatBuffEffectSummary(buff);
            const remainingText = formatBuffRemainingText(buff, isOneTime);
            tile.title = isOneTime
                ? `${buff.name} (Next Roll)`
                : `${buff.name} [${timerText}]`;

            const icon = document.createElement('i');
            icon.className = `fa-solid ${getBuffTileIcon(buff)} active-buff-icon`;
            icon.setAttribute('aria-hidden', 'true');
            tile.appendChild(icon);

            const timer = document.createElement('span');
            timer.className = 'active-buff-time';
            timer.textContent = timerText;
            tile.appendChild(timer);

            const count = document.createElement('span');
            count.className = 'active-buff-stack';
            count.textContent = 'x1';
            tile.appendChild(count);

            const tooltip = document.createElement('div');
            tooltip.className = 'active-buff-tooltip';

            const title = document.createElement('div');
            title.className = 'active-buff-tooltip-title';
            title.textContent = buff.name || 'Buff';
            tooltip.appendChild(title);

            const effect = document.createElement('div');
            effect.className = 'active-buff-tooltip-effect';
            effect.textContent = effectText;
            tooltip.appendChild(effect);

            const remaining = document.createElement('div');
            remaining.className = 'active-buff-tooltip-remaining';
            remaining.textContent = remainingText;
            tooltip.appendChild(remaining);

            addBuffCornerBrackets(tooltip);
            tile.appendChild(tooltip);
            addBuffCornerBrackets(tile);

            return tile;
        }

        function createBuffSummaryTile(label, color = '#95a5a6') {
            const tile = document.createElement('div');
            tile.className = 'active-buff-tile';
            tile.style.setProperty('--buff-accent', color);
            tile.title = label;

            const icon = document.createElement('i');
            icon.className = 'fa-solid fa-layer-group active-buff-icon';
            icon.setAttribute('aria-hidden', 'true');
            tile.appendChild(icon);

            const timer = document.createElement('span');
            timer.className = 'active-buff-time';
            timer.textContent = 'INFO';
            tile.appendChild(timer);

            const count = document.createElement('span');
            count.className = 'active-buff-stack';
            count.textContent = label;
            tile.appendChild(count);

            addBuffCornerBrackets(tile);
            return tile;
        }

        function updateBuffsHUD() {
            let container = document.getElementById('active-buffs-container');
            if (!container) {
                container = document.createElement('div');
                container.id = 'active-buffs-container';
                container.className = 'active-buffs-container';
                document.querySelector('.main-container').appendChild(container); // Append to main container to sit above HUD
            } else if (!container.classList.contains('active-buffs-container')) {
                container.classList.add('active-buffs-container');
            }

            container.innerHTML = '';
            const hideHud = !!userSettings?.rolling?.hideAllBuffs;
            if (hideHud) {
                container.style.display = 'none';
                return;
            }

            const timedBuffs = Object.values(activeBuffs);
            const queuedBuffs = oneTimeBuffs;
            const totalBuffCount = timedBuffs.length + queuedBuffs.length;

            if (totalBuffCount === 0) {
                container.style.display = 'none';
                return;
            }

            // Hard safety guard: avoid generating massive buff DOM trees.
            if (totalBuffCount > 250) {
                container.appendChild(createBuffSummaryTile(`${totalBuffCount} active`, '#e67e22'));
                container.style.display = 'flex';
                return;
            }

            const maxTiles = userSettings?.performance?.maxFpsMode ? 20 : 80;
            const fragment = document.createDocumentFragment();
            let rendered = 0;

            for (let i = 0; i < timedBuffs.length && rendered < maxTiles; i++) {
                fragment.appendChild(createBuffTile(timedBuffs[i]));
                rendered++;
            }

            for (let i = 0; i < queuedBuffs.length && rendered < maxTiles; i++) {
                fragment.appendChild(createBuffTile(queuedBuffs[i], true));
                rendered++;
            }

            container.appendChild(fragment);
            const hiddenCount = totalBuffCount - rendered;
            if (hiddenCount > 0) {
                container.appendChild(createBuffSummaryTile(`+${hiddenCount} more`, '#f39c12'));
            }
            container.style.display = 'flex';
        }

        function formatTime(seconds) {
            if (seconds >= 3600) {
                const h = Math.floor(seconds / 3600);
                const m = Math.floor((seconds % 3600) / 60);
                return `${h}h ${m}m`;
            }
            const m = Math.floor(seconds / 60);
            const s = seconds % 60;
            return `${m}:${s.toString().padStart(2, '0')}`;
        }


        function syncUIFromSettings() {
            const elSkipWarnVal = document.getElementById('set-skip-warn-val');
            const elSkipWarnToggle = document.getElementById('set-skip-warn-toggle');
            const elSwapWarnVal = document.getElementById('set-swap-warn-val');
            const elSwapWarnToggle = document.getElementById('set-swap-warn-toggle');
            const elAutoEquipVal = document.getElementById('set-auto-equip-val');
            const elAutoEquipToggle = document.getElementById('set-auto-equip-toggle');
            const elSkipCutsceneVal = document.getElementById('set-skip-cutscene-val');
            const elSkipCutsceneToggle = document.getElementById('set-skip-cutscene-toggle');
            const elBuffsEnabled = document.getElementById('set-buffs-enabled');
            const elHideAllBuffs = document.getElementById('set-hide-buffs-hud');
            const elStorageWarning = document.getElementById('set-storage-warning');
            const elPlayCutscene = document.getElementById('set-play-cutscene');
            if (elSkipWarnVal) elSkipWarnVal.value = userSettings.rolling.skipWarnRarity.toLocaleString();
            if (elSkipWarnToggle) elSkipWarnToggle.checked = userSettings.rolling.skipWarnEnabled;
            if (elSwapWarnVal) elSwapWarnVal.value = userSettings.rolling.swapWarnRarity.toLocaleString();
            if (elSwapWarnToggle) elSwapWarnToggle.checked = userSettings.rolling.swapWarnEnabled;
            if (elAutoEquipVal) elAutoEquipVal.value = userSettings.rolling.autoEquipRarity.toLocaleString();
            if (elAutoEquipToggle) elAutoEquipToggle.checked = userSettings.rolling.autoEquipEnabled;
            const elAutoGearToggle = document.getElementById('set-auto-gear-toggle');
            if (elAutoGearToggle) elAutoGearToggle.checked = userSettings.rolling.autoGearEnabled || false;
            if (elSkipCutsceneVal) elSkipCutsceneVal.value = userSettings.rolling.skipCutsceneRarity.toLocaleString();
            if (elSkipCutsceneToggle) elSkipCutsceneToggle.checked = userSettings.rolling.skipCutsceneEnabled;
            if (elBuffsEnabled) elBuffsEnabled.checked = userSettings.rolling.buffsEnabled;
            if (elHideAllBuffs) elHideAllBuffs.checked = !!userSettings.rolling.hideAllBuffs;
            if (elStorageWarning) elStorageWarning.checked = userSettings.rolling.storageWarning;
            if (elPlayCutscene) elPlayCutscene.checked = userSettings.rolling.playNewAuraCutscene;
            updateRollingSettingStatusLabels();
            updateBuffsHUD();
        }

        function getTierColor(tier) {
            const colors = {
                'T-1': '#2ecc71', 'T-2': '#3498db', 'T-3': '#9b59b6', 'T-4': '#00d4ff',
                'T-5': '#f1c40f', 'T-6': '#e67e22', 'T-7': '#e74c3c', 'T-8': '#c0392b',
                'T-9': '#ff00ff', 'T-10': '#ffffff', 'Event': '#ff6b6b', 'Season Pass': '#8c7ae6',
                // Potion Rarities
                'Common': '#4a4a4a', 'Uncommon': '#2ecc71', 'Rare': '#3498db',
                'Epic': '#9b59b6', 'Legendary': '#f39c12', 'Mythic': '#e74c3c',
                'Exalted': '#ff00ff', 'Glorious': '#ff00ff', 'Transcendent': '#ffd700'
            };
            return colors[tier] || colors['T-1'];
        }

        function switchSettingsTab(tabName) {
            document.querySelectorAll('.settings-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.tab === tabName);
            });
            document.querySelectorAll('.settings-tab-content').forEach(content => {
                content.style.display = content.id === `tab-${tabName}` ? 'block' : 'none';
            });
        }

        function toggleMenu() {
            const panel = document.getElementById('menu-panel');
            const overlay = document.querySelector('.menu-overlay');
            const rollOverlay = document.getElementById('roll-overlay');
            if (panel) panel.classList.toggle('active');
            if (overlay) overlay.classList.toggle('active');
            if (panel && panel.classList.contains('active')) {
                if (rollOverlay) rollOverlay.style.visibility = 'hidden';
            } else {
                if (rollOverlay) rollOverlay.style.visibility = 'visible';
            }
        }

        function toggleSettingsPanel() {
            const panel = document.getElementById('settings-panel');
            const rollOverlay = document.getElementById('roll-overlay');
            if (!panel) return;
            panel.classList.toggle('active');
            if (panel.classList.contains('active')) {
                if (rollOverlay) rollOverlay.style.visibility = 'hidden';
            } else {
                if (rollOverlay) rollOverlay.style.visibility = 'visible';
            }
        }

        function toggleInventoryPanel() {
            const panel = document.getElementById('inventory-panel');
            const rollOverlay = document.getElementById('roll-overlay');
            if (!panel) return;
            panel.classList.toggle('active');
            if (panel.classList.contains('active')) {
                populateInventory();
                updateInventoryEquippedSlots();
                if (rollOverlay) rollOverlay.style.visibility = 'hidden';
            } else {
                if (rollOverlay) rollOverlay.style.visibility = 'visible';
            }
        }

        function toggleWorkshopPanel() {
            const panel = document.getElementById('workshop-panel');
            const rollOverlay = document.getElementById('roll-overlay');
            panel.classList.toggle('active');
            if (panel.classList.contains('active')) {
                populateWorkshopGears();
                // Hide roll overlay when modal is open
                if (rollOverlay) rollOverlay.style.visibility = 'hidden';
            } else {
                // Show roll overlay when modal is closed
                if (rollOverlay) rollOverlay.style.visibility = 'visible';
            }
        }

        function populateWorkshopGears() {
            const list = document.getElementById('workshop-list');
            if (!list) return;
            list.innerHTML = '';
            const searchQuery = document.getElementById('workshop-search').value.toLowerCase();
            GEARS.forEach(gear => {
                if (searchQuery && !gear.name.toLowerCase().includes(searchQuery)) return;
                const item = document.createElement('div');
                item.classList.add('workshop-list-item');
                if (hasOwnedGear(gear.id)) item.classList.add('crafted');
                if (selectedGear && selectedGear.id === gear.id) item.classList.add('selected');
                item.innerHTML = `
                        <div class="item-tier">${gear.tier}</div>
                        <div class="item-name" style="color: ${getTierColor(gear.tier)}">${gear.name}</div>
                        <div class="item-desc">${gear.description}</div>
                    `;
                item.addEventListener('click', () => selectGear(gear));
                list.appendChild(item);
            });
        }

        function resolveCraftRequirementToGear(materialKey) {
            if (!materialKey) return null;
            // Prefer name-based matching for existing recipes, then fall back to ID.
            const byName = GEARS.find(g => g.name === materialKey);
            if (byName && !byName.isMaterial) return byName;
            const byId = GEARS.find(g => g.id === materialKey);
            if (byId && !byId.isMaterial) return byId;
            return null;
        }

        function hasOwnedGear(gearOrId) {
            const gearId = typeof gearOrId === 'string' ? gearOrId : gearOrId?.id;
            if (!gearId) return false;
            return !!playerInventory.craftedGears[gearId] ||
                playerInventory.equipped.left === gearId ||
                playerInventory.equipped.right === gearId;
        }

        function selectGear(gear) {
            selectedGear = gear;
            document.querySelectorAll('.workshop-list-item').forEach(item => {
                item.classList.toggle('selected', item.querySelector('.item-name').textContent === gear.name);
            });
            const preview = document.getElementById('workshop-preview');
            if (preview) {
                preview.innerHTML = `
                        <div style="text-align: center; padding: 20px;">
                            <div class="item-tier" style="margin-bottom: 10px;">${gear.tier}</div>
                            <div style="font-size: 22px; font-weight: 700; margin-bottom: 10px; color: ${getTierColor(gear.tier)}">${gear.name}</div>
                            <div style="font-size: 13px; color: rgba(255,255,255,0.6); margin-bottom: 15px;">${gear.description}</div>
                            ${gear.stats ? `<div style="font-size: 14px; color: #2ecc71;">
                                ${gear.stats.luck ? `+${(gear.stats.luck * 100).toFixed(0)}% Luck ` : ''}
                                ${gear.stats.rollSpeed ? `${gear.stats.rollSpeed > 0 ? '+' : ''}${(gear.stats.rollSpeed * 100).toFixed(0)}% Roll Speed` : ''}
                            </div>` : ''}
                        </div>
                    `;
            }
            const materialsList = document.getElementById('workshop-materials');
            if (materialsList) {
                materialsList.innerHTML = '';
                if (gear.recipe) {
                    Object.entries(gear.recipe).forEach(([material, required]) => {
                        const gearRequirement = resolveCraftRequirementToGear(material);
                        const has = gearRequirement ? (hasOwnedGear(gearRequirement.id) ? 1 : 0) : (playerInventory.materials[material] || 0);
                        const row = document.createElement('div');
                        row.classList.add('material-row');
                        row.innerHTML = `
                                <span class="material-name">${material}</span>
                                <span class="material-count ${has >= required ? 'has' : 'missing'}">${has}/${required}</span>
                            `;
                        materialsList.appendChild(row);
                    });
                } else if (gear.obtain) {
                    materialsList.innerHTML = `<div style="color: rgba(255,255,255,0.5); padding: 15px; text-align: center; font-size: 12px;">${gear.obtain}</div>`;
                }
            }
            const craftBtn = document.getElementById('craft-btn');
            if (craftBtn) {
                // We use addEventListener in DOMContentLoaded for a consolidated handler
                // So we don't set onclick here anymore
                // craftBtn.onclick = () => craftGear();

                const isCrafted = playerInventory.craftedGears[gear.id];
                const isEquipped = (playerInventory.equipped.left === gear.id || playerInventory.equipped.right === gear.id);
                if (isEquipped) { craftBtn.textContent = 'Unequip'; craftBtn.disabled = false; }
                else if (isCrafted) { craftBtn.textContent = 'Equip'; craftBtn.disabled = false; }
                else { craftBtn.textContent = 'Craft'; craftBtn.disabled = !canCraft(gear.id); }
            }
        }

        function equipGear(gearId) {
            const gear = GEARS.find(g => g.id === gearId);
            if (!gear) return;
            const slot = gear.slot || 'right';
            const wasEquipped = playerInventory.equipped[slot] === gearId;

            if (wasEquipped) {
                playerInventory.equipped[slot] = null;
                // Reset Darkshader state if being unequipped
                if (gearId === 'darkshader') {
                    darkshaderRollTracker = 0;
                    darkshaderBuffActive = false;
                    darkshaderBuffRollsRemaining = 0;
                }
                if (gearId === 'unfathomable-ruins') {
                    unfathomableBuffActive = false;
                    unfathomableBuffRollsRemaining = 0;
                    if (typeof updateUnfathomableVignette === 'function') updateUnfathomableVignette(false);
                }
                if (gearId === 'chronowarden-gauntlet') {
                    chronowardenBuffActive = false;
                    chronowardenBuffRollsRemaining = 0;
                    if (typeof updateChronowardenVignette === 'function') updateChronowardenVignette(false);
                }
                if (gearId === 'cataclysm-device') {
                    cataclysmRollTracker = 0;
                    cataclysmBuffActive = false;
                    cataclysmBuffRollsRemaining = 0;
                }
                if (gearId === 'fatebreaker-device') {
                    fatebreakerRollTracker = 0;
                    fatebreakerCharged = false;
                }
            } else {
                playerInventory.equipped[slot] = gearId;
                playerInventory.craftedGears[gearId] = true;
                // Initialize Darkshader tracking if equipped
                if (gearId === 'darkshader') {
                    darkshaderRollTracker = 0;
                    darkshaderBuffActive = false;
                    darkshaderBuffRollsRemaining = 0;
                    showNotification('Darkshader equipped! Bonus roll every 5 rolls with x5 luck!', '#e056fd');
                }
                if (gearId === 'unfathomable-ruins') {
                    unfathomableBuffActive = false;
                    unfathomableBuffRollsRemaining = 0;
                    if (typeof updateUnfathomableVignette === 'function') updateUnfathomableVignette(false);
                }
                if (gearId === 'chronowarden-gauntlet') {
                    chronowardenBuffActive = false;
                    chronowardenBuffRollsRemaining = 0;
                    if (typeof updateChronowardenVignette === 'function') updateChronowardenVignette(false);
                }
                if (gearId === 'cataclysm-device') {
                    cataclysmRollTracker = 0;
                    cataclysmBuffActive = false;
                    cataclysmBuffRollsRemaining = 0;
                }
                if (gearId === 'fatebreaker-device') {
                    fatebreakerRollTracker = 0;
                    fatebreakerCharged = false;
                }
            }

            updateEquippedDisplay();
            updateRollCount(); // Update display to reflect Darkshader status
            if (selectedGear) selectGear(selectedGear);
            populateWorkshopGears();
        }

        function canCraft(gearId) {
            const gear = GEARS.find(g => g.id === gearId);
            if (!gear || !gear.recipe) return false;

            // Allow re-crafting materials, but unique gears only once
            if (!gear.isMaterial && playerInventory.craftedGears[gearId]) return false;

            for (const [material, required] of Object.entries(gear.recipe)) {
                const gearItem = resolveCraftRequirementToGear(material);
                if (gearItem) {
                    // Gear requirements are boolean ownership checks.
                    if (!hasOwnedGear(gearItem.id)) return false;
                } else {
                    // It's a material requirement
                    const has = playerInventory.materials[material] || 0;
                    if (has < required) return false;
                }
            }
            return true;
        }

        function craftGear(gearId = null) {
            const gearToCraft = gearId ? GEARS.find(g => g.id === gearId) : selectedGear;

            if (!gearToCraft) return;

            // Handle equip/unequip for already crafted gears
            const isCrafted = playerInventory.craftedGears[gearToCraft.id];
            if (isCrafted && !gearToCraft.isMaterial) {
                // If called via auto-gear (gearId present), we don't toggle equip, we just ensure it's equipped if it's better?
                // Actually the request just said "auto craft". "so i can just idle".
                // Usually auto-progression implies auto-equipping too if it's better.
                // For now, let's stick to crafting. The user can use "Auto Equip" setting for auras, but for gear?
                // If I auto-craft a T10 gear, I probably want to equip it.
                // Let's checking if we are manually clicking or auto-crafting.
                if (!gearId) equipGear(gearToCraft.id);
                return;
            }

            if (!canCraft(gearToCraft.id)) return;

            // Deduct recipe (materials and gears)
            for (const [material, required] of Object.entries(gearToCraft.recipe)) {
                const gearItem = resolveCraftRequirementToGear(material);
                if (gearItem) {
                    // Remove the crafted gear from inventory (consumed in crafting)
                    delete playerInventory.craftedGears[gearItem.id];
                    // Also unequip if it was equipped
                    if (playerInventory.equipped.left === gearItem.id) {
                        playerInventory.equipped.left = null;
                        if (gearItem.id === 'darkshader') { // cleanup darkshader
                            darkshaderBuffActive = false;
                            updateRollCount();
                        }
                    }
                    if (playerInventory.equipped.right === gearItem.id) {
                        playerInventory.equipped.right = null;
                        if (gearItem.id === 'darkshader') { // cleanup darkshader
                            darkshaderBuffActive = false;
                            updateRollCount();
                        }
                    }
                } else {
                    // Deduct material
                    playerInventory.materials[material] -= required;
                }
            }

            if (gearToCraft.isMaterial) {
                addMaterial(gearToCraft.name, 1);
                // Notification handled in addMaterial? No, addMaterial shows notification for auto-deposit.
                // explicit craft shows notification here.
                if (!gearId) showNotification(`Successfully crafted ${gearToCraft.name}!`, getTierColor(gearToCraft.tier));
            } else {
                playerInventory.craftedGears[gearToCraft.id] = true;
                playerStats.gearsCrafted++;
                showNotification(`Successfully crafted ${gearToCraft.name}!`, getTierColor(gearToCraft.tier));

                // Auto-equip if it's a gear and we aren't wearing anything or it's an upgrade?
                // Simple logic: If slot is empty, equip.
                // If auto-gear is enabled, maybe we should aggressively equip highest tier?
                // Let's strict to just crafting for now unless requested.
                // Wait, "auto gear progession" implies using it.
                // I will auto-equip if the slot is empty or if the new gear is higher tier than current.

                // Actually, let's just use the existing equipGear function which warns/notifies
                // But only if we auto-crafted it (gearId present) or manual? 
                // Manual craft calls equipGear via the initial check if isCrafted, but here we just finished crafting.
                if (userSettings.rolling.autoGearEnabled || !gearId) {
                    // Check gear stats comparison (luck + speed score)
                    const slot = gearToCraft.slot || 'right';
                    const currentId = playerInventory.equipped[slot];
                    const currentGear = currentId ? GEARS.find(g => g.id === currentId) : null;

                    // Helper to calculate gear score based on luck and roll speed
                    const getGearScore = (gear) => {
                        if (!gear || !gear.stats) return 0;
                        const luck = gear.stats.luck || 0;
                        const speed = gear.stats.rollSpeed || 0;
                        // Weight luck and speed equally (speed is typically 0-1, luck is 0-12)
                        // Normalize speed by multiplying by 10 to make it comparable
                        return luck + (speed * 10);
                    };

                    const newScore = getGearScore(gearToCraft);
                    const currentScore = getGearScore(currentGear);

                    if (!currentGear || newScore > currentScore) {
                        equipGear(gearToCraft.id);
                    }
                }
            }

            updateStatsPanel();
            populateWorkshopGears();
            if (selectedGear && selectedGear.id === gearToCraft.id) selectGear(gearToCraft);
            updateEquippedDisplay(); // Update HUD
        }

        // Auto Gear Progression Check
        function checkAutoGear() {
            if (!userSettings.rolling.autoGearEnabled) return;

            // Sort gears by Tier descending (best first)
            // We want to craft the BEST possible gear we can right now.
            // Filter to only gears we don't have.
            const craftableGears = GEARS.filter(g =>
                !g.isMaterial &&
                !playerInventory.craftedGears[g.id] &&
                canCraft(g.id)
            ).sort((a, b) => {
                const ta = parseInt(a.tier.replace('T-', '')) || 0;
                const tb = parseInt(b.tier.replace('T-', '')) || 0;
                return tb - ta;
            });

            if (craftableGears.length > 0) {
                // Craft the best one
                craftGear(craftableGears[0].id);
            }
        }

        // ========== ITEMS TAB (POTION CRAFTING) ==========
        let selectedPotion = null;

        function populateWorkshopItems() {
            const list = document.getElementById('workshop-list');
            if (!list) return;
            list.innerHTML = '';
            const searchQuery = document.getElementById('workshop-search').value.toLowerCase();

            // Filter to only craftable potions
            const craftablePotions = POTIONS.filter(p => p.craftable);

            craftablePotions.forEach(potion => {
                if (searchQuery && !potion.name.toLowerCase().includes(searchQuery)) return;
                const item = document.createElement('div');
                item.classList.add('workshop-list-item');
                if (selectedPotion && selectedPotion.id === potion.id) item.classList.add('selected');

                // Get rarity color
                const rarityColors = {
                    'Common': '#4a4a4a',
                    'Uncommon': '#2ecc71',
                    'Rare': '#3498db',
                    'Epic': '#9b59b6',
                    'Legendary': '#f39c12',
                    'Mythic': '#e74c3c',
                    'Exalted': '#ff00ff'
                };
                const color = rarityColors[potion.rarity] || '#ffffff';

                item.innerHTML = `
                    <div class="item-tier" style="background: ${color};">${potion.rarity}</div>
                    <div class="item-name" style="color: ${color}">${potion.name}</div>
                    <div class="item-desc">${potion.description}</div>
                `;
                item.addEventListener('click', () => selectPotion(potion));
                list.appendChild(item);
            });

            // Also show chest/material inventory entries without overriding potion crafting UI.
            appendWorkshopChestAndMaterials(list, searchQuery);
        }

        function selectPotion(potion) {
            selectedPotion = potion;
            selectedGear = null; // Clear gear selection

            document.querySelectorAll('.workshop-list-item').forEach(item => {
                item.classList.toggle('selected', item.querySelector('.item-name').textContent === potion.name);
            });

            const rarityColors = {
                'Common': '#4a4a4a',
                'Uncommon': '#2ecc71',
                'Rare': '#3498db',
                'Epic': '#9b59b6',
                'Legendary': '#f39c12',
                'Mythic': '#e74c3c',
                'Exalted': '#ff00ff'
            };
            const color = rarityColors[potion.rarity] || '#ffffff';

            const preview = document.getElementById('workshop-preview');
            if (preview) {
                let statsText = '';
                if (potion.stats) {
                    if (potion.stats.luck) statsText += `+${(potion.stats.luck * 100).toFixed(0)}% Luck `;
                    if (potion.stats.rollSpeed) statsText += `+${(potion.stats.rollSpeed * 100).toFixed(0)}% Roll Speed `;
                    if (potion.stats.luckFlat) statsText += `+${potion.stats.luckFlat.toLocaleString()} Luck `;
                }
                const durationText = potion.type === 'one_time' ? '1 roll' : `${potion.duration}s`;

                preview.innerHTML = `
                    <div style="text-align: center; padding: 20px;">
                        <div class="item-tier" style="margin-bottom: 10px; background: ${color};">${potion.rarity}</div>
                        <div style="font-size: 22px; font-weight: 700; margin-bottom: 10px; color: ${color}">${potion.name}</div>
                        <div style="font-size: 13px; color: rgba(255,255,255,0.6); margin-bottom: 15px;">${potion.description}</div>
                        ${statsText ? `<div style="font-size: 14px; color: #2ecc71;">${statsText}</div>` : ''}
                        <div style="font-size: 12px; color: rgba(255,255,255,0.5); margin-top: 5px;">Duration: ${durationText}</div>
                    </div>
                `;
            }

            const materialsList = document.getElementById('workshop-materials');
            if (materialsList) {
                materialsList.innerHTML = '';
                if (potion.recipe) {
                    console.log('Potion recipe:', potion.recipe); // Debug

                    // Add header
                    const header = document.createElement('div');
                    header.style.cssText = 'padding: 10px; color: #f39c12; font-weight: bold; font-size: 14px; border-bottom: 1px solid rgba(255,255,255,0.1); margin-bottom: 10px;';
                    header.textContent = 'Required Materials';
                    materialsList.appendChild(header);

                    const entries = Object.entries(potion.recipe);
                    console.log('Recipe entries:', entries); // Debug

                    for (const [material, required] of entries) {
                        console.log('Processing material:', material, required); // Debug

                        // Check if it's a potion requirement or material
                        const potionReq = POTIONS.find(p => p.name === material);
                        let has = 0;

                        if (potionReq) {
                            // Count potions in inventory (potions is an object: { potion_id: count })
                            has = playerInventory.potions[potionReq.id] || 0;
                        } else {
                            // It's a material/aura
                            has = playerInventory.materials[material] || 0;
                        }

                        const row = document.createElement('div');
                        row.classList.add('material-row');
                        row.innerHTML = `
                            <span class="material-name">${material}</span>
                            <span class="material-count ${has >= required ? 'has' : 'missing'}">${has}/${required}</span>
                        `;
                        materialsList.appendChild(row);
                    }
                } else if (potion.obtainedFrom) {
                    materialsList.innerHTML = `<div style="color: rgba(255,255,255,0.5); padding: 15px; text-align: center; font-size: 12px;">${potion.obtainedFrom}</div>`;
                } else {
                    materialsList.innerHTML = `<div style="color: rgba(255,255,255,0.4); padding: 15px; text-align: center; font-size: 12px;">No crafting recipe available</div>`;
                }
            }

            const craftBtn = document.getElementById('craft-btn');
            if (craftBtn) {
                craftBtn.textContent = 'Craft';
                craftBtn.disabled = !canCraftPotion(potion.id);
            }
        }

        function canCraftPotion(potionId) {
            const potion = POTIONS.find(p => p.id === potionId);
            if (!potion || !potion.recipe) return false;

            for (const [material, required] of Object.entries(potion.recipe)) {
                // Check if it's a potion requirement
                const potionReq = POTIONS.find(p => p.name === material);

                if (potionReq) {
                    // Count potions in inventory (object: { potion_id: count })
                    const has = playerInventory.potions[potionReq.id] || 0;
                    if (has < required) return false;
                } else {
                    // It's a material/aura
                    const has = playerInventory.materials[material] || 0;
                    if (has < required) return false;
                }
            }
            return true;
        }

        function craftPotion() {
            if (!selectedPotion || !canCraftPotion(selectedPotion.id)) return;

            // Deduct recipe materials
            for (const [material, required] of Object.entries(selectedPotion.recipe)) {
                const potionReq = POTIONS.find(p => p.name === material);

                if (potionReq) {
                    // Remove potions from inventory (object: { potion_id: count })
                    playerInventory.potions[potionReq.id] = (playerInventory.potions[potionReq.id] || 0) - required;
                    if (playerInventory.potions[potionReq.id] <= 0) {
                        delete playerInventory.potions[potionReq.id];
                    }
                } else {
                    // Deduct material
                    playerInventory.materials[material] -= required;
                }
            }

            // Add crafted potion to inventory (object: { potion_id: count })
            playerInventory.potions[selectedPotion.id] = (playerInventory.potions[selectedPotion.id] || 0) + 1;

            const rarityColors = {
                'Common': '#4a4a4a',
                'Uncommon': '#2ecc71',
                'Rare': '#3498db',
                'Epic': '#9b59b6',
                'Legendary': '#f39c12',
                'Mythic': '#e74c3c',
                'Exalted': '#ff00ff'
            };

            showNotification(`Crafted ${selectedPotion.name}!`, rarityColors[selectedPotion.rarity] || '#2ecc71');

            // Update inventory display
            updatePotionInventoryDisplay();

            // Refresh the preview to update available materials
            selectPotion(selectedPotion);
        }

        let autoDepositGear = null; // The gear we're auto-depositing materials for

        function toggleAutoDeposit() {
            const autoBtn = document.getElementById('auto-btn');

            // If clicking on the same gear that's already auto, turn it off
            if (autoDepositGear && selectedGear && autoDepositGear.id === selectedGear.id) {
                autoDepositGear = null;
                autoBtn.textContent = 'Auto';
                autoBtn.classList.remove('active');
                showNotification('Auto-deposit disabled', '#ff6b6b');
                return;
            }

            // Start auto-depositing for selected gear (turns off any previous)
            if (!selectedGear) {
                showNotification('Select an item first!', '#ff6b6b');
                return;
            }

            if (!selectedGear.recipe) {
                showNotification('This item cannot be crafted!', '#ff6b6b');
                return;
            }

            // Switch to new gear (automatically replaces old one)
            autoDepositGear = selectedGear;
            autoBtn.textContent = 'Stop';
            autoBtn.classList.add('active');
            showNotification(`Auto-deposit enabled for ${selectedGear.name}`, getTierColor(selectedGear.tier));
        }

        // Called when an aura is rolled to check if we should notify about auto-deposit
        function checkAutoDeposit(auraName) {
            if (!autoDepositGear || !autoDepositGear.recipe) return;

            // Check if this aura is needed for the auto-deposit gear
            if (autoDepositGear.recipe[auraName]) {
                const has = playerInventory.materials[auraName] || 0;
                const required = autoDepositGear.recipe[auraName];

                if (has <= required) {
                    showNotification(`${auraName} added for ${autoDepositGear.name} (${has}/${required})`, getTierColor(autoDepositGear.tier));
                }

                // Check if we can now craft it
                if (canCraft(autoDepositGear.id)) {
                    showNotification(`Ready to craft ${autoDepositGear.name}!`, '#2ecc71');
                }
            }
        }
function getAuraStorageCapacityForLevel(level = 0) {
            return AURA_STORAGE_BASE_CAPACITY + (Math.max(0, level) * AURA_STORAGE_CAPACITY_STEP);
        }

        function getAuraStorageUpgradeCost(level = 0) {
            const tier = Math.max(0, level) + 1;
            return Math.floor(1500 + (tier * tier * 850));
        }

        function ensureAuraStorageState() {
            if (!playerInventory.auraStorage || typeof playerInventory.auraStorage !== 'object') {
                playerInventory.auraStorage = {};
            }
            const storage = playerInventory.auraStorage;
            storage.level = Number.isFinite(storage.level) ? Math.max(0, Math.floor(storage.level)) : 0;
            const formulaCapacity = getAuraStorageCapacityForLevel(storage.level);
            const savedCapacity = Number.isFinite(storage.capacity) ? Math.max(1, Math.floor(storage.capacity)) : formulaCapacity;
            storage.capacity = Math.max(formulaCapacity, savedCapacity);
            storage.nextId = Number.isFinite(storage.nextId) ? Math.max(1, Math.floor(storage.nextId)) : 1;
            storage.items = Array.isArray(storage.items) ? storage.items : [];

            storage.items = storage.items
                .filter(item => item && item.auraId && item.name)
                .map(item => ({
                    uid: item.uid || `as-${storage.nextId++}`,
                    auraId: item.auraId,
                    name: item.name,
                    displayChance: Number.isFinite(item.displayChance) ? Math.max(1, Math.floor(item.displayChance)) : Math.max(1, Math.floor(item.chance || 1)),
                    chance: Number.isFinite(item.chance) ? Math.max(1, Math.floor(item.chance)) : Math.max(1, Math.floor(item.displayChance || 1)),
                    luckAtRoll: Number.isFinite(item.luckAtRoll) ? Math.max(1, Math.floor(item.luckAtRoll)) : 1,
                    rollAt: Number.isFinite(item.rollAt) ? Math.max(0, Math.floor(item.rollAt)) : 0,
                    timestamp: Number.isFinite(item.timestamp) ? item.timestamp : Date.now(),
                    biome: item.biome || 'NORMAL',
                    special: !!item.special,
                    locked: !!item.locked,
                    color: item.color || '#fff',
                    gradient: item.gradient || null,
                    fontFamily: item.fontFamily || null,
                    fontWeight: item.fontWeight || null,
                    fontStyle: item.fontStyle || null,
                    letterSpacing: item.letterSpacing || null,
                    textTransform: item.textTransform || null
                }));

            // Never allow capacity to fall below current stored item count.
            // This prevents capacity shrinking when deleting from migrated saves.
            storage.capacity = Math.max(storage.capacity, storage.items.length);
            return storage;
        }

        function getAuraStorageEntryByUid(uid) {
            if (!uid) return null;
            const storage = ensureAuraStorageState();
            return storage.items.find(item => item.uid === uid) || null;
        }

        function getAuraStorageDisplayChance(entry) {
            if (!entry) return 1;
            return Math.max(1, Math.floor(entry.displayChance || entry.chance || 1));
        }

        function applyAuraStorageStyling(element, entry) {
            if (!element || !entry) return;
            const aura = getAuraById(entry.auraId);
            if (aura) {
                applyAuraStyling(element, aura);
                return;
            }
            const styleAura = {
                color: entry.color || '#fff',
                gradient: entry.gradient || null,
                fontFamily: entry.fontFamily || null,
                fontWeight: entry.fontWeight || null,
                fontStyle: entry.fontStyle || null,
                letterSpacing: entry.letterSpacing || null,
                textTransform: entry.textTransform || null
            };
            applyAuraStyling(element, styleAura);
        }

        function updateAuraStorageDetails() {
            const equipBtn = document.getElementById('aura-storage-equip-btn');
            const deleteBtn = document.getElementById('aura-storage-delete-btn');
            const lockBtn = document.getElementById('aura-storage-lock-btn');
            const previewName = document.getElementById('aura-storage-preview-name');
            const previewChance = document.getElementById('aura-storage-preview-chance');
            const infoRolls = document.getElementById('aura-storage-info-rolls');
            const infoLuck = document.getElementById('aura-storage-info-luck');
            const infoTime = document.getElementById('aura-storage-info-time');
            const infoBiome = document.getElementById('aura-storage-info-biome');

            const selected = getAuraStorageEntryByUid(selectedAuraStorageUid);
            if (!selected) {
                selectedAuraStorageUid = null;
                previewName.textContent = 'No Aura Selected';
                previewChance.textContent = '1/1';
                previewName.removeAttribute('style');
                infoRolls.textContent = 'Rolled at: -';
                infoLuck.textContent = 'With luck of: -';
                infoTime.textContent = 'Time Discovered: -';
                infoBiome.textContent = 'Biome: -';
                if (equipBtn) equipBtn.disabled = true;
                if (deleteBtn) deleteBtn.disabled = true;
                if (lockBtn) {
                    lockBtn.disabled = true;
                    lockBtn.textContent = 'Lock';
                }
                return;
            }

            previewName.textContent = selected.name;
            previewChance.textContent = `1/${getAuraStorageDisplayChance(selected).toLocaleString()}`;
            applyAuraStorageStyling(previewName, selected);
            infoRolls.textContent = `Rolled at: ${selected.rollAt.toLocaleString()} Rolls`;
            infoLuck.textContent = `With luck of: ${selected.luckAtRoll.toLocaleString()}`;
            infoTime.textContent = `Time Discovered: ${new Date(selected.timestamp).toLocaleString()}`;
            infoBiome.textContent = `Biome: ${selected.biome || 'NORMAL'}`;

            if (equipBtn) equipBtn.disabled = false;
            if (deleteBtn) deleteBtn.disabled = !!selected.locked;
            if (lockBtn) {
                lockBtn.disabled = false;
                lockBtn.textContent = selected.locked ? 'Unlock' : 'Lock';
            }
        }

        function renderAuraStorageGrid() {
            const grid = document.getElementById('aura-storage-grid');
            const searchInput = document.getElementById('aura-storage-search');
            if (!grid) return;

            const storage = ensureAuraStorageState();
            const query = ((searchInput && searchInput.value) || '').trim().toLowerCase();
            const wantsSpecial = auraStorageActiveTab === 'special';
            const filtered = storage.items
                .filter(item => (!!item.special) === wantsSpecial)
                .filter(item => !query || (item.name || '').toLowerCase().includes(query))
                .sort((a, b) => {
                    const chanceDiff = getAuraStorageDisplayChance(b) - getAuraStorageDisplayChance(a);
                    if (chanceDiff !== 0) return chanceDiff;
                    return (b.timestamp || 0) - (a.timestamp || 0);
                });

            if (selectedAuraStorageUid && !storage.items.some(item => item.uid === selectedAuraStorageUid)) {
                selectedAuraStorageUid = null;
            }

            grid.innerHTML = '';

            if (filtered.length === 0) {
                const empty = document.createElement('div');
                empty.className = 'aura-storage-empty';
                empty.textContent = 'No auras in this tab.';
                grid.appendChild(empty);
                updateAuraStorageDetails();
                return;
            }

            filtered.forEach(entry => {
                const itemEl = document.createElement('div');
                itemEl.className = 'aura-storage-item';
                if (entry.uid === selectedAuraStorageUid) itemEl.classList.add('selected');
                if (entry.locked) itemEl.classList.add('locked');
                itemEl.title = `${entry.name} [1/${getAuraStorageDisplayChance(entry).toLocaleString()}]`;

                const auraNameEl = document.createElement('div');
                auraNameEl.className = 'aura-storage-item-name';
                auraNameEl.textContent = entry.name;
                applyAuraStorageStyling(auraNameEl, entry);

                const chanceEl = document.createElement('div');
                chanceEl.className = 'aura-storage-item-chance';
                chanceEl.textContent = `1/${getAuraStorageDisplayChance(entry).toLocaleString()}`;

                itemEl.appendChild(auraNameEl);
                itemEl.appendChild(chanceEl);
                itemEl.addEventListener('click', () => {
                    selectedAuraStorageUid = entry.uid;
                    renderAuraStorageGrid();
                    updateAuraStorageDetails();
                });
                grid.appendChild(itemEl);
            });
        }

        function populateAuraStoragePanel() {
            const storage = ensureAuraStorageState();
            const regularTab = document.getElementById('aura-storage-tab-regular');
            const specialTab = document.getElementById('aura-storage-tab-special');
            const upgradeCostEl = document.getElementById('aura-storage-upgrade-cost');
            const upgradeBtn = document.getElementById('aura-storage-upgrade-btn');

            const regularCount = storage.items.filter(item => !item.special).length;
            const specialCount = storage.items.filter(item => item.special).length;
            const nextCost = getAuraStorageUpgradeCost(storage.level);

            if (regularTab) regularTab.textContent = `Regular [ ${regularCount} / ${storage.capacity} ]`;
            if (specialTab) specialTab.textContent = `Special [ ${specialCount} ]`;

            document.querySelectorAll('.aura-storage-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.tab === auraStorageActiveTab);
            });

            if (upgradeCostEl) {
                upgradeCostEl.textContent = `${nextCost.toLocaleString()} Coins`;
            }
            if (upgradeBtn) {
                upgradeBtn.textContent = `Upgrade (+${AURA_STORAGE_CAPACITY_STEP})`;
            }

            renderAuraStorageGrid();
            updateAuraStorageDetails();
        }

        function toggleAuraStoragePanel() {
            const panel = document.getElementById('aura-storage-panel');
            const rollOverlay = document.getElementById('roll-overlay');
            if (!panel) return;
            panel.classList.toggle('active');
            if (panel.classList.contains('active')) {
                populateAuraStoragePanel();
                if (rollOverlay) rollOverlay.style.visibility = 'hidden';
            } else {
                if (rollOverlay) rollOverlay.style.visibility = 'visible';
            }
        }

        function buildAuraStorageEntryData(aura, rolledLuck = null) {
            if (!aura) return null;
            const displayChance = Math.max(1, getAuraEffectiveChance(aura) || aura.chance || 1);
            const luckSnapshot = Number.isFinite(rolledLuck)
                ? Math.max(1, Math.floor(rolledLuck))
                : Math.max(1, Math.floor(calculateLuckFromFormula(currentBonusRollMultiplier, null, false)));
            const isSpecial = !!aura.ignoreLuck || (typeof isSpecialPotionAura === 'function' && isSpecialPotionAura(aura.id));

            return {
                auraId: aura.id,
                name: aura.name,
                displayChance: Math.floor(displayChance),
                chance: Math.max(1, Math.floor(aura.chance || displayChance)),
                luckAtRoll: luckSnapshot,
                rollAt: playerStats.totalRolls,
                timestamp: Date.now(),
                biome: currentBiome ? currentBiome.name : 'NORMAL',
                special: isSpecial,
                locked: false,
                color: aura.color || '#fff',
                gradient: aura.gradient || null,
                fontFamily: aura.fontFamily || null,
                fontWeight: aura.fontWeight || null,
                fontStyle: aura.fontStyle || null,
                letterSpacing: aura.letterSpacing || null,
                textTransform: aura.textTransform || null
            };
        }

        function hideStorageFullPopup() {
            const popup = document.getElementById('storage-full-popup');
            if (popup) popup.classList.remove('active');
            pendingStorageFullRoll = null;
        }

        function showStorageFullPopup(entryData) {
            if (!entryData) return;
            pendingStorageFullRoll = entryData;

            const popup = document.getElementById('storage-full-popup');
            const desc = document.getElementById('storage-full-desc');
            if (!popup || !desc) return;

            desc.textContent = `You rolled ${entryData.name} [1/${entryData.displayChance.toLocaleString()}]. Storage is full. Replace your most recent aura or delete this rolled aura?`;
            popup.classList.add('active');

            // Pause rolling so the decision prompt is not skipped.
            if (autoRollInterval) {
                clearInterval(autoRollInterval);
                autoRollInterval = null;
                const autoBtn = document.getElementById('auto-roll');
                const autoSpan = document.querySelector('#auto-roll span');
                if (autoSpan) autoSpan.textContent = 'Auto Roll : Off';
                if (autoBtn) autoBtn.setAttribute('aria-pressed', 'false');
            }
            if (quickRollMode) {
                quickRollMode = false;
                const quickBtn = document.getElementById('quick-roll');
                const quickSpan = document.querySelector('#quick-roll span');
                if (quickSpan) quickSpan.textContent = 'Quick Roll : Off';
                if (quickBtn) quickBtn.setAttribute('aria-pressed', 'false');
            }
        }

        function replaceMostRecentStorageAuraFromPrompt() {
            if (!pendingStorageFullRoll) return;
            const pendingEntry = { ...pendingStorageFullRoll };
            const storage = ensureAuraStorageState();

            // If space opened up meanwhile, just add the pending aura.
            if (storage.items.length < storage.capacity) {
                storage.items.push({
                    uid: `as-${storage.nextId++}`,
                    ...pendingEntry
                });
                hideStorageFullPopup();
                if (document.getElementById('aura-storage-panel')?.classList.contains('active')) {
                    populateAuraStoragePanel();
                }
                showNotification(`Stored ${pendingEntry.name}.`, '#2ecc71');
                saveGame();
                return;
            }

            let replaceIndex = -1;
            let newestTs = -Infinity;
            for (let i = 0; i < storage.items.length; i++) {
                const item = storage.items[i];
                if (item.locked) continue;
                const ts = Number.isFinite(item.timestamp) ? item.timestamp : 0;
                if (ts >= newestTs) {
                    newestTs = ts;
                    replaceIndex = i;
                }
            }

            if (replaceIndex === -1) {
                showNotification('All stored auras are locked. Unlock one or delete this roll.', '#ff6b6b');
                return;
            }

            const replacedName = storage.items[replaceIndex].name;
            storage.items[replaceIndex] = {
                uid: `as-${storage.nextId++}`,
                ...pendingEntry
            };
            selectedAuraStorageUid = null;
            hideStorageFullPopup();

            if (document.getElementById('aura-storage-panel')?.classList.contains('active')) {
                populateAuraStoragePanel();
            }
            showNotification(`Replaced ${replacedName} with ${pendingEntry.name}.`, '#2ecc71');
            saveGame();
        }

        function discardRolledAuraFromPrompt() {
            if (!pendingStorageFullRoll) return;
            const discardedName = pendingStorageFullRoll.name;
            hideStorageFullPopup();
            showNotification(`${discardedName} discarded.`, '#ff6b6b');
        }

        function addAuraToStorage(aura, rolledLuck = null) {
            if (!aura || aura.id === 'nothing') return false;

            const entryData = buildAuraStorageEntryData(aura, rolledLuck);
            if (!entryData) return false;

            // Apply storage rarity gate only when Auto Equip is enabled.
            if (userSettings?.rolling?.autoEquipEnabled) {
                const minStorageRarity = parseInt(userSettings?.rolling?.autoEquipRarity || 0, 10) || 0;
                if (entryData.displayChance < minStorageRarity) {
                    return false;
                }
            }

            const storage = ensureAuraStorageState();
            if (storage.items.length >= storage.capacity) {
                if (userSettings.rolling.storageWarning && Date.now() - lastAuraStorageWarningAt > 3500) {
                    lastAuraStorageWarningAt = Date.now();
                    showStorageFullPopup(entryData);
                } else {
                    showStorageFullPopup(entryData);
                }
                return false;
            }

            storage.items.push({
                uid: `as-${storage.nextId++}`,
                ...entryData
            });

            if (document.getElementById('aura-storage-panel')?.classList.contains('active')) {
                populateAuraStoragePanel();
            }
            return true;
        }

        function equipSelectedStorageAura() {
            const selected = getAuraStorageEntryByUid(selectedAuraStorageUid);
            if (!selected) {
                showNotification('Select an aura first.', '#ff6b6b');
                return;
            }
            const aura = getAuraById(selected.auraId);
            if (!aura) {
                showNotification('This aura no longer exists in data.', '#ff6b6b');
                return;
            }
            if (tryAutoEquipAura(aura, 'Aura Storage')) {
                showNotification(`Equipped ${aura.name}`, aura.color || '#4a9eff');
                saveGame();
            }
        }

        function toggleLockSelectedStorageAura() {
            const selected = getAuraStorageEntryByUid(selectedAuraStorageUid);
            if (!selected) {
                showNotification('Select an aura first.', '#ff6b6b');
                return;
            }
            selected.locked = !selected.locked;
            showNotification(`${selected.name} ${selected.locked ? 'locked' : 'unlocked'}.`, selected.locked ? '#4a9eff' : '#2ecc71');
            updateAuraStorageDetails();
            renderAuraStorageGrid();
            saveGame();
        }

        function deleteSelectedStorageAura() {
            const storage = ensureAuraStorageState();
            const selected = getAuraStorageEntryByUid(selectedAuraStorageUid);
            if (!selected) {
                showNotification('Select an aura first.', '#ff6b6b');
                return;
            }
            if (selected.locked) {
                showNotification('Unlock this aura before deleting it.', '#ff6b6b');
                return;
            }
            if (!confirm(`Delete ${selected.name} from Aura Storage?`)) return;

            storage.items = storage.items.filter(item => item.uid !== selected.uid);
            selectedAuraStorageUid = null;
            populateAuraStoragePanel();
            saveGame();
        }

        function upgradeAuraStorageCapacity() {
            const storage = ensureAuraStorageState();
            const cost = getAuraStorageUpgradeCost(storage.level);
            const coins = playerAchievements.coins || 0;
            if (coins < cost) {
                showNotification(`Need ${cost.toLocaleString()} coins (You have ${coins.toLocaleString()}).`, '#ff6b6b');
                return;
            }

            playerAchievements.coins -= cost;
            storage.level += 1;
            storage.capacity = Math.max(
                storage.capacity + AURA_STORAGE_CAPACITY_STEP,
                getAuraStorageCapacityForLevel(storage.level)
            );
            showNotification(`Aura Storage upgraded to ${storage.capacity} slots!`, '#2ecc71');
            populateAuraStoragePanel();
            saveGame();
        }

        function populateInventory() {
            const list = document.getElementById('inventory-gear-list');
            const searchQuery = document.getElementById('inventory-search').value.toLowerCase();
            list.innerHTML = '';

            // Check active tab from the main inventory tabs (in HTML)
            const activeTab = document.querySelector('.inventory-tabs .inventory-tab.active');
            const mode = activeTab ? activeTab.dataset.tab : 'gears';

            if (mode === 'potions') {
                populateInventoryPotions(list, searchQuery);
                return;
            }

            // --- GEARS LOGIC ---
            // Get crafted gears separated by slot
            const rightGears = GEARS.filter(g =>
                playerInventory.craftedGears[g.id] &&
                (g.slot === 'right' || !g.slot) &&
                !g.isMaterial &&
                (!searchQuery || g.name.toLowerCase().includes(searchQuery))
            );
            const leftGears = GEARS.filter(g =>
                playerInventory.craftedGears[g.id] &&
                g.slot === 'left' &&
                !g.isMaterial &&
                (!searchQuery || g.name.toLowerCase().includes(searchQuery))
            );

            // Right Gear Section
            if (rightGears.length > 0 || !searchQuery) {
                const rightTitle = document.createElement('div');
                rightTitle.classList.add('gear-section-title');
                rightTitle.textContent = 'Right Gear';
                list.appendChild(rightTitle);

                const rightGrid = document.createElement('div');
                rightGrid.classList.add('gear-grid');
                rightGears.forEach(gear => {
                    rightGrid.appendChild(createGearItem(gear, 'right'));
                });
                list.appendChild(rightGrid);
            }

            // Left Gear Section
            if (leftGears.length > 0 || !searchQuery) {
                const leftTitle = document.createElement('div');
                leftTitle.classList.add('gear-section-title');
                leftTitle.textContent = 'Left Gear';
                list.appendChild(leftTitle);

                const leftGrid = document.createElement('div');
                leftGrid.classList.add('gear-grid');
                leftGears.forEach(gear => {
                    leftGrid.appendChild(createGearItem(gear, 'left'));
                });
                list.appendChild(leftGrid);
            }

            if (rightGears.length === 0 && leftGears.length === 0) {
                list.innerHTML = '<div style="text-align: center; padding: 40px; color: rgba(255,255,255,0.4);">No crafted gears yet.<br>Craft gears in the Workshop!</div>';
            }
        }

        function populateInventoryPotions(list, searchQuery) {
            const userPotions = POTIONS.filter(p =>
                playerInventory.potions && playerInventory.potions[p.id] > 0 &&
                (!searchQuery || p.name.toLowerCase().includes(searchQuery))
            );

            if (userPotions.length === 0) {
                list.innerHTML = '<div style="text-align: center; padding: 40px; color: rgba(255,255,255,0.4);">No potions.<br>Find them by rolling!</div>';
                return;
            }

            // Add a compact header
            const header = document.createElement('div');
            header.style.cssText = `
                padding: 6px 10px; background: rgba(224, 86, 253, 0.1); border-radius: 4px; 
                margin-bottom: 8px; border: 1px solid rgba(224, 86, 253, 0.3);
            `;
            header.innerHTML = `<span style="color: #e056fd; font-size: 10px;">Click potion to use. Use controls below each potion for batch use.</span>`;
            list.appendChild(header);

            // Create compact grid - more columns
            const grid = document.createElement('div');
            grid.style.cssText = `
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
                gap: 6px;
            `;

            userPotions.forEach(potion => {
                const count = playerInventory.potions[potion.id];
                const item = document.createElement('div');
                item.style.cssText = `
                    background: rgba(255, 255, 255, 0.03);
                    border: 1px solid rgba(255, 255, 255, 0.15);
                    padding: 6px;
                    border-radius: 4px;
                    display: flex;
                    flex-direction: column;
                    gap: 4px;
                `;

                const inputId = `potion-qty-${potion.id}`;

                item.innerHTML = `
                    <div style="font-size: 11px; font-weight: 600; color: #e056fd; text-align: center; line-height: 1.2;">${potion.name}</div>
                    <div style="font-size: 12px; color: #fff; text-align: center; font-weight: bold;">x${count.toLocaleString()}</div>
                    <div style="font-size: 8px; color: #666; text-align: center;">${potion.description.substring(0, 30)}...</div>
                    <div style="display: flex; gap: 3px;">
                        <button class="potion-use-btn" data-potion="${potion.id}" data-qty="1" 
                            style="flex: 1; padding: 3px; font-size: 9px; background: rgba(46, 204, 113, 0.2); 
                            border: 1px solid #2ecc71; color: #2ecc71; border-radius: 3px; cursor: pointer;">Use 1</button>
                        <button class="potion-use-btn" data-potion="${potion.id}" data-qty="all"
                            style="flex: 1; padding: 3px; font-size: 9px; background: rgba(231, 76, 60, 0.2);
                            border: 1px solid #e74c3c; color: #e74c3c; border-radius: 3px; cursor: pointer;">Use All</button>
                    </div>
                    <div style="display: flex; gap: 3px; align-items: center;">
                        <input type="number" id="${inputId}" min="1" max="${count}" value="10" 
                            style="flex: 1; padding: 2px; font-size: 9px; background: rgba(0,0,0,0.3);
                            border: 1px solid rgba(255,255,255,0.2); color: #fff; border-radius: 3px; 
                            text-align: center; width: 40px;">
                        <button class="potion-use-btn" data-potion="${potion.id}" data-input="${inputId}"
                            style="padding: 2px 6px; font-size: 9px; background: rgba(52, 152, 219, 0.2);
                            border: 1px solid #3498db; color: #3498db; border-radius: 3px; cursor: pointer;">Use</button>
                    </div>
                `;

                grid.appendChild(item);
            });
            list.appendChild(grid);

            // Add event listeners for all potion buttons
            list.querySelectorAll('.potion-use-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const potionId = btn.dataset.potion;
                    const qty = btn.dataset.qty;
                    const inputId = btn.dataset.input;

                    if (!potionId) return;

                    let useCount = 1;
                    if (qty === 'all') {
                        // Get fresh count from inventory at click time
                        const currentCount = (playerInventory.potions && playerInventory.potions[potionId]) || 0;
                        useCount = Math.max(1, currentCount); // Use at least 1 if we have any
                        console.log(`[Potion] Use All clicked for ${potionId}, count: ${currentCount}`);
                    } else if (inputId) {
                        const input = document.getElementById(inputId);
                        useCount = parseInt(input?.value) || 1;
                    } else {
                        useCount = parseInt(qty) || 1;
                    }

                    if (useCount > 0) {
                        usePotionsBatch(potionId, useCount);
                    }
                });
            });
        }

        function createGearItem(gear, slot) {
            const item = document.createElement('div');
            item.classList.add('gear-item');
            const isEquipped = playerInventory.equipped[slot] === gear.id;
            if (isEquipped) item.classList.add('equipped');

            item.innerHTML = `
                    <div class="corner tl"></div>
                    <div class="corner tr"></div>
                    <div class="corner bl"></div>
                    <div class="corner br"></div>
                    <div class="gear-item-name" style="color: ${getTierColor(gear.tier)}">${gear.name}</div>
                    <div class="gear-item-count">x1</div>
                `;

            item.addEventListener('click', () => {
                // Toggle equip
                if (playerInventory.equipped[slot] === gear.id) {
                    playerInventory.equipped[slot] = null;
                    showNotification(`Unequipped ${gear.name}`, '#ff6b6b');
                } else {
                    playerInventory.equipped[slot] = gear.id;
                    showNotification(`Equipped ${gear.name}`, getTierColor(gear.tier));
                }
                populateInventory();
                updateInventoryEquippedSlots();
                updateEquippedDisplay();
            });

            return item;
        }

        function formatGearPercent(value, label) {
            if (typeof value !== 'number' || value === 0) return null;
            const sign = value > 0 ? '+' : '';
            return `${sign}${(value * 100).toFixed(0)}% ${label}`;
        }

        function getSpecialGearEffectText(specialId) {
            const specialEffects = {
                'omega-overdrive': 'Every 25 rolls: OVERDRIVE for 8 rolls (x2 Luck, +50% Speed)',
                'gemstone-proc': 'Every 10 rolls: 50/50 +30% Luck or +30% Speed for 10 rolls',
                'dark-matter': 'Each Bonus Roll: 0.1% chance to gain +1 Point',
                'jackpot-bonus': 'Rolling Jackpot gives +$77',
                'flesh-bonus': 'Every roll acts as Bonus Roll (x1.3 multiplier)',
                'bonus-6x': 'Bonus Roll multiplier becomes x6',
                'dark-shader': 'Bonus threshold 10->5; ENCROACHED every 20 rolls',
                'light-caster': 'Bonus threshold 10->3; RADIANT every 15 rolls',
                'pole-skip': 'Every 30 rolls: 5 Sky-Warp rolls',
                'cataclysm-phase': 'Every 50 rolls: CATACLYSM for 5 rolls (x3 Luck, +80% Speed)',
                'paradox-pulse': 'Every 12th roll: x4 Luck pulse',
                'chronowarden-burst': 'Every 300th roll: x30 Luck for 6 rolls',
                'fatebreaker-collapse': 'Every 100 rolls: next roll samples 3 outcomes, keeps rarest',
                'tide-bonus': 'Bonus rolls can use native RAINY aura rarity',
                'blessed-tide': 'Bonus threshold 10->6, bonus multiplier x3, native RAINY on bonus',
                'present-luck': 'Every 11th roll: x5 Luck',
                'xmas-luck': 'Every 6th roll: x4 Luck',
                'halloween-boost': 'Halloween auras get 20% rarity reduction',
                'unfathomable-ruins': 'Every 1000th roll: x100 Luck for 10 rolls'
            };
            return specialEffects[specialId] || null;
        }

        function getGearEffectSummary(gear) {
            if (!gear || !gear.stats) return 'No stat effects.';
            const stats = gear.stats;
            const effects = [];

            const luckText = formatGearPercent(stats.luck, 'Luck');
            if (luckText) effects.push(luckText);

            const speedText = formatGearPercent(stats.rollSpeed, 'Roll Speed');
            if (speedText) effects.push(speedText);

            if (typeof stats.luckMultiplier === 'number' && stats.luckMultiplier !== 1) {
                const deltaPct = ((stats.luckMultiplier - 1) * 100).toFixed(0);
                effects.push(`${stats.luckMultiplier >= 1 ? '+' : ''}${deltaPct}% Base Luck Multiplier`);
            }

            if (typeof stats.duplicateChance === 'number' && stats.duplicateChance > 0) {
                effects.push(`${(stats.duplicateChance * 100).toFixed(0)}% Item Duplicate Chance`);
            }

            if (stats.removeBonusRoll) {
                effects.push('Bonus Roll Disabled');
            }

            if (stats.rainyBonus) {
                const rainyEffects = [];
                const rainyLuck = formatGearPercent(stats.rainyBonus.luck, 'Luck');
                const rainySpeed = formatGearPercent(stats.rainyBonus.rollSpeed, 'Roll Speed');
                if (rainyLuck) rainyEffects.push(rainyLuck);
                if (rainySpeed) rainyEffects.push(rainySpeed);
                if (rainyEffects.length) effects.push(`RAINY: ${rainyEffects.join(', ')}`);
            }

            if (stats.starfallBonus) {
                const starfallEffects = [];
                const starLuck = formatGearPercent(stats.starfallBonus.luck, 'Luck');
                const starSpeed = formatGearPercent(stats.starfallBonus.rollSpeed, 'Roll Speed');
                if (starLuck) starfallEffects.push(starLuck);
                if (starSpeed) starfallEffects.push(starSpeed);
                if (starfallEffects.length) effects.push(`STARFALL: ${starfallEffects.join(', ')}`);
            }

            if (stats.weatherBonus) {
                const weatherEffects = [];
                const weatherLuck = formatGearPercent(stats.weatherBonus.luck, 'Luck');
                const weatherSpeed = formatGearPercent(stats.weatherBonus.rollSpeed, 'Roll Speed');
                if (weatherLuck) weatherEffects.push(weatherLuck);
                if (weatherSpeed) weatherEffects.push(weatherSpeed);
                const weatherNames = Array.isArray(stats.weatherBonus.biomes) ? stats.weatherBonus.biomes.join('/') : 'Weather';
                if (weatherEffects.length) effects.push(`${weatherNames}: ${weatherEffects.join(', ')}`);
            }

            if (stats.biomeBonus) {
                const biomeEffects = [];
                const biomeLuck = formatGearPercent(stats.biomeBonus.luck, 'Luck');
                const biomeSpeed = formatGearPercent(stats.biomeBonus.rollSpeed, 'Roll Speed');
                if (biomeLuck) biomeEffects.push(biomeLuck);
                if (biomeSpeed) biomeEffects.push(biomeSpeed);
                const biomeNames = Array.isArray(stats.biomeBonus.biomes) ? stats.biomeBonus.biomes.join('/') : 'Biome';
                if (biomeEffects.length) effects.push(`${biomeNames}: ${biomeEffects.join(', ')}`);
            }

            if (stats.special) {
                const specialText = getSpecialGearEffectText(stats.special);
                if (specialText) effects.push(specialText);
            }

            if (!effects.length && gear.description) return gear.description;
            if (!effects.length) return 'No stat effects.';

            return effects.join(' | ');
        }

        function updateInventoryEquippedSlots() {
            const rightSlot = document.getElementById('equipped-right-slot');
            const leftSlot = document.getElementById('equipped-left-slot');

            // Right slot
            const rightGearId = playerInventory.equipped.right;
            const rightGear = rightGearId ? GEARS.find(g => g.id === rightGearId) : null;
            const rightName = rightSlot.querySelector('.equipped-slot-name');
            const rightEffects = rightSlot.querySelector('.equipped-slot-effects');
            const rightDesc = rightSlot.querySelector('.equipped-slot-desc');
            if (rightGear) {
                rightName.textContent = rightGear.name;
                rightName.style.color = getTierColor(rightGear.tier);
                if (rightEffects) rightEffects.textContent = getGearEffectSummary(rightGear);
                if (rightDesc) rightDesc.textContent = rightGear.description || '';
                rightSlot.classList.remove('empty');
            } else {
                rightName.textContent = 'Empty.';
                rightName.style.color = '';
                if (rightEffects) rightEffects.textContent = 'No gear equipped.';
                if (rightDesc) rightDesc.textContent = 'Equip a right-hand gear to see its effects.';
                rightSlot.classList.add('empty');
            }

            // Left slot
            const leftGearId = playerInventory.equipped.left;
            const leftGear = leftGearId ? GEARS.find(g => g.id === leftGearId) : null;
            const leftName = leftSlot.querySelector('.equipped-slot-name');
            const leftEffects = leftSlot.querySelector('.equipped-slot-effects');
            const leftDesc = leftSlot.querySelector('.equipped-slot-desc');
            if (leftGear) {
                leftName.textContent = leftGear.name;
                leftName.style.color = getTierColor(leftGear.tier);
                if (leftEffects) leftEffects.textContent = getGearEffectSummary(leftGear);
                if (leftDesc) leftDesc.textContent = leftGear.description || '';
                leftSlot.classList.remove('empty');
            } else {
                leftName.textContent = 'Empty.';
                leftName.style.color = '';
                if (leftEffects) leftEffects.textContent = 'No gear equipped.';
                if (leftDesc) leftDesc.textContent = 'Equip a left-hand gear to see its effects.';
                leftSlot.classList.add('empty');
            }
        }

        function toggleFilterPanel() {
            const panel = document.getElementById('filter-panel');
            panel.classList.toggle('active');
            if (panel.classList.contains('active')) initFilterPanel();
        }

        function initFilterPanel() {
            const list = document.getElementById('filter-list');
            if (list.children.length > 0) return;
            AURAS.forEach(aura => {
                if (aura.id === 'nothing') return;
                const row = document.createElement('div');
                row.classList.add('filter-row');
                const status = userSettings.filters[aura.id] || 'disabled';
                if (status !== 'disabled') row.classList.add(status); else row.classList.add('disabled');
                row.innerHTML = `
                        <div class="corner tl"></div><div class="corner tr"></div>
                        <div class="corner bl"></div><div class="corner br"></div>
                        <span class="filter-aura-name">${aura.name}</span>
                        <div class="filter-controls">
                            <button class="filter-status-btn">${status.charAt(0).toUpperCase() + status.slice(1)}</button>
                            <button class="filter-icon-btn">${getFilterIcon(status)}</button>
                        </div>
                    `;
                const auraNameEl = row.querySelector('.filter-aura-name');
                if (auraNameEl) applyAuraStyling(auraNameEl, aura);
                const btn = row.querySelector('.filter-status-btn');
                const iconBtn = row.querySelector('.filter-icon-btn');
                const updateRow = (newStatus) => {
                    row.classList.remove('disabled', 'skip', 'keep');
                    if (newStatus === 'disabled') row.classList.add('disabled'); else row.classList.add(newStatus);
                    btn.textContent = newStatus.charAt(0).toUpperCase() + newStatus.slice(1);
                    iconBtn.innerHTML = getFilterIcon(newStatus);
                    userSettings.filters[aura.id] = newStatus;
                };

                const cycleStatus = () => {
                    const states = ['disabled', 'skip', 'keep'];
                    const current = userSettings.filters[aura.id] || 'disabled';
                    const next = states[(states.indexOf(current) + 1) % states.length];
                    const auraChance = aura.chance || 0;

                    if (next === 'skip' && userSettings.rolling.skipWarnEnabled && auraChance >= userSettings.rolling.skipWarnRarity) {
                        if (!confirm(`Skip filter warning:\n${aura.name} is 1 in ${auraChance.toLocaleString()}.\nAre you sure you want to mark it as SKIP?`)) {
                            return;
                        }
                    }
                    updateRow(next);
                };

                btn.addEventListener('click', cycleStatus);
                iconBtn.addEventListener('click', cycleStatus);
                list.appendChild(row);
            });
        }

        function getFilterIcon(status) {
            if (status === 'skip') return '&#10006;';
            if (status === 'keep') return '&#10003;';
            return '&#9675;';
        }

        function resetEverything() {
            if (!confirm("Are you sure you want to reset ALL progress and settings? This cannot be undone.")) return;
            if (!confirm("This will DELETE ALL your data. Are you REALLY sure?")) return;

            // CRITICAL: Set flag to prevent beforeunload from re-saving data
            _isResetting = true;

            // Clear all saved data from localStorage
            localStorage.removeItem('solsRngSave');
            localStorage.removeItem('solsRngSettings');
            localStorage.removeItem('solsRngAchievements');
            localStorage.removeItem('solsRngAuraLog');

            // Clear everything in localStorage that starts with solsRng
            Object.keys(localStorage).forEach(key => {
                if (key.startsWith('solsRng') || key.startsWith('sols')) {
                    localStorage.removeItem(key);
                }
            });

            showNotification('All data cleared! Reloading...', '#e74c3c');

            // Short delay so user sees the notification
            setTimeout(() => {
                // Reload the page for a completely clean slate
                location.reload(true); // Force reload from server
            }, 500);
        }

        function clearAllBuffs() {
            if (!confirm("Are you sure you want to clear all active potion buffs? (Gear bonuses will not be affected)")) return;

            // Clear active timed buffs
            activeBuffs = {};

            // Clear one-time queued buffs
            oneTimeBuffs = [];

            // Update UI
            updateBuffsHUD();
            updateStatsPanel();

            showNotification('All buffs have been cleared!', '#ff9f43');
        }

        function parseRarity(val) {
            if (!val) return 0;
            return parseInt(val.toString().replace(/,/g, '')) || 0;
        }

        function updateRollingSettingStatusLabels() {
            const skipStatus = document.getElementById('set-skip-warn-status');
            const swapStatus = document.getElementById('set-swap-warn-status');

            if (skipStatus) {
                const enabled = !!userSettings.rolling.skipWarnEnabled;
                skipStatus.textContent = enabled ? 'Enabled' : 'Disabled';
                skipStatus.style.color = enabled ? '#2ecc71' : '#ff6b6b';
            }
            if (swapStatus) {
                const enabled = !!userSettings.rolling.swapWarnEnabled;
                swapStatus.textContent = enabled ? 'Enabled' : 'Disabled';
                swapStatus.style.color = enabled ? '#2ecc71' : '#ff6b6b';
            }
        }

        function syncSettingsFromUI() {
            const elSkipWarnVal = document.getElementById('set-skip-warn-val');
            const elSkipWarnToggle = document.getElementById('set-skip-warn-toggle');
            const elSwapWarnVal = document.getElementById('set-swap-warn-val');
            const elSwapWarnToggle = document.getElementById('set-swap-warn-toggle');
            const elAutoEquipVal = document.getElementById('set-auto-equip-val');
            const elAutoEquipToggle = document.getElementById('set-auto-equip-toggle');
            const elSkipCutsceneVal = document.getElementById('set-skip-cutscene-val');
            const elSkipCutsceneToggle = document.getElementById('set-skip-cutscene-toggle');
            const elBuffsEnabled = document.getElementById('set-buffs-enabled');
            const elStorageWarning = document.getElementById('set-storage-warning');
            const elPlayCutscene = document.getElementById('set-play-cutscene');
            const elVolBgm = document.getElementById('vol-bgm');
            const elVolSfx = document.getElementById('vol-sfx');
            if (elSkipWarnVal) userSettings.rolling.skipWarnRarity = parseRarity(elSkipWarnVal.value);
            if (elSkipWarnToggle) userSettings.rolling.skipWarnEnabled = elSkipWarnToggle.checked;
            if (elSwapWarnVal) userSettings.rolling.swapWarnRarity = parseRarity(elSwapWarnVal.value);
            if (elSwapWarnToggle) userSettings.rolling.swapWarnEnabled = elSwapWarnToggle.checked;
            if (elAutoEquipVal) userSettings.rolling.autoEquipRarity = parseRarity(elAutoEquipVal.value);
            if (elAutoEquipToggle) userSettings.rolling.autoEquipEnabled = elAutoEquipToggle.checked;
            const elAutoGearToggle = document.getElementById('set-auto-gear-toggle');
            if (elAutoGearToggle) userSettings.rolling.autoGearEnabled = elAutoGearToggle.checked;
            if (elSkipCutsceneVal) userSettings.rolling.skipCutsceneRarity = parseRarity(elSkipCutsceneVal.value);
            if (elSkipCutsceneToggle) userSettings.rolling.skipCutsceneEnabled = elSkipCutsceneToggle.checked;
            if (elBuffsEnabled) userSettings.rolling.buffsEnabled = elBuffsEnabled.checked;
            if (elStorageWarning) userSettings.rolling.storageWarning = elStorageWarning.checked;
            if (elPlayCutscene) userSettings.rolling.playNewAuraCutscene = elPlayCutscene.checked;
            if (elVolBgm) userSettings.audio.bgm = parseInt(elVolBgm.value);
            if (elVolSfx) userSettings.audio.sfx = parseInt(elVolSfx.value);
            updateRollingSettingStatusLabels();
        }

        function updateEquippedDisplay() {
            const hud = document.getElementById('current-aura-hud');
            if (currentEquippedAura && currentEquippedAura.id !== 'nothing') {
                hud.innerHTML = '';
                const prefix = document.createElement('span');
                prefix.textContent = 'Aura: ';
                prefix.style.color = '#e5edf8';
                prefix.style.textShadow = 'none';
                hud.appendChild(prefix);

                const auraName = document.createElement('span');
                auraName.textContent = currentEquippedAura.name;
                applyAuraStyling(auraName, currentEquippedAura);
                hud.appendChild(auraName);
            } else {
                hud.textContent = 'Aura: None';
                hud.style.color = '#fff';
                hud.style.textShadow = 'none';
                hud.style.fontFamily = "'Sarpanch', sans-serif";
            }
        }

        
function updateAdminChromaticEffect() {
            const adminInner = document.querySelector('.admin-panel-inner');
            const adminTitle = document.querySelector('.admin-title');
            if (!adminInner) return;
            const active = isChromaticCrusherEquipped();
            adminInner.classList.toggle('chromatic-crusher-rgb', active);
            if (adminTitle) adminTitle.classList.toggle('chromatic-crusher-rgb-text', active);
        }

        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('roll-button').addEventListener('click', performRoll);
            document.getElementById('auto-roll').addEventListener('click', toggleAutoRoll);
            document.getElementById('quick-roll').addEventListener('click', toggleQuickRoll);

            // Admin Panel
            document.getElementById('admin-btn').addEventListener('click', toggleAdminPanel);
            document.getElementById('admin-close').addEventListener('click', toggleAdminPanel);
            initAdminPanel();

            // Admin Panel - Gear Search
            const adminGearSearch = document.getElementById('admin-gear-search');
            if (adminGearSearch) {
                adminGearSearch.addEventListener('input', populateAdminGears);
            }

            // Admin Panel - Give Material Button
            const adminGiveMaterialBtn = document.getElementById('admin-give-material');
            if (adminGiveMaterialBtn) {
                adminGiveMaterialBtn.addEventListener('click', giveAdminMaterial);
            }

            // Admin Panel - Set Rolls Button
            const adminSetRollsBtn = document.getElementById('admin-update-rolls');
            if (adminSetRollsBtn) {
                adminSetRollsBtn.addEventListener('click', () => {
                    const rollsInput = document.getElementById('admin-set-rolls');
                    const newRolls = parseInt(rollsInput.value);
                    if (isNaN(newRolls) || newRolls < 0) {
                        showNotification('Enter a valid number!', '#ff6b6b');
                        return;
                    }
                    playerStats.totalRolls = newRolls;
                    updateRollCount();
                    updateStatsPanel();
                    saveGame();
                    showNotification(`Total rolls set to ${newRolls.toLocaleString()}!`, '#2ecc71');
                    rollsInput.value = '';
                });
            }

            // Admin Panel - Clear All Buffs Button
            const adminClearBuffsBtn = document.getElementById('admin-clear-buffs');
            if (adminClearBuffsBtn) {
                adminClearBuffsBtn.addEventListener('click', clearAllBuffs);
            }

            // Admin Panel - Reset All Data Button
            const adminResetDataBtn = document.getElementById('admin-reset-data');
            if (adminResetDataBtn) {
                adminResetDataBtn.addEventListener('click', resetEverything);
            }

            // Admin Panel - VIP Toggle Buttons
            const vipToggleBtn = document.getElementById('admin-toggle-vip');
            const vipPlusToggleBtn = document.getElementById('admin-toggle-vip-plus');

            if (vipToggleBtn) {
                vipToggleBtn.addEventListener('click', () => {
                    hasVIP = !hasVIP;
                    vipToggleBtn.textContent = hasVIP ? 'VIP: ON' : 'VIP: OFF';
                    vipToggleBtn.style.background = hasVIP ? 'rgba(255, 215, 0, 0.4)' : 'rgba(255, 215, 0, 0.2)';
                    showNotification(hasVIP ? 'VIP Enabled! x' + getVIPMultiplier() + ' luck' : 'VIP Disabled', '#ffd700');
                    saveGame();
                });
            }

            if (vipPlusToggleBtn) {
                vipPlusToggleBtn.addEventListener('click', () => {
                    hasVIPPlus = !hasVIPPlus;
                    vipPlusToggleBtn.textContent = hasVIPPlus ? 'VIP+: ON' : 'VIP+: OFF';
                    vipPlusToggleBtn.style.background = hasVIPPlus ? 'rgba(147, 112, 219, 0.4)' : 'rgba(147, 112, 219, 0.2)';
                    showNotification(hasVIPPlus ? 'VIP+ Enabled! x' + getVIPMultiplier() + ' luck' : 'VIP+ Disabled', '#9370db');
                    saveGame();
                });
            }

            // Admin Panel - Only Potion Aura Cutscenes Toggle
            const potionCutscenesToggleBtn = document.getElementById('admin-toggle-potion-cutscenes');
            if (potionCutscenesToggleBtn) {
                potionCutscenesToggleBtn.addEventListener('click', () => {
                    userSettings.debug.onlyPotionAuraCutscenes = !userSettings.debug.onlyPotionAuraCutscenes;
                    const isOn = userSettings.debug.onlyPotionAuraCutscenes;
                    potionCutscenesToggleBtn.textContent = isOn ? 'Only Potion Auras: ON' : 'Only Potion Auras: OFF';
                    potionCutscenesToggleBtn.style.background = isOn ? 'rgba(224, 86, 253, 0.4)' : 'rgba(224, 86, 253, 0.2)';
                    showNotification(isOn ? 'Only potion aura cutscenes enabled!' : 'All cutscenes enabled', '#e056fd');
                    saveGame();
                });
            }

            // Admin Panel - Test Cutscene Button
            const testCutsceneBtn = document.getElementById('admin-test-cutscene');
            if (testCutsceneBtn) {
                testCutsceneBtn.addEventListener('click', () => testAdminCutscene());
            }

            // Menu Panel

            document.getElementById('settings-close').addEventListener('click', toggleSettingsPanel);
            document.getElementById('filter-close').addEventListener('click', toggleFilterPanel);

            // Open Filter from Settings
            const openFilterBtn = document.getElementById('open-filter-btn');
            const openFilterLabel = document.getElementById('open-filter-label');
            if (openFilterBtn) openFilterBtn.addEventListener('click', toggleFilterPanel);
            if (openFilterLabel) openFilterLabel.addEventListener('click', toggleFilterPanel);

            document.querySelectorAll('.settings-tab').forEach(tab => {
                tab.addEventListener('click', () => switchSettingsTab(tab.dataset.tab));
            });

            // === Workshop Event Listeners ===
            const itemsBtn = document.getElementById('items-btn');
            if (itemsBtn) itemsBtn.addEventListener('click', toggleWorkshopPanel);

            const workshopClose = document.getElementById('workshop-close');
            if (workshopClose) workshopClose.addEventListener('click', toggleWorkshopPanel);

            const workshopSearch = document.getElementById('workshop-search');
            if (workshopSearch) {
                workshopSearch.addEventListener('input', () => {
                    // Check which tab is active and refresh accordingly
                    const activeTab = document.querySelector('.workshop-tab.active');
                    if (activeTab && activeTab.dataset.tab === 'items') {
                        populateWorkshopItems();
                    } else {
                        populateWorkshopGears();
                    }
                });
            }

            // === Inventory Event Listeners ===
            const inventoryBtn = document.getElementById('inventory-btn');
            if (inventoryBtn) inventoryBtn.addEventListener('click', toggleInventoryPanel);

            const inventoryClose = document.getElementById('inventory-close');
            if (inventoryClose) inventoryClose.addEventListener('click', toggleInventoryPanel);

            const inventorySearch = document.getElementById('inventory-search');
            if (inventorySearch) {
                inventorySearch.addEventListener('input', populateInventory);
            }

            // === Aura Storage Event Listeners ===
            const storageBtn = document.getElementById('storage-btn');
            if (storageBtn) storageBtn.addEventListener('click', toggleAuraStoragePanel);

            const auraStorageClose = document.getElementById('aura-storage-close');
            if (auraStorageClose) auraStorageClose.addEventListener('click', toggleAuraStoragePanel);

            const auraStorageSearch = document.getElementById('aura-storage-search');
            if (auraStorageSearch) {
                auraStorageSearch.addEventListener('input', renderAuraStorageGrid);
            }

            document.querySelectorAll('.aura-storage-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    auraStorageActiveTab = tab.dataset.tab === 'special' ? 'special' : 'regular';
                    populateAuraStoragePanel();
                });
            });

            const auraStorageEquipBtn = document.getElementById('aura-storage-equip-btn');
            if (auraStorageEquipBtn) auraStorageEquipBtn.addEventListener('click', equipSelectedStorageAura);

            const auraStorageDeleteBtn = document.getElementById('aura-storage-delete-btn');
            if (auraStorageDeleteBtn) auraStorageDeleteBtn.addEventListener('click', deleteSelectedStorageAura);

            const auraStorageLockBtn = document.getElementById('aura-storage-lock-btn');
            if (auraStorageLockBtn) auraStorageLockBtn.addEventListener('click', toggleLockSelectedStorageAura);

            const auraStorageUpgradeBtn = document.getElementById('aura-storage-upgrade-btn');
            if (auraStorageUpgradeBtn) auraStorageUpgradeBtn.addEventListener('click', upgradeAuraStorageCapacity);

            const storageFullReplaceBtn = document.getElementById('storage-full-replace-btn');
            if (storageFullReplaceBtn) storageFullReplaceBtn.addEventListener('click', replaceMostRecentStorageAuraFromPrompt);

            const storageFullDiscardBtn = document.getElementById('storage-full-discard-btn');
            if (storageFullDiscardBtn) storageFullDiscardBtn.addEventListener('click', discardRolledAuraFromPrompt);

            // Inventory tabs (Gears/Potions)
            document.querySelectorAll('.inventory-tabs .inventory-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.inventory-tabs .inventory-tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    populateInventory();
                });
            });

            // Equipped slots click to unequip
            document.querySelectorAll('.equipped-slot').forEach(slot => {
                slot.addEventListener('click', () => {
                    const slotType = slot.dataset.slot;
                    if (playerInventory.equipped[slotType]) {
                        const gear = GEARS.find(g => g.id === playerInventory.equipped[slotType]);
                        playerInventory.equipped[slotType] = null;
                        showNotification(`Unequipped ${gear ? gear.name : 'gear'}`, '#ff6b6b');
                        populateInventory();
                        updateInventoryEquippedSlots();
                        updateEquippedDisplay();
                    }
                });
            });

            const craftBtn = document.getElementById('craft-btn');
            if (craftBtn) {
                craftBtn.addEventListener('click', () => {
                    performWorkshopAction();
                });
            }

            const autoBtn = document.getElementById('auto-btn');
            if (autoBtn) {
                autoBtn.addEventListener('click', toggleAutoDeposit);
            }

            document.querySelectorAll('.workshop-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.workshop-tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    const tabName = tab.dataset.tab;
                    // Clear preview when switching tabs
                    document.getElementById('workshop-preview').innerHTML = '<div class="preview-placeholder">Select an item to craft</div>';
                    document.getElementById('workshop-materials').innerHTML = '';
                    // Handle different tabs
                    if (tabName === 'gears') {
                        selectedPotion = null;
                        selectedChestId = null;
                        populateWorkshopGears();
                    } else if (tabName === 'items') {
                        selectedGear = null;
                        selectedChestId = null;
                        populateWorkshopItems();
                    } else {
                        document.getElementById('workshop-list').innerHTML = `<div style="padding: 20px; color: rgba(255,255,255,0.4); text-align: center;">${tabName.charAt(0).toUpperCase() + tabName.slice(1)} coming soon...</div>`;
                    }
                });
            });

            // Settings slider value update
            document.querySelectorAll('.setting-slider').forEach(slider => {
                slider.addEventListener('input', () => {
                    const badge = slider.parentElement.querySelector('.setting-value-badge');
                    if (badge) badge.textContent = `${slider.value}%`;
                });
            });

            // Menu item click handlers
            document.querySelectorAll('.menu-item').forEach(item => {
                item.addEventListener('click', () => {
                    const action = item.dataset.action;
                    console.log('Menu action:', action);

                    if (action === 'settings') {
                        toggleSettingsPanel();
                        toggleMenu(); // Close menu
                    } else if (action === 'achievements') {
                        toggleAchievementsPanel();
                        // Menu closing is handled inside toggleAchievementsPanel to support switching
                    } else {
                        toggleMenu();
                    }
                });
            });

            // Achievements Close Button
            const achievementsClose = document.getElementById('achievements-close');
            if (achievementsClose) {
                achievementsClose.addEventListener('click', toggleAchievementsPanel);
            }

            // Tab Switching
            document.querySelectorAll('.admin-tab').forEach(tab => {
                tab.addEventListener('click', () => switchTab(tab.dataset.tab));
            });

            // Time Controls
            document.getElementById('time-day').addEventListener('click', () => setTime('DAYTIME'));
            document.getElementById('time-night').addEventListener('click', () => setTime('NIGHTTIME'));
            document.getElementById('time-auto-toggle').addEventListener('click', toggleAutoTimeCycle);

            // --- Sync Settings Logic ---


            // Add listeners to all relevant inputs
            const settingMappings = [
                { id: 'set-notif-enabled', path: 'notifications.enabled', type: 'check' },
                { id: 'set-skip-warn-val', path: 'rolling.skipWarnRarity', type: 'parse' },
                { id: 'set-skip-warn-toggle', path: 'rolling.skipWarnEnabled', type: 'check' },
                { id: 'set-swap-warn-val', path: 'rolling.swapWarnRarity', type: 'parse' },
                { id: 'set-swap-warn-toggle', path: 'rolling.swapWarnEnabled', type: 'check' },
                { id: 'set-auto-equip-val', path: 'rolling.autoEquipRarity', type: 'parse' },
                { id: 'set-auto-equip-toggle', path: 'rolling.autoEquipEnabled', type: 'check' },
                { id: 'set-auto-gear-toggle', path: 'rolling.autoGearEnabled', type: 'check' },
                { id: 'set-skip-cutscene-val', path: 'rolling.skipCutsceneRarity', type: 'parse' },
                { id: 'set-skip-cutscene-toggle', path: 'rolling.skipCutsceneEnabled', type: 'check' },
                { id: 'set-storage-warning', path: 'rolling.storageWarning', type: 'check' },
                { id: 'set-play-cutscene', path: 'rolling.playNewAuraCutscene', type: 'check' },
                { id: 'vol-bgm', path: 'audio.bgm', type: 'int' },
                { id: 'vol-sfx', path: 'audio.sfx', type: 'int' },
                { id: 'set-buffs-enabled', path: 'rolling.buffsEnabled', type: 'check' },
                { id: 'set-hide-buffs-hud', path: 'rolling.hideAllBuffs', type: 'check' }
            ];

            settingMappings.forEach(mapping => {
                const el = document.getElementById(mapping.id);
                if (!el) return;
                const eventType = el.type === 'text' ? 'blur' : 'change';
                el.addEventListener(eventType, () => {
                    let val;
                    if (mapping.type === 'check') val = el.checked;
                    else if (mapping.type === 'parse') val = parseRarity(el.value);
                    else val = parseInt(el.value);

                    // Set deep value
                    const parts = mapping.path.split('.');
                    userSettings[parts[0]][parts[1]] = val;
                    console.log(`Setting updated: ${mapping.path} =`, val);

                    // Trigger Auto Gear Check immediately if enabled
                    if (mapping.id === 'set-auto-gear-toggle' && val) {
                        checkAutoGear();
                    }
                    if (mapping.path.startsWith('rolling.')) {
                        updateRollingSettingStatusLabels();
                    }
                    if (mapping.id === 'set-hide-buffs-hud' || mapping.id === 'set-buffs-enabled') {
                        updateBuffsHUD();
                    }
                });
            });





            // --- Time Management ---
            window.updateLighting = function () {
                const lightingOverlay = document.getElementById('lighting-overlay');
                if (lightingOverlay) {
                    if (currentTime === 'NIGHTTIME') {
                        lightingOverlay.style.opacity = '0.7';
                    } else {
                        lightingOverlay.style.opacity = '0';
                    }
                }
            };

            window.setTime = function (time) {
                currentTime = time;
                updateHUD();
                updateTimeButtons();
                updateLighting(); // Force immediate update
                // If manual set, disable auto cycle? Or keep it?
                // User logic: "Time controls" usually implies manual override.
                // We'll leave autoTimeCycle as is, but resets timer.
                timeCycleTimer = 0;
                showNotification(`Time set to ${time}`, '#3498db');
            };

            window.toggleAutoTimeCycle = function () {
                autoTimeCycle = !autoTimeCycle;
                const btn = document.getElementById('time-auto-toggle');
                if (btn) {
                    btn.textContent = `Auto Cycle: ${autoTimeCycle ? 'ON' : 'OFF'}`;
                    btn.style.color = autoTimeCycle ? '#2ecc71' : '#e74c3c';
                }
                showNotification(`Auto Time Cycle: ${autoTimeCycle ? 'ON' : 'OFF'}`, autoTimeCycle ? '#2ecc71' : '#e74c3c');
            };

            // Initial Lighting Check
            updateLighting();

            document.getElementById('reset-game-btn').addEventListener('click', resetEverything);

            // Stats Panel Toggle
            const statsToggle = document.getElementById('stats-toggle');
            const statsContent = document.getElementById('stats-content');
            if (statsToggle && statsContent) {
                statsToggle.addEventListener('click', () => {
                    statsContent.classList.toggle('collapsed');
                    statsToggle.textContent = statsContent.classList.contains('collapsed') ? '+' : '-';
                });
            }

            loadGame();
            ensureAuraStorageState();

            currentEquippedAura = AURAS[0];
            syncSettingsFromUI();
            updateRollCount();
            updateHUD();
            updateTimeButtons();
            updateEquippedDisplay();
            updateStatsPanel();
            document.querySelector('.version').textContent = 'v1.000';

            // Auto-save every 10 seconds
            setInterval(saveGame, 10000);

            // Playtime timer - update every second
            startPlaytimeTracking();

            // --- Periodic Cleanup for Visual Glitches ---
            setInterval(() => {
                cleanupVisualGlitches();
            }, 30000); // Every 30 seconds
        });

        // Cleanup function for stuck visual effects
        function cleanupVisualGlitches() {
            // Remove orphaned 1B effect elements
            document.querySelectorAll('[data-1b-effect]').forEach(el => el.remove());

            // Reset stuck body filters
            const body = document.body;
            if (body.style.filter && body.style.filter !== 'none' && !is1BEffectPlaying) {
                console.log('[Cleanup] Resetting stuck body filter');
                body.style.filter = '';
                body.style.transform = '';
                body.style.animation = '';
                body.style.transition = '';
            }

            // Clear duplicate video overlays
            const videoOverlays = document.querySelectorAll('#video-cutscene-overlay');
            if (videoOverlays.length > 1) {
                console.log('[Cleanup] Removing duplicate video overlays');
                for (let i = 1; i < videoOverlays.length; i++) {
                    videoOverlays[i].remove();
                }
            }

            // Ensure video cutscene overlay is hidden if not actively playing
            const overlay = document.getElementById('video-cutscene-overlay');
            const video = document.getElementById('cutscene-video');
            if (overlay && video && video.paused && overlay.style.display !== 'none') {
                // Check if it's been visible for too long without activity
                if (!video.src || video.ended) {
                    overlay.style.display = 'none';
                }
            }

            // Clean up stale flash overlays
            document.querySelectorAll('div[style*="position: fixed"][style*="z-index: 10000"]').forEach(el => {
                // Only remove if opacity is 0 or very low
                const opacity = parseFloat(el.style.opacity);
                if (opacity <= 0.01) {
                    el.remove();
                }
            });
        }

        // ============================================
        // PERFORMANCE MONITOR SYSTEM
        // ============================================
        const PerfMonitor = {
            visible: false,
            fps: 0,
            rollTimes: [],
            fpsHistory: [],
            lastFrameTime: 0,
            frameCount: 0,
            lastFpsUpdate: 0,

            init() {
                // Create monitor HTML
                const monitor = document.createElement('div');
                monitor.id = 'perf-monitor';
                monitor.innerHTML = `
                    <div class="perf-title">
                        <span>PERFORMANCE</span>
                        <span class="perf-close" onclick="PerfMonitor.toggle()">X</span>
                    </div>
                    <div class="perf-row">
                        <span class="perf-label">FPS:</span>
                        <span id="perf-fps" class="perf-value good">60</span>
                    </div>
                    <div class="perf-row">
                        <span class="perf-label">RPM:</span>
                        <span id="perf-rpm" class="perf-value">0</span>
                    </div>
                    <div class="perf-row">
                        <span class="perf-label">Roll Time:</span>
                        <span id="perf-rolltime" class="perf-value">-- ms</span>
                    </div>
                    <div class="perf-row">
                        <span class="perf-label">Memory:</span>
                        <span id="perf-memory" class="perf-value">-- MB</span>
                    </div>
                    <div class="perf-row">
                        <span class="perf-label">Particles:</span>
                        <span id="perf-particles" class="perf-value">0</span>
                    </div>
                    <div class="perf-row">
                        <span class="perf-label">DOM Nodes:</span>
                        <span id="perf-dom" class="perf-value">0</span>
                    </div>
                    <div class="perf-graph" id="perf-graph"></div>
                    <button id="perf-maxfps-btn" class="perf-maxfps-btn" onclick="toggleMaxFpsMode()">Max FPS: OFF</button>
                `;
                document.body.appendChild(monitor);

                // Create toggle button
                const toggleBtn = document.createElement('button');
                toggleBtn.className = 'perf-toggle-btn';
                toggleBtn.textContent = 'Perf';
                toggleBtn.onclick = () => PerfMonitor.toggle();
                document.body.appendChild(toggleBtn);

                // Start monitoring loop
                this.startMonitoring();

                // Keybinds
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'F9') {
                        e.preventDefault();
                        PerfMonitor.toggle();
                    }
                    if (e.key === 'F10') {
                        e.preventDefault();
                        toggleMaxFpsMode();
                        // Update button text
                        const btn = document.getElementById('perf-maxfps-btn');
                        if (btn) btn.textContent = `Max FPS: ${userSettings.performance.maxFpsMode ? 'ON' : 'OFF'}`;
                    }
                    if (e.key === 'F11') {
                        e.preventDefault();
                        // Emergency cleanup - fixes stuck overlays/effects
                        console.log('[Emergency Cleanup] Running...');

                        // Reset body
                        document.body.style.filter = '';
                        document.body.style.transform = '';
                        document.body.style.animation = '';

                        // Hide video overlay
                        const videoOverlay = document.getElementById('video-cutscene-overlay');
                        if (videoOverlay) videoOverlay.style.display = 'none';

                        // Clear any flash overlays
                        document.querySelectorAll('.flash-overlay, .mythic-flash, .legendary-flash, .unique-flash, .global-flash, [data-1b-effect]').forEach(el => el.remove());

                        // Reset roll state
                        if (typeof isRolling !== 'undefined') isRolling = false;
                        if (typeof isOnCooldown !== 'undefined') isOnCooldown = false;

                        // Re-enable roll button
                        const rollBtn = document.getElementById('roll-button');
                        if (rollBtn) {
                            rollBtn.classList.remove('disabled', 'cooldown-active');
                        }

                        // Run performance cleanup
                        if (typeof SolsPerformance !== 'undefined' && SolsPerformance.cleanupOrphanedElements) {
                            SolsPerformance.cleanupOrphanedElements();
                        }

                        showNotification('Emergency cleanup complete!', '#2ecc71');
                        console.log('[Emergency Cleanup] Done!');
                    }
                });

                console.log('[PerfMonitor] Initialized. F9=Toggle Monitor, F10=Toggle Max FPS Mode, F11=Emergency Cleanup');
            },

            toggle() {
                const monitor = document.getElementById('perf-monitor');
                if (monitor) {
                    this.visible = !this.visible;
                    monitor.classList.toggle('visible', this.visible);
                }
            },

            startMonitoring() {
                // FPS monitoring loop
                const measureFPS = (timestamp) => {
                    this.frameCount++;

                    if (timestamp - this.lastFpsUpdate >= 1000) {
                        this.fps = this.frameCount;
                        this.frameCount = 0;
                        this.lastFpsUpdate = timestamp;

                        // Update FPS history for graph
                        this.fpsHistory.push(this.fps);
                        if (this.fpsHistory.length > 30) this.fpsHistory.shift();

                        // Only update display if visible
                        if (this.visible) {
                            this.updateDisplay();
                        }
                    }

                    this.lastFrameTime = timestamp;
                    requestAnimationFrame(measureFPS);
                };

                requestAnimationFrame(measureFPS);
            },

            recordRollTime(duration) {
                this.rollTimes.push(duration);
                if (this.rollTimes.length > 50) this.rollTimes.shift();
            },

            updateDisplay() {
                // FPS
                const fpsEl = document.getElementById('perf-fps');
                if (fpsEl) {
                    fpsEl.textContent = this.fps;
                    fpsEl.className = 'perf-value ' + (this.fps >= 50 ? 'good' : this.fps >= 30 ? 'warning' : 'bad');
                }

                // RPM (Rolls Per Minute)
                const rpmEl = document.getElementById('perf-rpm');
                if (rpmEl && playerStats) {
                    const now = Date.now();
                    const recentRolls = playerStats.recentRollTimestamps.filter(t => t > now - 60000);
                    rpmEl.textContent = recentRolls.length;
                    rpmEl.className = 'perf-value ' + (recentRolls.length > 100 ? 'good' : 'warning');
                }

                // Roll Time
                const rollTimeEl = document.getElementById('perf-rolltime');
                if (rollTimeEl && this.rollTimes.length > 0) {
                    const avg = this.rollTimes.reduce((a, b) => a + b, 0) / this.rollTimes.length;
                    rollTimeEl.textContent = avg.toFixed(1) + ' ms';
                    rollTimeEl.className = 'perf-value ' + (avg < 16 ? 'good' : avg < 50 ? 'warning' : 'bad');
                }

                // Memory (if available)
                const memEl = document.getElementById('perf-memory');
                if (memEl) {
                    if (performance.memory) {
                        const mb = (performance.memory.usedJSHeapSize / 1048576).toFixed(1);
                        memEl.textContent = mb + ' MB';
                        memEl.className = 'perf-value ' + (mb < 100 ? 'good' : mb < 200 ? 'warning' : 'bad');
                    } else {
                        memEl.textContent = 'N/A';
                    }
                }

                // Particle count
                const particlesEl = document.getElementById('perf-particles');
                if (particlesEl) {
                    const particles = document.querySelectorAll('.raindrop, .snowflake, .dust-particle, .dust-streak, .wind-streak, .sand-cloud, .sakura-petal, .ink-drip').length;
                    particlesEl.textContent = particles;
                    particlesEl.className = 'perf-value ' + (particles < 50 ? 'good' : particles < 150 ? 'warning' : 'bad');
                }

                // DOM node count
                const domEl = document.getElementById('perf-dom');
                if (domEl) {
                    const nodeCount = document.getElementsByTagName('*').length;
                    domEl.textContent = nodeCount;
                    domEl.className = 'perf-value ' + (nodeCount < 1000 ? 'good' : nodeCount < 2000 ? 'warning' : 'bad');
                }

                // FPS Graph
                const graphEl = document.getElementById('perf-graph');
                if (graphEl) {
                    graphEl.innerHTML = '';
                    this.fpsHistory.forEach(fps => {
                        const bar = document.createElement('div');
                        bar.className = 'perf-bar';
                        bar.style.height = Math.min(100, (fps / 60) * 100) + '%';
                        bar.style.background = fps >= 50 ? '#2ecc71' : fps >= 30 ? '#f39c12' : '#e74c3c';
                        graphEl.appendChild(bar);
                    });
                }
            }
        };

        // Initialize performance monitor
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => PerfMonitor.init());
        } else {
            PerfMonitor.init();
        }

        // Hook into roll function to measure performance
        const _originalRecordRoll = typeof recordRoll === 'function' ? recordRoll : null;

        // --- Stats Panel Functions ---
        // Helper function to apply aura typography (font-specific settings)
        function applyAuraTypography(element, aura, fallbackFont = "'Sarpanch', sans-serif", fallbackWeight = 'normal') {
            if (!element || !aura) return;

            element.style.fontFamily = aura.fontFamily || fallbackFont;
            element.style.fontWeight = aura.fontWeight || fallbackWeight;
            element.style.fontStyle = aura.fontStyle || 'normal';
            element.style.letterSpacing = aura.letterSpacing || 'normal';
            element.style.textTransform = aura.textTransform || 'none';

            // Reset transform/stroke from previously rendered aura styles
            element.style.transform = 'none';
            element.style.display = '';
            element.style.webkitTextStroke = 'unset';
            element.style.textStroke = 'unset';

            if (aura.skewX) {
                element.style.transform = `skewX(${aura.skewX})`;
                element.style.display = 'inline-block';
            }
            if (aura.textStroke) {
                element.style.webkitTextStroke = aura.textStroke;
                element.style.textStroke = aura.textStroke;
            }
        }

        // Helper function to apply aura styling (font + gradient) to an element
        function applyAuraStyling(element, aura) {
            if (!element || !aura) return;

            // Reset visual styles first
            element.style.background = 'none';
            element.style.backgroundClip = 'unset';
            element.style.webkitBackgroundClip = 'unset';
            element.style.webkitTextFillColor = 'unset';
            element.style.textShadow = 'none';
            element.style.color = '';

            // Apply per-aura typography
            applyAuraTypography(element, aura, "'Sarpanch', sans-serif", 'normal');

            // Apply gradient if specified, otherwise use solid color
            if (aura.gradient) {
                element.style.background = aura.gradient;
                element.style.backgroundClip = 'text';
                element.style.webkitBackgroundClip = 'text';
                element.style.color = 'transparent';
                element.style.webkitTextFillColor = 'transparent';
            } else {
                element.style.color = aura.color || '#fff';
                element.style.textShadow = `0 0 8px ${aura.color || '#fff'}66`;
            }
        }

        // Session best tracking
        let sessionBestAura = null;
        let totalRaritySum = 0;

        // --- Debounced Stats Panel Updates ---
        let _statsPanelPending = null;

        function updateStatsPanel() {
            // Debounce: only update once every 250ms during rapid rolls
            if (_statsPanelPending) return;

            _statsPanelPending = requestAnimationFrame(() => {
                _statsPanelPending = null;
                _doUpdateStatsPanel();
            });
        }

        function _doUpdateStatsPanel() {
            // Total Rolls
            const totalRollsEl = document.getElementById('stat-total-rolls');
            if (totalRollsEl) {
                totalRollsEl.textContent = playerStats.totalRolls.toLocaleString();
            }

            // Best Aura (All Time)
            const bestAuraEl = document.getElementById('stat-best-aura');
            if (bestAuraEl && playerStats.bestAura) {
                const aura = AURAS.find(a => a.id === playerStats.bestAura);
                if (aura) {
                    // Show native rarity for native auras
                    const displayChance = (isAuraNative(aura) && aura.nativeChance) ? aura.nativeChance : aura.chance;
                    bestAuraEl.textContent = `${aura.name} [1/${displayChance.toLocaleString()}]`;
                    bestAuraEl.title = `1/${displayChance.toLocaleString()}`;
                    applyAuraStyling(bestAuraEl, aura);
                }
            } else if (bestAuraEl) {
                bestAuraEl.textContent = 'None';
                bestAuraEl.style.color = 'rgba(255,255,255,0.5)';
                bestAuraEl.style.fontFamily = "'Sarpanch', sans-serif";
            }

            // Session Best Aura
            const sessionBestEl = document.getElementById('stat-session-best');
            if (sessionBestEl) {
                if (sessionBestAura) {
                    const aura = AURAS.find(a => a.id === sessionBestAura);
                    if (aura) {
                        // Show native rarity for native auras
                        const displayChance = (isAuraNative(aura) && aura.nativeChance) ? aura.nativeChance : aura.chance;
                        sessionBestEl.textContent = `${aura.name} [1/${displayChance.toLocaleString()}]`;
                        sessionBestEl.title = `1/${displayChance.toLocaleString()}`;
                        applyAuraStyling(sessionBestEl, aura);
                    }
                } else {
                    sessionBestEl.textContent = 'None';
                    sessionBestEl.style.color = 'rgba(255,255,255,0.5)';
                    sessionBestEl.style.fontFamily = "'Sarpanch', sans-serif";
                }
            }

            // Equipped Aura
            const equippedEl = document.getElementById('stat-equipped-aura');
            if (equippedEl) {
                if (currentEquippedAura) {
                    equippedEl.textContent = currentEquippedAura.name;
                    // Show native rarity for native auras
                    const displayChance = (isAuraNative(currentEquippedAura) && currentEquippedAura.nativeChance) ? currentEquippedAura.nativeChance : currentEquippedAura.chance;
                    equippedEl.title = `1/${displayChance.toLocaleString()}`;
                    applyAuraStyling(equippedEl, currentEquippedAura);
                } else {
                    equippedEl.textContent = 'None';
                    equippedEl.style.color = 'rgba(255,255,255,0.5)';
                    equippedEl.style.fontFamily = "'Sarpanch', sans-serif";
                }
            }

            // Collected Auras
            const collectedEl = document.getElementById('stat-collected');
            if (collectedEl) {
                const collected = Object.keys(playerStats.collectedAuras).length;
                const total = AURAS.filter(a => !a.unrollable).length;
                collectedEl.textContent = `${collected} / ${total}`;

                // Color based on completion percentage
                const percent = collected / total;
                if (percent >= 1) {
                    collectedEl.style.color = '#ffd700'; // Gold for 100%
                } else if (percent >= 0.5) {
                    collectedEl.style.color = '#2ecc71'; // Green for 50%+
                } else {
                    collectedEl.style.color = '#3498db'; // Blue
                }
            }

            // Average Rarity
            const avgRarityEl = document.getElementById('stat-avg-rarity');
            if (avgRarityEl) {
                if (playerStats.totalRolls > 0) {
                    const avg = Math.round(totalRaritySum / playerStats.totalRolls);
                    avgRarityEl.textContent = `1/${avg.toLocaleString()}`;

                    // Color based on average
                    if (avg >= 100000) {
                        avgRarityEl.style.color = '#ff00ff';
                    } else if (avg >= 10000) {
                        avgRarityEl.style.color = '#9b59b6';
                    } else if (avg >= 1000) {
                        avgRarityEl.style.color = '#3498db';
                    } else {
                        avgRarityEl.style.color = 'rgba(255,255,255,0.6)';
                    }
                } else {
                    avgRarityEl.textContent = 'N/A';
                    avgRarityEl.style.color = 'rgba(255,255,255,0.5)';
                }
            }

            // Biome Luck Multiplier
            const biomeLuckEl = document.getElementById('stat-biome-luck');
            if (biomeLuckEl) {
                const biomeMult = currentBiome?.multiplier || 1;
                biomeLuckEl.textContent = `x${biomeMult}`;

                if (biomeMult > 1) {
                    biomeLuckEl.style.color = '#00ffaa';
                    biomeLuckEl.style.textShadow = '0 0 5px #00ffaa66';
                } else {
                    biomeLuckEl.style.color = 'rgba(255,255,255,0.6)';
                    biomeLuckEl.style.textShadow = 'none';
                }
            }

            // Current Luck - using OFFICIAL SOL'S RNG FORMULA:
            // ((1 + Basic Buffs) * Bonus Roll + Special Buffs) * VIP
            const luckEl = document.getElementById('stat-luck');
            if (luckEl) {
                const vipMultiplier = getVIPMultiplier();

                // For display, we don't include special buffs (one-time potions)
                // unless one is queued for the next roll.
                const queuedOneTimeStats = getNextQueuedOneTimeStats();
                let displayLuck = calculateLuckFromFormula(
                    currentBonusRollMultiplier,
                    queuedOneTimeStats,
                    !!queuedOneTimeStats
                );

                if (vipMultiplier > 1) {
                    if (hasVIP && hasVIPPlus) {
                        luckEl.style.color = '#9370db';
                    } else {
                        luckEl.style.color = '#ffd700';
                    }
                } else if (currentBonusRollMultiplier > 1) {
                    if (currentBonusRollMultiplier >= 5) {
                        luckEl.style.color = '#ff00ff';
                    } else if (currentBonusRollMultiplier >= 2.5) {
                        luckEl.style.color = '#e056fd';
                    } else {
                        luckEl.style.color = '#00fffa';
                    }
                } else {
                    luckEl.style.color = '#2ecc71';
                }

                let vipLabel = '';
                if (hasVIP && hasVIPPlus) {
                    vipLabel = ' <span style="font-size: 10px; color: #9370db;">VIP+</span>';
                } else if (hasVIP) {
                    vipLabel = ' <span style="font-size: 10px; color: #ffd700;">VIP</span>';
                } else if (hasVIPPlus) {
                    vipLabel = ' <span style="font-size: 10px; color: #9370db;">VIP+</span>';
                }

                luckEl.innerHTML = displayLuck.toFixed(1) + 'x' + vipLabel;
            }

            // Rolls Per Minute
            const rpmEl = document.getElementById('stat-rolls-per-min');
            if (rpmEl) {
                const now = Date.now();
                playerStats.recentRollTimestamps = playerStats.recentRollTimestamps.filter(t => now - t < 60000);
                const rpm = playerStats.recentRollTimestamps.length;
                rpmEl.textContent = rpm.toLocaleString();

                if (rpm >= 100) {
                    rpmEl.style.color = '#ff00ff';
                } else if (rpm >= 60) {
                    rpmEl.style.color = '#00d4ff';
                } else if (rpm >= 30) {
                    rpmEl.style.color = '#2ecc71';
                } else {
                    rpmEl.style.color = 'rgba(255,255,255,0.6)';
                }
            }

            // Rarest Biome
            const rarestBiomeEl = document.getElementById('stat-rarest-biome');
            if (rarestBiomeEl) {
                if (playerStats.rarestBiome) {
                    rarestBiomeEl.textContent = playerStats.rarestBiome;
                    rarestBiomeEl.style.color = '#ff9ff3';
                } else {
                    rarestBiomeEl.textContent = 'None';
                    rarestBiomeEl.style.color = 'rgba(255,255,255,0.5)';
                }
            }

            // Biomes Found
            const biomesFoundEl = document.getElementById('stat-biomes-found');
            if (biomesFoundEl) {
                const discovered = Object.keys(playerStats.biomesDiscovered).length;
                const totalBiomes = BIOMES.length;
                biomesFoundEl.textContent = `${discovered} / ${totalBiomes}`;

                if (discovered >= totalBiomes) {
                    biomesFoundEl.style.color = '#ffd700';
                } else if (discovered >= totalBiomes / 2) {
                    biomesFoundEl.style.color = '#2ecc71';
                } else {
                    biomesFoundEl.style.color = '#f39c12';
                }
            }

            // Native Auras
            const nativeAurasEl = document.getElementById('stat-native-auras');
            if (nativeAurasEl) {
                nativeAurasEl.textContent = playerStats.nativeAurasRolled.toLocaleString();
                nativeAurasEl.style.color = playerStats.nativeAurasRolled > 0 ? '#f1c40f' : 'rgba(255,255,255,0.5)';
            }

            // Bonus Rolls Hit
            const bonusRollsEl = document.getElementById('stat-bonus-rolls');
            if (bonusRollsEl) {
                bonusRollsEl.textContent = playerStats.bonusRollsHit.toLocaleString();
                bonusRollsEl.style.color = playerStats.bonusRollsHit > 0 ? '#00fffa' : 'rgba(255,255,255,0.5)';
            }

            // Lucky Streak (Best)
            const luckyStreakEl = document.getElementById('stat-lucky-streak');
            if (luckyStreakEl) {
                luckyStreakEl.textContent = playerStats.luckyStreak.toLocaleString();
                if (playerStats.luckyStreak >= 10) {
                    luckyStreakEl.style.color = '#ffd700';
                } else if (playerStats.luckyStreak >= 5) {
                    luckyStreakEl.style.color = '#2ecc71';
                } else {
                    luckyStreakEl.style.color = 'rgba(255,255,255,0.6)';
                }
            }

            // Dry Streak
            const dryStreakEl = document.getElementById('stat-dry-streak');
            if (dryStreakEl) {
                dryStreakEl.textContent = playerStats.dryStreak.toLocaleString();
                if (playerStats.dryStreak >= 1000) {
                    dryStreakEl.style.color = '#e74c3c';
                } else if (playerStats.dryStreak >= 500) {
                    dryStreakEl.style.color = '#f39c12';
                } else {
                    dryStreakEl.style.color = 'rgba(255,255,255,0.6)';
                }
            }

            const ptsEl = document.getElementById('stat-dm-points');
            if (ptsEl) {
                ptsEl.textContent = (playerStats.points || 0).toLocaleString();
            }

            const moneyEl = document.getElementById('stat-money');
            if (moneyEl) {
                moneyEl.textContent = '$' + (playerStats.money || 0).toLocaleString();
            }

            // Current Streak
            const currentStreakEl = document.getElementById('stat-current-streak');
            if (currentStreakEl) {
                currentStreakEl.textContent = playerStats.currentLuckyStreak.toLocaleString();
                if (playerStats.currentLuckyStreak >= 5) {
                    currentStreakEl.style.color = '#ffd700';
                } else if (playerStats.currentLuckyStreak >= 3) {
                    currentStreakEl.style.color = '#2ecc71';
                } else {
                    currentStreakEl.style.color = 'rgba(255,255,255,0.6)';
                }
            }

            // Gears Crafted
            const gearsCraftedEl = document.getElementById('stat-gears-crafted');
            if (gearsCraftedEl) {
                gearsCraftedEl.textContent = playerStats.gearsCrafted.toLocaleString();
                gearsCraftedEl.style.color = playerStats.gearsCrafted > 0 ? '#9b59b6' : 'rgba(255,255,255,0.5)';
            }

            // Potions Used
            const potionsUsedEl = document.getElementById('stat-potions-used');
            if (potionsUsedEl) {
                potionsUsedEl.textContent = playerStats.potionsUsed.toLocaleString();
                potionsUsedEl.style.color = playerStats.potionsUsed > 0 ? '#27ae60' : 'rgba(255,255,255,0.5)';
            }

            // Tier Counts
            const tierMapping = {
                'common': playerStats.tierCounts.common,
                'uncommon': playerStats.tierCounts.uncommon,
                'rare': playerStats.tierCounts.rare,
                'epic': playerStats.tierCounts.epic,
                'legendary': playerStats.tierCounts.legendary,
                'mythic': playerStats.tierCounts.mythic,
                'exalted': playerStats.tierCounts.exalted,
                'glorious': playerStats.tierCounts.glorious,
                'transcendent': playerStats.tierCounts.transcendent
            };

            for (const [tier, count] of Object.entries(tierMapping)) {
                const el = document.getElementById(`stat-tier-${tier}`);
                if (el) {
                    el.textContent = count.toLocaleString();
                    el.style.color = count > 0 ? '#fff' : 'rgba(255,255,255,0.3)';
                }
            }

            // Playtime
            updatePlaytimeDisplay();
        }

        function updatePlaytimeDisplay() {
            const playtimeEl = document.getElementById('stat-playtime');
            if (playtimeEl) {
                const hours = Math.floor(playerStats.playtimeSeconds / 3600);
                const minutes = Math.floor((playerStats.playtimeSeconds % 3600) / 60);
                const seconds = playerStats.playtimeSeconds % 60;
                playtimeEl.textContent = `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
        }

        function recordRoll(aura, oneTimeStatsUsed = null) {
            // Increment total rolls
            playerStats.totalRolls++;
            playerStats.rollsThisSession++;
            updateRollCount();

            // Jackpot Gauntlet Reward
            if (aura.id === 'jackpot' && playerInventory.equipped.left === 'jackpot-gauntlet') {
                playerStats.money = (playerStats.money || 0) + 77;
                showNotification('Jackpot Bonus: +$77!', '#f1c40f');
            }

            // Dark Matter Device Reward
            if (playerInventory.equipped.left === 'dark-matter-device' && currentBonusRollMultiplier > 1) {
                if (Math.random() < 0.001) {
                    playerStats.points = (playerStats.points || 0) + 1;
                    showNotification('Dark Matter: +1 POINT!', '#e056fd');
                }
            }

            // Track roll timestamp for RPM calculation (with cleanup to prevent memory buildup)
            const now = Date.now();
            playerStats.recentRollTimestamps.push(now);
            // Keep only last 60 seconds of timestamps
            while (playerStats.recentRollTimestamps.length > 0 && playerStats.recentRollTimestamps[0] < now - 60000) {
                playerStats.recentRollTimestamps.shift();
            }

            // Store rolled aura entry in Aura Storage (except "Nothing")
            const rollLuckSnapshot = calculateLuckFromFormula(currentBonusRollMultiplier, oneTimeStatsUsed, !!oneTimeStatsUsed);
            addAuraToStorage(aura, rollLuckSnapshot);

            // Check if this is a new unique aura
            if (!playerStats.collectedAuras[aura.id]) {
                playerStats.collectedAuras[aura.id] = true;
            }

            // Check if this is the best (rarest) aura
            if (!playerStats.bestAura) {
                playerStats.bestAura = aura.id;
            } else {
                const currentBest = getAuraById(playerStats.bestAura);
                if (currentBest && aura.chance > currentBest.chance) {
                    playerStats.bestAura = aura.id;
                }
            }

            // Track session best aura
            if (!sessionBestAura) {
                sessionBestAura = aura.id;
            } else {
                const currentSessionBest = getAuraById(sessionBestAura);
                if (currentSessionBest && aura.chance > currentSessionBest.chance) {
                    sessionBestAura = aura.id;
                }
            }

            // Track total rarity for average calculation
            totalRaritySum += (aura.chance || 1);

            // Track tier counts
            const effectiveChance = aura.chance || 1;
            if (effectiveChance >= 1000000000) {
                playerStats.tierCounts.transcendent++;
            } else if (effectiveChance >= 100000000) {
                playerStats.tierCounts.glorious++;
            }


            else if (effectiveChance >= 10000000) {
                playerStats.tierCounts.exalted++;
            } else if (effectiveChance >= 1000000) {
                playerStats.tierCounts.mythic++;
            } else if (effectiveChance >= 100000) {
                playerStats.tierCounts.legendary++;
            } else if (effectiveChance >= 10000) {
                playerStats.tierCounts.epic++;
            } else if (effectiveChance >= 1000) {
                playerStats.tierCounts.rare++;
            } else if (effectiveChance >= 100) {
                playerStats.tierCounts.uncommon++;
            } else {
                playerStats.tierCounts.common++;
            }

            // --- Achievement Tracking ---
            // Track highest rarity
            if (aura.chance > playerAchievements.highestRarityFound) {
                playerAchievements.highestRarityFound = aura.chance;
            }

            // Track breakthroughs
            if (aura.biome && aura.biome.length > 0) {
                // If we rolled a biome-exclusive aura while NOT in that biome, it's a breakthrough
                // (Assuming currentBiome.name matches one of the strings in aura.biome)
                if (currentBiome && !aura.biome.includes(currentBiome.name)) {
                    playerAchievements.breakthroughCount++;
                }
            }

            checkAchievements();

            // Track native auras
            if (isAuraNative(aura) && aura.nativeChance) {
                playerStats.nativeAurasRolled++;
            }

            // Track streaks (10k+ is considered lucky)
            if (effectiveChance >= 10000) {
                playerStats.currentLuckyStreak++;
                if (playerStats.currentLuckyStreak > playerStats.luckyStreak) {
                    playerStats.luckyStreak = playerStats.currentLuckyStreak;
                }
                playerStats.currentDryStreak = 0;
            } else {
                playerStats.currentDryStreak++;
                if (playerStats.currentDryStreak > playerStats.dryStreak) {
                    playerStats.dryStreak = playerStats.currentDryStreak;
                }
                playerStats.currentLuckyStreak = 0;
            }

            // Log aura find to the log panel
            logAuraFind(aura);

            // Update the stats panel
            updateStatsPanel();
        }

        // --- Aura Log System ---
        let playerUsername = '@Player'; // Can be customized via UI

        function logAuraFind(aura) {
            const logContent = document.getElementById('aura-log-content');
            const thresholdSelect = document.getElementById('aura-log-threshold');
            if (!logContent || !thresholdSelect) return;

            // Check if native
            const native = isAuraNative(aura) && aura.nativeChance;

            // Get the rarity number - use native chance if applicable
            let rarityNumber = native ? aura.nativeChance : (aura.chance || 1);

            // Skip if rarity is invalid
            if (rarityNumber <= 0 || !isFinite(rarityNumber)) {
                rarityNumber = 1;
            }

            const threshold = parseInt(thresholdSelect.value) || 0;

            // Check if this aura meets the threshold
            if (rarityNumber < threshold) return;

            // Check native-only filter (use global variable)
            if (typeof auraLogNativeOnly !== 'undefined' && auraLogNativeOnly && !native) return;

            // Determine color class based on rarity
            let colorClass = '';
            if (rarityNumber >= 1000000000) {
                colorClass = 'aura-log-rarity-transcendent';
            } else if (rarityNumber >= 100000000) {
                colorClass = 'aura-log-rarity-magenta';
            } else if (rarityNumber >= 10000000) {
                colorClass = 'aura-log-rarity-darkblue';
            } else if (rarityNumber >= 1000000) {
                colorClass = 'aura-log-rarity-purple';
            } else if (rarityNumber >= 100000) {
                colorClass = 'aura-log-rarity-blue';
            } else {
                colorClass = 'aura-log-rarity-common';
            }

            // Create log entry
            const entry = document.createElement('div');
            entry.className = 'aura-log-entry';

            const formattedNumber = rarityNumber.toLocaleString();
            const nativeLabel = native ? '<span style="color: #2ecc71; font-weight: bold;"> [NATIVE]</span>' : '';

            // Build aura name with proper styling (font + gradient)
            let auraNameStyle = '';
            if (aura.gradient) {
                auraNameStyle = `
                    background: ${aura.gradient};
                    background-clip: text;
                    -webkit-background-clip: text;
                    color: transparent;
                    -webkit-text-fill-color: transparent;
                    font-family: ${aura.fontFamily || "'Sarpanch', sans-serif"};
                `;
            } else {
                auraNameStyle = `
                    color: ${aura.color || '#fff'};
                    text-shadow: 0 0 8px ${aura.color || '#fff'}66;
                    font-family: ${aura.fontFamily || "'Sarpanch', sans-serif"};
                `;
            }

            // Add biome context if in special biome and show biome is enabled
            let biomeContext = '';
            const showBiome = typeof auraLogShowBiome === 'undefined' ? true : auraLogShowBiome;
            if (showBiome && currentBiome && currentBiome.name !== 'NORMAL') {
                biomeContext = `<span style="color: ${currentBiome.color || '#888'}; font-size: 10px;"> [${currentBiome.name}]</span>`;
            }

            entry.innerHTML = `
                <span class="aura-log-player">${playerUsername}</span>
                <span class="aura-log-action"> HAS FOUND </span>
                <span class="aura-log-aura" style="${auraNameStyle}">${aura.name}</span>${nativeLabel}${biomeContext}
                <span class="aura-log-action">, CHANCE OF </span>
                <span class="aura-log-chance ${colorClass}">1 IN ${formattedNumber}</span>
            `;

            // Add to top of log
            logContent.insertBefore(entry, logContent.firstChild);

            // Limit log entries to 100 (increased from 50)
            while (logContent.children.length > 100) {
                logContent.removeChild(logContent.lastChild);
            }

            // Update the log count display
            if (typeof updateAuraLogCount === 'function') {
                updateAuraLogCount();
            }
        }

        // Aura log toggle
        const auraLogToggle = document.getElementById('aura-log-toggle');
        if (auraLogToggle) {
            auraLogToggle.addEventListener('click', () => {
                const content = document.getElementById('aura-log-content');
                if (content) {
                    content.classList.toggle('collapsed');
                    auraLogToggle.textContent = content.classList.contains('collapsed') ? '+' : '-';
                }
            });
        }

        // Aura log username update
        const auraLogUsernameInput = document.getElementById('aura-log-username');
        if (auraLogUsernameInput) {
            auraLogUsernameInput.addEventListener('input', (e) => {
                playerUsername = e.target.value.trim() || '@Player';
            });
        }

        // Aura log clear button
        const auraLogClearBtn = document.getElementById('aura-log-clear');
        if (auraLogClearBtn) {
            auraLogClearBtn.addEventListener('click', () => {
                const logContent = document.getElementById('aura-log-content');
                if (logContent) {
                    logContent.innerHTML = '';
                    updateAuraLogCount();
                    showNotification('Aura log cleared', '#ff6b6b');
                }
            });
        }

        // Aura log filter states
        let auraLogNativeOnly = false;
        let auraLogShowBiome = true;

        // Native only filter
        const nativeOnlyCheckbox = document.getElementById('aura-log-native-only');
        if (nativeOnlyCheckbox) {
            nativeOnlyCheckbox.addEventListener('change', (e) => {
                auraLogNativeOnly = e.target.checked;
            });
        }

        // Show biome filter
        const showBiomeCheckbox = document.getElementById('aura-log-show-biome');
        if (showBiomeCheckbox) {
            showBiomeCheckbox.addEventListener('change', (e) => {
                auraLogShowBiome = e.target.checked;
            });
        }

        // Update log count display
        function updateAuraLogCount() {
            const logContent = document.getElementById('aura-log-content');
            const countEl = document.getElementById('aura-log-count');
            if (logContent && countEl) {
                countEl.textContent = logContent.children.length;
            }
        }

        // Update biome display in log panel
        function updateAuraLogBiomeDisplay() {
            const biomeDisplayEl = document.getElementById('aura-log-biome-display');
            if (biomeDisplayEl && currentBiome) {
                if (currentBiome.name !== 'NORMAL') {
                    biomeDisplayEl.innerHTML = `<span style="color: ${currentBiome.color || '#888'};">Biome: ${currentBiome.name}</span>`;
                } else {
                    biomeDisplayEl.innerHTML = '';
                }
            }
        }
        // --- Force Roll Functionality ---
        let selectedForceRollAura = null;

        const forceRollSearch = document.getElementById('admin-force-roll-search');
        const forceRollList = document.getElementById('admin-force-roll-list');
        const forceRollBtn = document.getElementById('admin-force-roll-btn');

        if (forceRollSearch && forceRollList) {
            forceRollSearch.addEventListener('input', () => {
                const query = forceRollSearch.value.toLowerCase().trim();
                if (query.length < 1) {
                    forceRollList.style.display = 'none';
                    return;
                }

                // Filter auras by name or ID
                const matches = AURAS.filter(a =>
                    a.name.toLowerCase().includes(query) ||
                    a.id.toLowerCase().includes(query)
                ).slice(0, 20); // Limit to 20 results

                if (matches.length === 0) {
                    forceRollList.innerHTML = '<div style="padding: 10px; color: #888; text-align: center;">No auras found</div>';
                    forceRollList.style.display = 'block';
                    return;
                }

                forceRollList.innerHTML = '';
                matches.forEach(aura => {
                    const item = document.createElement('div');
                    item.style.cssText = `
                        padding: 8px 12px;
                        cursor: pointer;
                        border-bottom: 1px solid rgba(255,255,255,0.1);
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        transition: background 0.2s;
                    `;
                    item.innerHTML = `
                        <span style="color: ${aura.color || '#fff'}; font-family: ${aura.fontFamily || 'inherit'};">${aura.name}</span>
                        <span style="color: #888; font-size: 10px;">1 in ${aura.chance.toLocaleString()}</span>
                    `;
                    item.addEventListener('mouseenter', () => {
                        item.style.background = 'rgba(0, 206, 201, 0.2)';
                    });
                    item.addEventListener('mouseleave', () => {
                        item.style.background = 'transparent';
                    });
                    item.addEventListener('click', () => {
                        selectedForceRollAura = aura;
                        forceRollSearch.value = aura.name;
                        forceRollSearch.style.color = aura.color || '#00cec9';
                        forceRollSearch.style.fontFamily = aura.fontFamily || "'Sarpanch', sans-serif";
                        forceRollList.style.display = 'none';
                        showNotification(`Selected: ${aura.name}`, aura.color || '#00cec9');
                    });
                    forceRollList.appendChild(item);
                });
                forceRollList.style.display = 'block';
            });

            // Hide dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (!forceRollSearch.contains(e.target) && !forceRollList.contains(e.target)) {
                    forceRollList.style.display = 'none';
                }
            });
        }

        if (forceRollBtn) {
            forceRollBtn.addEventListener('click', () => {
                if (!selectedForceRollAura) {
                    showNotification('Please select an aura first!', '#ff6b6b');
                    return;
                }

                const aura = selectedForceRollAura;

                // Queue this aura for the next roll
                window.forcedNextRollAura = aura;

                // Close admin panel
                const adminPanel = document.querySelector('.admin-panel');
                if (adminPanel) adminPanel.classList.remove('active');
                const rollOverlay = document.getElementById('roll-overlay');
                if (rollOverlay) rollOverlay.style.visibility = 'visible';

                // Notify user
                showNotification(`Next roll queued: ${aura.name}`, aura.color || '#00cec9');
                showNotification(`Click ROLL to trigger it!`, '#ffd700');

                // Reset selection
                selectedForceRollAura = null;
                forceRollSearch.value = '';
                forceRollSearch.style.color = '';
                forceRollSearch.style.fontFamily = "'Sarpanch', sans-serif";
            });
        }

        function playTextCutscene(aura, onComplete) {
            // Hide the roll overlay during text cutscene
            const rollOverlay = document.getElementById('roll-overlay');
            if (rollOverlay) rollOverlay.style.visibility = 'hidden';

            // Wrap onComplete to restore roll overlay visibility
            const wrappedOnComplete = () => {
                if (rollOverlay) rollOverlay.style.visibility = 'visible';
                if (onComplete) onComplete();
            };

            // Use the global cutscene gate to keep text/video behavior consistent.
            if (!shouldShowCutscene(aura)) {
                wrappedOnComplete();
                return;
            }

            // Determine theme based on aura
            const isAeternitas = aura.id === 'aeternitas';
            const isAnotherRealm = aura.id === 'another_realm';
            const isSingularity = aura.id === 'singularity';
            const isMagnumOpus = aura.id === 'magnum_opus';
            const isToll = aura.id === 'toll';
            let tollSceneEl = null;
            let tollBellTriggerTimeout = null;
            let tollBellAudio = null;
            let tollBellFadeInterval = null;

            const stopTollBellAudio = (immediate = false) => {
                if (!tollBellAudio) return;

                if (tollBellFadeInterval) {
                    clearInterval(tollBellFadeInterval);
                    tollBellFadeInterval = null;
                }

                if (immediate) {
                    tollBellAudio.pause();
                    tollBellAudio.currentTime = 0;
                    tollBellAudio = null;
                    return;
                }

                const steps = 12;
                const stepMs = 100;
                const startVolume = Number.isFinite(tollBellAudio.volume) ? tollBellAudio.volume : 1;
                let currentStep = 0;

                tollBellFadeInterval = setInterval(() => {
                    currentStep++;
                    const nextVolume = Math.max(0, startVolume * (1 - currentStep / steps));
                    tollBellAudio.volume = nextVolume;
                    if (currentStep >= steps) {
                        clearInterval(tollBellFadeInterval);
                        tollBellFadeInterval = null;
                        tollBellAudio.pause();
                        tollBellAudio.currentTime = 0;
                        tollBellAudio = null;
                    }
                }, stepMs);
            };

            let theme;
            if (isAeternitas) {
                theme = {
                    bgGradient: 'radial-gradient(circle at center, #2a1f0a 0%, #0d0906 50%, #000000 100%)',
                    particleColor: '#c9a227',
                    particleAlpha: 0.03,
                    textColor: '#c9a227',
                    textShadow: '0 0 20px rgba(201, 162, 39, 0.8), 0 0 40px rgba(201, 162, 39, 0.4)',
                    fontFamily: "'Cinzel', serif",
                    fontSize: '28px',
                    cursorColor: '#c9a227',
                    ambienceType: 'desert'
                };
            } else if (isAnotherRealm) {
                theme = {
                    bgGradient: 'radial-gradient(circle at center, #1a0a2e 0%, #0d001a 50%, #000000 100%)',
                    particleColor: '#8e44ad',
                    particleAlpha: 0.025,
                    textColor: '#00ffff',
                    textShadow: '0 0 20px rgba(0, 255, 255, 0.8), 0 0 40px rgba(142, 68, 173, 0.6), 0 0 60px rgba(255, 0, 255, 0.4)',
                    fontFamily: "'Orbitron', 'Courier New', monospace",
                    fontSize: '26px',
                    cursorColor: '#ff00ff',
                    ambienceType: 'dimensional'
                };
            } else if (isSingularity) {
                theme = {
                    bgGradient: 'black',
                    particleColor: '#00ffff',
                    particleAlpha: 0.05,
                    textColor: '#00ffff',
                    textShadow: '2px 2px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000, 0 0 20px rgba(0, 255, 255, 0.8), 0 0 40px rgba(255, 255, 255, 0.4)',
                    fontFamily: "'Martian Mono', monospace",
                    fontSize: '32px',
                    cursorColor: '#00ffff',
                    ambienceType: 'void',
                    textAlign: 'center'
                };
            } else if (isMagnumOpus) {
                theme = {
                    bgGradient: 'radial-gradient(circle at center, #1a1508 0%, #0a0805 50%, #000000 100%)',
                    particleColor: '#f1c40f',
                    particleAlpha: 0.04,
                    textColor: '#f1c40f',
                    textShadow: '0 0 20px rgba(241, 196, 15, 0.8), 0 0 40px rgba(255, 255, 255, 0.4)',
                    fontFamily: "'Cinzel', serif",
                    fontSize: '36px',
                    cursorColor: '#f1c40f',
                    ambienceType: 'desert',
                    textAlign: 'center'
                };
            } else if (isToll) {
                theme = {
                    bgGradient: 'black',
                    particleColor: '#e3b695',
                    particleAlpha: 0.03,
                    textColor: '#e3b695',
                    textShadow: '0 0 20px rgba(227, 182, 149, 0.8), 0 0 40px rgba(183, 181, 180, 0.4)',
                    fontFamily: "'Cinzel', serif",
                    fontSize: '32px',
                    cursorColor: '#b7b5b4',
                    ambienceType: 'fog',
                    textAlign: 'center'
                };
            } else {
                theme = {
                    bgGradient: 'radial-gradient(circle at center, #2c3e50 0%, #000000 85%)',
                    particleColor: '#ffffff',
                    particleAlpha: 0.02,
                    textColor: '#fff',
                    textShadow: '0 0 10px rgba(255, 255, 255, 0.5)',
                    fontFamily: "'Courier New', monospace",
                    fontSize: '24px',
                    cursorColor: '#fff',
                    ambienceType: 'fog'
                };
            }

            // 1. Generate Fog Texture Programmatically (True Transparency)
            const generateFogDataURL = () => {
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 512;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, 512, 512);

                // Parse theme color to RGB
                const hexToRgb = (hex) => {
                    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                    return result ? {
                        r: parseInt(result[1], 16),
                        g: parseInt(result[2], 16),
                        b: parseInt(result[3], 16)
                    } : { r: 255, g: 255, b: 255 };
                };
                const rgb = hexToRgb(theme.particleColor);

                for (let i = 0; i < 800; i++) {
                    const x = Math.random() * 512;
                    const y = Math.random() * 512;
                    const r = 30 + Math.random() * 70;
                    const alpha = theme.particleAlpha + Math.random() * 0.02;
                    const g = ctx.createRadialGradient(x, y, 0, x, y, r);
                    g.addColorStop(0, `rgba(${rgb.r},${rgb.g},${rgb.b},${alpha})`);
                    g.addColorStop(1, `rgba(${rgb.r},${rgb.g},${rgb.b},0)`);
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(x, y, r, 0, Math.PI * 2);
                    ctx.fill();
                    [[x - 512, y], [x + 512, y], [x, y - 512], [x, y + 512]].forEach(pos => {
                        const g2 = ctx.createRadialGradient(pos[0], pos[1], 0, pos[0], pos[1], r);
                        g2.addColorStop(0, `rgba(${rgb.r},${rgb.g},${rgb.b},${alpha})`);
                        g2.addColorStop(1, `rgba(${rgb.r},${rgb.g},${rgb.b},0)`);
                        ctx.fillStyle = g2;
                        ctx.beginPath();
                        ctx.arc(pos[0], pos[1], r, 0, Math.PI * 2);
                        ctx.fill();
                    });
                }
                return canvas.toDataURL();
            };
            const fogDataUrl = generateFogDataURL();

            // 1. Inject CSS if needed
            if (!document.getElementById('text-cutscene-styles')) {
                const style = document.createElement('style');
                style.id = 'text-cutscene-styles';
                style.textContent = `
                    #text-cutscene-overlay {
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: radial-gradient(circle at center, #2c3e50 0%, #000000 85%);
                        z-index: 99999;
                        opacity: 0;
                        transition: opacity 2s ease;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        flex-direction: column;
                        pointer-events: none;
                    }
                    #text-cutscene-overlay.active {
                        opacity: 1;
                        pointer-events: auto;
                    }

                    /* Fog Animation */
                    .fog-container {
                        position: absolute;
                        width: 100%;
                        height: 100%;
                        overflow: hidden;
                        z-index: 1;
                        opacity: 0.4;
                    }
                    .fog-layer {
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 200%;
                        height: 100%;
                        /* bg set via inline style */
                        background-size: 50% 100%;
                        animation: fog-scroll 60s linear infinite;
                    }
                    .fog-layer:nth-child(2) {
                        top: 0;
                        width: 200%;
                        height: 100%;
                        animation-duration: 45s;
                        animation-direction: reverse;
                        opacity: 0.6;
                        transform: scale(1.5); /* Different scale for depth */
                    }

                    @keyframes fog-scroll {
                        0% { transform: translateX(0); }
                        100% { transform: translateX(-50%); }
                    }

                    /* Text Styles */
                    #text-cutscene-content {
                        z-index: 10;
                        text-align: center;
                        font-family: 'Courier New', monospace; /* Typewriter feel */
                        color: #fff;
                        font-size: 24px;
                        font-weight: bold;
                        letter-spacing: 2px;
                        text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
                        opacity: 0;
                        transition: opacity 0.5s ease;
                        max-width: 80%;
                    }
                    .typewriter-cursor {
                        display: inline-block;
                        width: 10px;
                        height: 24px;
                        background: #fff;
                        animation: cursor-blink 1s step-end infinite;
                        vertical-align: middle;
                        margin-left: 5px;
                    }
                    @keyframes cursor-blink {
                        0%, 100% { opacity: 1; }
                        50% { opacity: 0; }
                    }
                `;
                document.head.appendChild(style);
            }

            // 2. Create Overlay Elements
            const overlay = document.createElement('div');
            overlay.id = 'text-cutscene-overlay';
            // Apply theme-specific background
            overlay.style.background = theme.bgGradient;
            overlay.style.transition = 'background 2s ease, filter 0.5s ease';

            // Hide Game UI for immersion
            const hideGameUI = (hide) => {
                const uiElements = ['.game-info', '.admin-btn', '.left-sidebar', '.stats-panel', '.inventory-btn', '.storage-btn', '.items-btn', '#menu-btn', '.main-container'];
                uiElements.forEach(selector => {
                    const el = document.querySelector(selector);
                    if (el) el.style.opacity = hide ? '0' : '1';
                    if (el) el.style.pointerEvents = hide ? 'none' : 'auto';
                    if (el) el.style.transition = 'opacity 0.5s ease';
                });
            };
            hideGameUI(true);

            // Different visual effects based on theme
            if (isAeternitas) {
                // === AETERNITAS SPECIAL VISUALS ===

                // Create falling sand canvas
                const sandCanvas = document.createElement('canvas');
                sandCanvas.id = 'aeternitas-sand-canvas';
                sandCanvas.style.cssText = 'position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; opacity: 0.6;';
                // Note: sandCanvas will be added to sceneContainer later

                // Add hourglass animation keyframes
                if (!document.getElementById('aeternitas-styles')) {
                    const aeternitasStyle = document.createElement('style');
                    aeternitasStyle.id = 'aeternitas-styles';
                    aeternitasStyle.textContent = `
                        @keyframes hourglass-pulse {
                            0%, 100% { opacity: 0.15; transform: translate(-50%, -50%) scale(1); }
                            50% { opacity: 0.25; transform: translate(-50%, -50%) scale(1.05); }
                        }
                        @keyframes hourglass-pulse-fast {
                            0%, 100% { opacity: 0.5; transform: translate(-50%, -50%) scale(1) rotate(-2deg); }
                            50% { opacity: 0.8; transform: translate(-50%, -50%) scale(1.1) rotate(2deg); }
                        }
                        @keyframes sand-shimmer {
                            0%, 100% { filter: brightness(1); }
                            50% { filter: brightness(1.3); }
                        }
                        @keyframes camera-zoom-in {
                            from { transform: scale(1); }
                            to { transform: scale(1.3); }
                        }
                        @keyframes camera-zoom-out {
                            from { transform: scale(1.3); }
                            to { transform: scale(1); }
                        }
                        @keyframes camera-pan-left {
                            from { transform: translateX(0); }
                            to { transform: translateX(-50px); }
                        }
                        @keyframes camera-pan-right {
                            from { transform: translateX(-50px); }
                            to { transform: translateX(50px); }
                        }
                        @keyframes slow-rotate {
                            from { transform: rotate(0deg); }
                            to { transform: rotate(360deg); }
                        }
                        @keyframes scene-wipe-down {
                            from { clip-path: inset(0 0 100% 0); }
                            to { clip-path: inset(0 0 0 0); }
                        }
                        @keyframes perspective-tilt {
                            0%, 100% { transform: perspective(1000px) rotateX(0deg); }
                            50% { transform: perspective(1000px) rotateX(5deg); }
                        }
                        @keyframes float-up {
                            from { transform: translateY(0); }
                            to { transform: translateY(-30px); }
                        }
                        @keyframes dramatic-zoom {
                            0% { transform: scale(1); filter: brightness(1); }
                            50% { transform: scale(1.5); filter: brightness(1.5); }
                            100% { transform: scale(1.2); filter: brightness(1.2); }
                        }
                        .aeternitas-scene-container {
                            position: absolute;
                            width: 100%;
                            height: 100%;
                            transition: all 2s cubic-bezier(0.4, 0, 0.2, 1);
                            transform-origin: center center;
                        }
                    `;
                    document.head.appendChild(aeternitasStyle);
                }

                // Create scene container for camera movements
                const sceneContainer = document.createElement('div');
                sceneContainer.className = 'aeternitas-scene-container';
                sceneContainer.id = 'aeternitas-scene';
                overlay.appendChild(sceneContainer);

                // Move sand canvas into scene container
                sceneContainer.appendChild(sandCanvas);

                // Create hourglass and add to scene container
                const hourglass = document.createElement('div');
                hourglass.id = 'aeternitas-hourglass';
                hourglass.innerHTML = `
                    <svg viewBox="0 0 100 150" style="width: 200px; height: 300px; opacity: 0.15; filter: drop-shadow(0 0 30px #c9a227); transition: all 2s ease;">
                        <defs>
                            <linearGradient id="hourglassGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                                <stop offset="0%" style="stop-color:#c9a227;stop-opacity:1" />
                                <stop offset="50%" style="stop-color:#8b7355;stop-opacity:0.8" />
                                <stop offset="100%" style="stop-color:#c9a227;stop-opacity:1" />
                            </linearGradient>
                        </defs>
                        <path d="M10,5 L90,5 L90,15 L55,70 L55,80 L90,135 L90,145 L10,145 L10,135 L45,80 L45,70 L10,15 Z" 
                              fill="none" stroke="url(#hourglassGrad)" stroke-width="3"/>
                        <ellipse cx="50" cy="10" rx="35" ry="5" fill="url(#hourglassGrad)" opacity="0.5"/>
                        <ellipse cx="50" cy="140" rx="35" ry="5" fill="url(#hourglassGrad)" opacity="0.5"/>
                    </svg>
                `;
                hourglass.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 2; animation: hourglass-pulse 4s ease-in-out infinite; transition: all 2s ease;';
                sceneContainer.appendChild(hourglass);

                // Initialize falling sand animation after overlay is added
                setTimeout(() => {
                    const canvas = document.getElementById('aeternitas-sand-canvas');
                    if (!canvas) return;
                    const ctx = canvas.getContext('2d');
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;

                    // MUCH more particles for intensity
                    const sandParticles = [];
                    for (let i = 0; i < 400; i++) {
                        sandParticles.push({
                            x: Math.random() * canvas.width,
                            y: Math.random() * canvas.height,
                            size: 0.5 + Math.random() * 3,
                            speed: 0.5 + Math.random() * 2,
                            baseSpeed: 0.5 + Math.random() * 2,
                            opacity: 0.2 + Math.random() * 0.6,
                            drift: (Math.random() - 0.5) * 2,
                            baseDrift: (Math.random() - 0.5) * 0.5,
                            phase: Math.random() * Math.PI * 2
                        });
                    }

                    // Time distortion variables
                    let timeWarp = 1;
                    let shakeX = 0, shakeY = 0;
                    let flashOpacity = 0;
                    let windDirection = 0;
                    let intensity = 1;

                    // Store these for scene transitions to modify
                    window.aeternitasEffects = {
                        setTimeWarp: (v) => timeWarp = v,
                        setShake: (x, y) => { shakeX = x; shakeY = y; },
                        flash: () => { flashOpacity = 1; },
                        setWind: (d) => windDirection = d,
                        setIntensity: (i) => intensity = i
                    };

                    let animationId;
                    let frame = 0;
                    const animateSand = () => {
                        frame++;
                        ctx.clearRect(0, 0, canvas.width, canvas.height);

                        // Draw lightning flash
                        if (flashOpacity > 0) {
                            ctx.fillStyle = `rgba(201, 162, 39, ${flashOpacity * 0.3})`;
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                            flashOpacity *= 0.9;
                        }

                        // Apply shake offset
                        ctx.save();
                        ctx.translate(shakeX, shakeY);
                        shakeX *= 0.9;
                        shakeY *= 0.9;

                        sandParticles.forEach(p => {
                            // Time distortion effect - some particles move backwards!
                            const timeEffect = Math.sin(frame * 0.01 + p.phase) * (timeWarp - 1);
                            const effectiveSpeed = (p.baseSpeed + timeEffect) * intensity;

                            // Wind effect
                            const windEffect = Math.sin(frame * 0.02) * windDirection;

                            ctx.beginPath();
                            // Draw as streaks when moving fast
                            if (intensity > 1.5) {
                                ctx.moveTo(p.x, p.y);
                                ctx.lineTo(p.x - p.drift * 3, p.y - effectiveSpeed * 3);
                                ctx.strokeStyle = `rgba(201, 162, 39, ${p.opacity})`;
                                ctx.lineWidth = p.size;
                                ctx.stroke();
                            } else {
                                ctx.arc(p.x, p.y, p.size * intensity, 0, Math.PI * 2);
                                ctx.fillStyle = `rgba(201, 162, 39, ${p.opacity})`;
                                ctx.fill();
                            }

                            p.y += effectiveSpeed;
                            p.x += p.baseDrift + windEffect;

                            // Wrap around
                            if (p.y > canvas.height) {
                                p.y = -5;
                                p.x = Math.random() * canvas.width;
                            }
                            if (p.y < -10 && effectiveSpeed < 0) {
                                p.y = canvas.height + 5;
                            }
                            if (p.x < 0) p.x = canvas.width;
                            if (p.x > canvas.width) p.x = 0;
                        });

                        ctx.restore();
                        animationId = requestAnimationFrame(animateSand);
                    };
                    animateSand();

                    // Store animation ID for cleanup
                    overlay.dataset.sandAnimation = animationId;
                }, 100);

            } else if (isAnotherRealm) {
                // === ANOTHER REALM: REALITY TEARING/GLITCH VISUALS ===
                // Completely different from Aeternitas - this is about reality BREAKING

                // Add glitch CSS
                if (!document.getElementById('realm-glitch-styles')) {
                    const glitchStyle = document.createElement('style');
                    glitchStyle.id = 'realm-glitch-styles';
                    glitchStyle.textContent = `
                        .realm-container {
                            position: absolute;
                            width: 100%;
                            height: 100%;
                            overflow: hidden;
                        }
                        .reality-slice {
                            position: absolute;
                            width: 100%;
                            left: 0;
                            background: linear-gradient(90deg, 
                                rgba(142,68,173,0) 0%, 
                                rgba(142,68,173,0.3) 20%,
                                rgba(0,255,255,0.5) 50%,
                                rgba(255,0,255,0.3) 80%,
                                rgba(255,0,255,0) 100%);
                            transition: transform 0.05s ease-out;
                            pointer-events: none;
                        }
                        .dimensional-rift {
                            position: absolute;
                            top: 0;
                            height: 100%;
                            width: 4px;
                            background: linear-gradient(180deg, 
                                transparent 0%, 
                                #00ffff 20%, 
                                #ffffff 50%, 
                                #ff00ff 80%, 
                                transparent 100%);
                            box-shadow: 0 0 20px #00ffff, 0 0 40px #ff00ff, 0 0 60px #fff;
                            opacity: 0;
                            transition: all 0.3s ease;
                        }
                        .static-overlay {
                            position: absolute;
                            top: 0;
                            left: 0;
                            width: 100%;
                            height: 100%;
                            opacity: 0;
                            pointer-events: none;
                            mix-blend-mode: overlay;
                        }
                        .scanlines {
                            position: absolute;
                            top: 0;
                            left: 0;
                            width: 100%;
                            height: 100%;
                            background: repeating-linear-gradient(
                                0deg,
                                transparent,
                                transparent 2px,
                                rgba(0, 0, 0, 0.15) 2px,
                                rgba(0, 0, 0, 0.15) 4px
                            );
                            pointer-events: none;
                            opacity: 0.6;
                        }
                        @keyframes rift-flicker {
                            0%, 100% { opacity: 0.8; }
                            50% { opacity: 1; }
                        }
                    `;
                    document.head.appendChild(glitchStyle);
                }

                // Create container
                const realmContainer = document.createElement('div');
                realmContainer.className = 'realm-container';
                realmContainer.id = 'realm-scene';
                overlay.appendChild(realmContainer);

                // Create horizontal reality slices (like screen tearing)
                const slices = [];
                for (let i = 0; i < 20; i++) {
                    const slice = document.createElement('div');
                    slice.className = 'reality-slice';
                    slice.style.top = `${i * 5}%`;
                    slice.style.height = '5%';
                    slice.dataset.index = i;
                    realmContainer.appendChild(slice);
                    slices.push(slice);
                }

                // Create dimensional rifts (vertical tears in reality)
                const rifts = [];
                for (let i = 0; i < 5; i++) {
                    const rift = document.createElement('div');
                    rift.className = 'dimensional-rift';
                    rift.style.left = `${15 + i * 17}%`;
                    rift.id = `rift-${i}`;
                    realmContainer.appendChild(rift);
                    rifts.push(rift);
                }

                // Create static noise canvas
                const staticCanvas = document.createElement('canvas');
                staticCanvas.className = 'static-overlay';
                staticCanvas.id = 'realm-static';
                realmContainer.appendChild(staticCanvas);

                // Add scanlines for CRT/glitch effect
                const scanlines = document.createElement('div');
                scanlines.className = 'scanlines';
                realmContainer.appendChild(scanlines);

                // Initialize glitch animation loop
                setTimeout(() => {
                    const canvas = document.getElementById('realm-static');
                    if (!canvas) return;
                    const ctx = canvas.getContext('2d');
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;



                    // Effect variables controlled by transitions
                    let glitchIntensity = 0;
                    let staticOpacity = 0;
                    let tearAmount = 0;
                    let riftOpenness = 0;

                    window.realmEffects = {
                        setGlitch: (v) => glitchIntensity = v,
                        setStatic: (v) => {
                            staticOpacity = v;
                            canvas.style.opacity = v;
                        },
                        setTear: (v) => tearAmount = v,
                        setRifts: (v) => {
                            riftOpenness = v;
                            rifts.forEach((rift, i) => {
                                rift.style.opacity = Math.min(1, v * (1 + i * 0.1));
                                rift.style.width = `${4 + v * 15}px`;
                                if (v > 0.3) rift.style.animation = 'rift-flicker 0.15s infinite';
                            });
                        },
                        invert: () => {
                            overlay.style.filter = 'invert(1) hue-rotate(180deg)';
                            setTimeout(() => overlay.style.filter = '', 80);
                        },
                        flash: (color = '#ffffff') => {
                            const flash = document.createElement('div');
                            flash.style.cssText = `position:absolute;top:0;left:0;width:100%;height:100%;background:${color};opacity:0.6;pointer-events:none;z-index:100;`;
                            realmContainer.appendChild(flash);
                            setTimeout(() => flash.remove(), 80);
                        },
                        shake: (x, y) => {
                            realmContainer.style.transform = `translate(${x}px, ${y}px)`;
                            setTimeout(() => realmContainer.style.transform = '', 80);
                        },
                        glitchBurst: () => {
                            // Rapid random slice movements
                            slices.forEach(slice => {
                                slice.style.transform = `translateX(${(Math.random() - 0.5) * 150}px)`;
                                slice.style.opacity = '0.8';
                            });
                            setTimeout(() => {
                                slices.forEach(slice => {
                                    slice.style.transform = '';
                                    slice.style.opacity = '0.3';
                                });
                            }, 100);
                        }
                    };

                    let frame = 0;
                    const animate = () => {
                        frame++;
                        // Draw static noise when needed
                        if (staticOpacity > 0.01) {
                            const imageData = ctx.createImageData(canvas.width, canvas.height);
                            const data = imageData.data;
                            for (let i = 0; i < data.length; i += 4) {
                                const noise = Math.random() * 255;
                                data[i] = noise;
                                data[i + 1] = noise;
                                data[i + 2] = noise;
                                data[i + 3] = Math.random() * 80 * staticOpacity;
                            }
                            ctx.putImageData(imageData, 0, 0);
                        } else {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                        }

                        // Animate reality slices (horizontal glitch tearing)
                        if (tearAmount > 0.01) {
                            slices.forEach((slice, i) => {
                                const wave = Math.sin(frame * 0.05 + i * 0.3) * tearAmount * 30;
                                const glitch = (Math.random() - 0.5) * glitchIntensity * 50;
                                slice.style.transform = `translateX(${wave + glitch}px)`;
                                slice.style.opacity = (0.2 + tearAmount * 0.5).toString();
                            });
                        }

                        // Random glitch spikes
                        if (glitchIntensity > 0.3 && Math.random() < glitchIntensity * 0.15) {
                            const randomSlice = slices[Math.floor(Math.random() * slices.length)];
                            randomSlice.style.transform = `translateX(${(Math.random() - 0.5) * 120}px)`;
                            randomSlice.style.background = `linear-gradient(90deg, 
                                rgba(${Math.random() > 0.5 ? '0,255,255' : '255,0,255'},0.6) 0%, 
                                rgba(${Math.random() > 0.5 ? '255,0,255' : '0,255,255'},0.6) 100%)`;
                        }
                        overlay.dataset.realmAnimation = requestAnimationFrame(animate);
                    };
                    animate();

                }, 100);

            } else if (isToll) {
                // === TOLL: THE BELL ===
                if (!document.getElementById('toll-styles')) {
                    const bellStyle = document.createElement('style');
                    bellStyle.id = 'toll-styles';
                    bellStyle.textContent = `
                        #toll-scene {
                            width: 100%;
                            height: 100%;
                            position: absolute;
                            top: 0;
                            left: 0;
                            display: flex;
                            justify-content: center;
                            align-items: center;
                            overflow: hidden;
                            perspective: 1000px;
                            background: #000;
                            opacity: 0;
                            transition: opacity 1.2s ease;
                            
                            /* CRITICAL SCALING: Defines 1em relative to viewport size */
                            --_size: min(min(600px, 50vh), 50vw);
                            font-size: calc(var(--_size) * 0.01); 
                            --base-clr: #b7b5b4;
                            --degofrot: 0.8;
                        }
                        
                        #toll-scene * {
                            box-sizing: border-box;
                            transition: filter 0.4s ease-in-out, box-shadow 0.4s ease-in-out,
                                opacity 0.4s ease-in-out, color 0.4s ease-in-out, background 0.4s ease-in-out,
                                text-shadow 0.4s ease-in-out, transform 0.4s ease-in-out;
                        }

                        #toll-scene .bell-container {
                            width: 80em;
                            height: 80em;
                            opacity: 1;
                            cursor: pointer;
                            transform-origin: 50% -50vh;
                            animation: none; /* No swing until activated */
                            position: absolute;
                            left: 0; right: 0; top: 0; bottom: 0; margin: auto;
                            z-index: 50;
                        }

                        #toll-scene .bell-container.off {
                            animation: none; /* Bell is static when off */
                        }

                        @keyframes bell {
                            0% { transform: rotate(calc(1deg * var(--degofrot))); }
                            50% { transform: rotate(calc(-1deg * var(--degofrot))); }
                            100% { transform: rotate(calc(1deg * var(--degofrot))); }
                        }

                        @keyframes bell-swing {
                            0% { transform: rotate(15deg); }
                            25% { transform: rotate(-12deg); }
                            50% { transform: rotate(10deg); }
                            75% { transform: rotate(-8deg); }
                            100% { transform: rotate(6deg); }
                        }

                        #toll-scene .bell-container.swinging {
                            animation: 0.8s ease-out bell-swing, 3s ease-in-out 0.8s infinite bell-active;
                        }

                        @keyframes bell-active {
                            0% { transform: rotate(6deg); }
                            50% { transform: rotate(-6deg); }
                            100% { transform: rotate(6deg); }
                        }

                        #toll-scene .bell-container div {
                            position: absolute;
                            left: 0; right: 0; top: 0; bottom: 0; margin: auto;
                        }

                        #toll-scene .rope {
                            height: 50vh;
                            width: 2em;
                            transform: translateY(-52%);
                            background: linear-gradient(90deg, #2d54744d 0%, #000b 30%, transparent 100%),
                                        repeating-linear-gradient(-70deg, #252525, #888 2%, #3a3a3a 3%);
                        }

                        #toll-scene .bell-top {
                            width: 14%; height: 14%; border-radius: 50%;
                            transform: translateY(-28em);
                            background: var(--base-clr);
                            box-shadow: inset -1em -0.5em 2em 0.5em #fff, inset 1em -1em 2em 3em #000,
                                0 -0.1em 0.4em 0.3em #c6eaffa8;
                        }

                        #toll-scene .bell-base {
                            width: 50%; height: 50%; border-radius: 50%;
                            transform: translateY(-24%);
                            background: var(--base-clr);
                            box-shadow: 0 -0.1em 0.4em 0.2em #c6eaffa8;
                        }
                        #toll-scene .bell-base:before {
                            content: "";
                            background-image: radial-gradient(circle at -80% -12%, transparent 50em, var(--base-clr) 50em);
                            position: absolute;
                            transform: translate(-18em, 20em);
                            width: 100%; height: 80%;
                        }
                        #toll-scene .bell-base:after {
                            content: "";
                            background-image: radial-gradient(circle at -80% -12%, transparent 50.1em, #cacaca 50.3em, var(--base-clr) 50.5em);
                            position: absolute;
                            transform: translate(18em, 20em) rotateY(180deg);
                            width: 100%; height: 80%;
                        }
                        #toll-scene .bell-base:nth-child(2) {
                            filter: brightness(3) blur(1em);
                            transform: scale(0.74, 0.84) translateY(-11em);
                        }

                        #toll-scene .shadow-l1 {
                            width: 30em; height: 42em; border-radius: 50%;
                            transform: rotate(12deg) translate(-3em, -6em);
                            filter: blur(2em); background: #797a80;
                        }
                        #toll-scene .shadow-l2 {
                            width: 130%; height: 90%; filter: blur(5em); transform: translate(-6em, 9em);
                        }
                        
                        #toll-scene .glow { width: 100%; height: 100%; filter: brightness(2) blur(2em); }
                        #toll-scene .glow::before {
                            content: ""; display: block; width: 100%; height: 80%;
                            transform: translateY(6em) scale(0.94, 0.94);
                            background: #fff3;
                            clip-path: polygon(9% 83%, 12% 79%, 15% 74%, 18% 68%, 20% 62%, 22% 56%, 23% 50%, 24% 43%, 25% 38%, 25% 34%, 26% 29%, 26% 26%, 27% 22%, 29% 19%, 30% 15%, 32% 13%, 34% 10%, 37% 7%, 41% 5%, 44% 4%, 47% 3%, 51% 3%, 55% 3%, 58% 5%, 62% 6%, 73% 29%, 72% 25%, 70% 20%, 67% 16%, 63% 12%, 60% 9%, 58% 8%, 55% 7%, 52% 6%, 48% 6%, 44% 8%, 41% 9%, 37% 12%, 36% 14%, 33% 16%, 31% 20%, 30% 23%, 29% 26%, 28% 31%, 27% 36%, 27% 39%, 26% 44%, 26% 48%, 26% 52%, 25% 56%, 23% 61%, 22% 65%, 21% 69%, 19% 72%, 17% 75%, 15% 78%, 13% 81%);
                        }
                        
                        #toll-scene .glow2 { width: 100%; height: 100%; filter: brightness(1) blur(0.3em); opacity: 0.1; }
                        #toll-scene .glow2::before {
                            clip-path: polygon(9.21% 83%, 12.28% 79%, 15.35% 74%, 18.41% 68%, 20.46% 62%, 22.51% 56%, 23.53% 50%, 24.55% 43%, 25.58% 34%, 26.6% 29%, 27.62% 22%, 29.16% 18.5%, 30.95% 15.75%, 32.74% 13%, 34.78% 10%, 37.85% 7%, 41.94% 5%, 45.01% 4%, 48.08% 3%, 52.17% 3%, 56.27% 3%, 64.01% 6.36%, 55.75% 4.5%, 47.83% 4.75%, 42.84% 5.88%, 39.51% 7.88%, 36.45% 10.38%, 33.38% 14.88%, 30.69% 19%, 29.67% 22.5%, 28.8% 26.72%, 28.21% 31.36%, 26.92% 38.44%, 26.57% 43.67%, 25.51% 48.34%, 25% 54.34%, 23.4% 60.69%, 21.23% 65.38%, 18.41% 71.5%, 16.88% 74.75%, 12.28% 80.5%);
                            width: 100%; height: 84%;
                            transform: translate(-1em, 8.4em);
                            scale: 1; background: #fff3; display: block; content: "";
                        }

                        #toll-scene .left-glow {
                            --lgc: #5d819666;
                            width: 50%; height: 50%; border-radius: 50%;
                            transform: translateY(-24%); background: transparent;
                            box-shadow: inset 1em 0em 1em 0.2em var(--lgc);
                            clip-path: polygon(0 0, 100% 0, 100% 50%, 0 50%);
                        }
                        #toll-scene .left-glow2 {
                            --lgc2: #5d819666;
                            width: 49%; height: 50%;
                            background-image: radial-gradient(circle at -80% -12%, transparent 50em, var(--lgc2) 50.3em, transparent 52em);
                            position: absolute;
                            transform: translate(-19em, 10.35em);
                            clip-path: polygon(0 0, 100% 0, 100% 78%, 0 78%);
                        }

                        #toll-scene .r-glow {
                            --lgc: #fffaf680;
                            width: 50%; height: 50%; border-radius: 50%;
                            transform: translateY(-24%) rotateY(180deg);
                        }

                        #toll-scene .r-glow2 {
                            --lgc2: #fffaf680;
                            width: 49%; height: 50%;
                            background-image: radial-gradient(circle at -80% -12%, transparent 50em, var(--lgc2) 50.3em, transparent 52em);
                            position: absolute;
                            transform: translate(18.2em, 10.35em) rotateY(180deg) rotateZ(-2deg);
                            clip-path: polygon(0 0, 100% 0, 100% 78%, 0 78%);
                        }

                        #toll-scene .mid-ring {
                            width: 64%; height: 10%; border-radius: 50%;
                            transform: translate(-0.1em, 10em);
                            box-shadow: inset -0.3em 1.3em 0.4em -1em #fff5,
                                -0.2em -1.2em 0.4em -0.4em #505050, -0.1em -1.8em 0.4em -0.4em #fff5,
                                0 -2.5em 0.4em -1em #000000;
                            mix-blend-mode: hard-light; filter: brightness(0.8);
                        }
                        #toll-scene .mid-ring::before,
                        #toll-scene .mid-ring::after {
                            content: ""; display: block; background: #000;
                            width: 2em; height: 2em; top: 10%; border-radius: 50%; position: absolute;
                        }
                        #toll-scene .mid-ring::after { right: -2%; }
                        #toll-scene .mid-ring::before { left: -2%; }
                        #toll-scene .mid-ring.small { transform: translate(0.04em, -8em) scale(0.8, 0.5); }

                        #toll-scene .bell-buff-t {
                            background: #fff2; width: 72%; height: 12%; border-radius: 50%;
                            transform: translateY(16em); filter: blur(1em);
                        }
                        #toll-scene .bell-buff {
                            background: linear-gradient(90deg, black 40%, var(--base-clr) 90%);
                            width: 88%; height: 20%;
                            border-radius: 50% 50% 50% 50% / 50% 50% 30% 30%;
                            transform: translateY(20em);
                            box-shadow: inset 1em 0 2em -1em #5d819666, inset -1em 0 2em -1em #fff;
                        }

                        #toll-scene .bell-btm {
                            width: 88%; height: 18%; border-radius: 50%;
                            transform: translateY(23em);
                            background: linear-gradient(90deg, black 40%, var(--base-clr) 90%);
                        }
                        #toll-scene .bell-btm2 {
                            width: 74%; height: 12%; border-radius: 50%;
                            transform: translateY(24em);
                            background: #fffff6;
                            box-shadow: 0 0 1em 0.6em #ffe9d4, -0.8em 0.2em 2em 1em #cca37f,
                                -5.4em -0.6em 3em -1em #ce6e1abb, 6em -0.6em 3em -1em #ce6e1abb,
                                inset 0em 30.3em 0.3em -30em #c7962d, inset 0 -2em 2em -2em #ffe9d4,
                                inset 0em -1em 2em 1em #ce6e1a66;
                            filter: brightness(1);
                        }
                        #toll-scene .off .bell-btm2 { filter: brightness(0.02); }

                        #toll-scene .bell-ring-container {
                            width: 74%; height: 24%; border-radius: 50% 50% 50% 50% / 25% 25% 0% 0%;
                            transform: translateY(29.2em); overflow: hidden;
                        }
                        #toll-scene .bell-ring {
                            width: 12em; height: 12em; background: #fff; border-radius: 50%;
                            transform: translateY(-6em);
                            box-shadow: 0 0.8em 1em -0.3em #f8e1d0, inset 0 -6em 4em -4em #e3b695,
                                inset 0 1em 3em 1em #fff4, inset 0 2em 3em 1em #fff,
                                inset 0 100em 0 100em #2c2c2c;
                        }
                        #toll-scene .off .bell-ring {
                            background: #000;
                            box-shadow: 0 0.8em 1em -0.3em #f8e1d000, inset 0 -6em 4em -4em #e3b69500,
                                inset 0 1em 3em 1em #fff0, inset 0 -2em 3em 1em #fff2,
                                inset 0 100em 0 100em #000;
                        }

                        #toll-scene .bell-rays {
                            mix-blend-mode: soft-light; box-shadow: inset 0 -21em 4em -20em #000;
                            width: 100%; height: 140%; transform: translateY(-4em); border-radius: 50%;
                        }
                        #toll-scene .bell-rays::before {
                            content: ""; display: block; width: 100em; height: 100em;
                            transform-origin: 50% 50%; position: absolute;
                            left: -21em; top: -77em; border-radius: 100%; filter: blur(0.6em);
                            background: repeating-conic-gradient(at 50% 50%, #fff2 0%, transparent 0.6%, #fff2 0.8%);
                            animation: radiate 1s linear infinite;
                        }
                        #toll-scene .off .bell-rays { opacity: 0; }
                        @keyframes radiate { 0% { transform: rotate(0deg); } 100% { transform: rotate(6deg); } }

                        #toll-scene .volumetric {
                            width: 98%; height: 224%; transform: translateY(124em); opacity: 0.2;
                        }
                        #toll-scene .volumetric .vl {
                            width: 100%; height: 100%; transform-origin: 50% 20em;
                            transform: rotate(22deg); box-shadow: inset 40em 0 20em -20em #fff1;
                        }
                        #toll-scene .volumetric .vr {
                            width: 100%; height: 100%; transform-origin: 50% 20em;
                            transform: rotate(-22deg); box-shadow: inset -40em 0 20em -20em #fff1;
                        }
                        #toll-scene .off .volumetric { opacity: 0; }

                        #toll-scene .grain {
                            z-index: 10; position: absolute; pointer-events: none;
                            width: 100%; height: 100%; top: 0; bottom: 0; margin: auto;
                            background: radial-gradient(circle at 50% 50%, #000, #0000),
                                url("data:image/svg+xml,%3Csvg viewBox='0 0 600 600' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='2' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
                            filter: contrast(100%) brightness(200%) grayscale(1) opacity(0.168);
                            mix-blend-mode: screen;
                        }

                        @keyframes lumenbtn {
                            0% { box-shadow: inset 0 0.04em 0.06em 0 #fff, inset calc(-0.2em * var(--degofrot)) 1em 1em 0 #fff5, inset calc(-0.2em * var(--degofrot)) 0.2em 0.4em 0 #e3b695; }
                            50% { box-shadow: inset 0 0.04em 0.06em 0 #fff, inset calc(0.2em * var(--degofrot)) 1em 1em 0 #fff5, inset calc(0.2em * var(--degofrot)) 0.2em 0.4em 0 #e3b695; }
                            100% { box-shadow: inset 0 0.04em 0.06em 0 #fff, inset calc(-0.2em * var(--degofrot)) 1em 1em 0 #fff5, inset calc(-0.2em * var(--degofrot)) 0.2em 0.4em 0 #e3b695; }
                        }
                        @keyframes lumen {
                            0% { transform: translate(calc(-0.8em * var(--degofrot)), 0); }
                            50% { transform: translate(calc(0.8em * var(--degofrot)), 0); }
                            100% { transform: translate(calc(-0.8em * var(--degofrot)), 0); }
                        }
                    `;
                    document.head.appendChild(bellStyle);
                }

                const tollScene = document.createElement('div');
                tollScene.id = 'toll-scene';
                overlay.appendChild(tollScene);

                tollScene.innerHTML = `
                    <div class="bell-container off" id="toll-bell">
                        <div class="rope"></div>
                        <div class="bell-top"></div>

                        <div class="bell-base"></div>
                        <div class="bell-base"></div>
                        <div class="shadow-l1"></div>
                        <div class="shadow-l2"></div>
                        <div class="left-glow"></div>
                        <div class="left-glow2"></div>
                        <div class="r-glow"></div>
                        <div class="r-glow2"></div>
                        <div class="mid-ring"></div>
                        <div class="mid-ring small"></div>

                        <div class="glow"></div>
                        <div class="glow2"></div>

                        <div class="bell-buff-t"></div>
                        <div class="bell-buff"></div>

                        <div class="bell-btm"></div>
                        <div class="bell-btm2"></div>

                        <div class="bell-ring-container">
                            <div class="bell-ring"></div>
                            <div class="bell-rays"></div>
                        </div>

                        <div class="volumetric">
                            <div class="vl"></div>
                            <div class="vr"></div>
                        </div>

                    </div>
                    <div class="grain"></div>
                `;

                const bell = tollScene.querySelector('#toll-bell');
                tollSceneEl = tollScene;

                // Play scary bell sound
                const playBellSound = () => {
                    try {
                        stopTollBellAudio(true);
                        const primaryBell = new Audio('cutscenes/toll_bell_menacing.mp3');
                        primaryBell.onerror = () => {
                            const fallbackBell = new Audio('cutscenes/bell_toll.mp3');
                            fallbackBell.volume = 1.0;
                            tollBellAudio = fallbackBell;
                            fallbackBell.play().catch(e => console.log('Fallback bell audio play failed:', e));
                        };
                        primaryBell.volume = 1.0;
                        tollBellAudio = primaryBell;
                        primaryBell.play().catch(e => console.log('Bell audio play failed:', e));

                        // Let the toll ring, then fade it out so it never bleeds past the cutscene.
                        setTimeout(() => stopTollBellAudio(false), 4200);
                    } catch (e) {
                        console.log('Bell sound could not be played:', e);
                    }
                };

                const triggerBell = () => {
                    if (!bell || !bell.classList.contains('off')) return;
                    bell.classList.remove('off');
                    bell.classList.add('swinging'); // Start dramatic swing

                    // Play bell sound effect
                    playBellSound();

                    // White flash effect
                    const flash = document.createElement('div');
                    flash.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:white;opacity:0;z-index:99999;pointer-events:none;transition:opacity 0.15s ease;';
                    document.body.appendChild(flash);
                    setTimeout(() => flash.style.opacity = '1', 50);
                    setTimeout(() => flash.style.opacity = '0', 800);
                    setTimeout(() => flash.remove(), 1500);

                    // Screen shake
                    tollScene.style.animation = 'shake 0.5s cubic-bezier(.36,.07,.19,.97) both';
                };

                // Automatically trigger the bell after 2 seconds
                tollBellTriggerTimeout = setTimeout(triggerBell, 2000);

            } else if (isSingularity) {
                // === SINGULARITY: 3D REALISTIC BLACK HOLE ===

                // Styles for the Three.js container and UI
                if (!document.getElementById('singularity-styles')) {
                    const singStyle = document.createElement('style');
                    singStyle.id = 'singularity-styles';
                    singStyle.textContent = `
                        #singularity-container {
                            position: absolute;
                            top: 0; left: 0;
                            width: 100%; height: 100%;
                            background: radial-gradient(ellipse at center, #0a0a1a 0%, #000002 70%);
                            z-index: 1;
                            overflow: hidden;
                        }
                        #singularity-container canvas {
                            display: block;
                            width: 100%; height: 100%;
                        }
                    `;
                    document.head.appendChild(singStyle);
                }

                const container = document.createElement('div');
                container.id = 'singularity-container';
                overlay.appendChild(container);

                // Initialize Three.js asynchronously
                (async () => {
                    const THREE = await import('three');
                    const { EffectComposer } = await import('three/addons/postprocessing/EffectComposer.js');
                    const { RenderPass } = await import('three/addons/postprocessing/RenderPass.js');
                    const { UnrealBloomPass } = await import('three/addons/postprocessing/UnrealBloomPass.js');
                    const { ShaderPass } = await import('three/addons/postprocessing/ShaderPass.js');

                    // --- CONFIGURATION ---
                    const CONFIG = {
                        blackHoleRadius: 1.3,
                        diskInnerRadius: 1.5,
                        diskOuterRadius: 8.0,
                        diskTilt: Math.PI / 3.0,
                        lensingStrength: 0.12,
                        flowSpeed: 0.22,
                        noiseScale: 2.5
                    };

                    // --- SCENE SETUP ---
                    const scene = new THREE.Scene();
                    scene.fog = new THREE.FogExp2(0x020104, 0.025);

                    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 4000);
                    camera.position.set(-6.5, 5.0, 6.5);
                    camera.lookAt(0, 0, 0);

                    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance", alpha: true });
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
                    renderer.outputColorSpace = THREE.SRGBColorSpace;
                    renderer.toneMapping = THREE.ACESFilmicToneMapping;
                    renderer.toneMappingExposure = 1.2;
                    container.appendChild(renderer.domElement);

                    // --- POST-PROCESSING ---
                    const composer = new EffectComposer(renderer);
                    composer.addPass(new RenderPass(scene, camera));

                    const bloomPass = new UnrealBloomPass(
                        new THREE.Vector2(window.innerWidth, window.innerHeight),
                        0.8, 0.7, 0.8
                    );
                    composer.addPass(bloomPass);

                    const lensingShader = {
                        uniforms: {
                            "tDiffuse": { value: null },
                            "blackHoleScreenPos": { value: new THREE.Vector2(0.5, 0.5) },
                            "lensingStrength": { value: CONFIG.lensingStrength },
                            "lensingRadius": { value: 0.3 },
                            "aspectRatio": { value: window.innerWidth / window.innerHeight },
                            "chromaticAberration": { value: 0.005 }
                        },
                        vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
                        fragmentShader: `
                            uniform sampler2D tDiffuse;
                            uniform vec2 blackHoleScreenPos;
                            uniform float lensingStrength;
                            uniform float lensingRadius;
                            uniform float aspectRatio;
                            uniform float chromaticAberration;
                            varying vec2 vUv;
                            
                            void main() {
                                vec2 screenPos = vUv;
                                vec2 toCenter = screenPos - blackHoleScreenPos;
                                toCenter.x *= aspectRatio;
                                float dist = length(toCenter);
                                
                                float distortionAmount = lensingStrength / (dist * dist + 0.003);
                                distortionAmount = clamp(distortionAmount, 0.0, 0.7);
                                float falloff = smoothstep(lensingRadius, lensingRadius * 0.3, dist);
                                distortionAmount *= falloff;
                                
                                vec2 offset = normalize(toCenter) * distortionAmount;
                                offset.x /= aspectRatio;
                                
                                vec2 distortedUvR = screenPos - offset * (1.0 + chromaticAberration);
                                vec2 distortedUvG = screenPos - offset;
                                vec2 distortedUvB = screenPos - offset * (1.0 - chromaticAberration);
                                
                                float r = texture2D(tDiffuse, distortedUvR).r;
                                float g = texture2D(tDiffuse, distortedUvG).g;
                                float b = texture2D(tDiffuse, distortedUvB).b;
                                
                                gl_FragColor = vec4(r, g, b, 1.0);
                            }`
                    };
                    const lensingPass = new ShaderPass(lensingShader);
                    composer.addPass(lensingPass);

                    // --- OBJECTS ---

                    // Starfield
                    const starGeometry = new THREE.BufferGeometry();
                    const starCount = 30000;
                    const starPositions = new Float32Array(starCount * 3);
                    const starColors = new Float32Array(starCount * 3);
                    const starSizes = new Float32Array(starCount);
                    const starTwinkle = new Float32Array(starCount);
                    const starFieldRadius = 2000;
                    const starPalette = [
                        new THREE.Color(0x88aaff), new THREE.Color(0xffaaff), new THREE.Color(0xaaffff),
                        new THREE.Color(0xffffff), new THREE.Color(0x88ffff)
                    ];

                    for (let i = 0; i < starCount; i++) {
                        const i3 = i * 3;
                        const phi = Math.acos(-1 + (2 * i) / starCount);
                        const theta = Math.sqrt(starCount * Math.PI) * phi;
                        const radius = Math.cbrt(Math.random()) * starFieldRadius + 100;
                        starPositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                        starPositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                        starPositions[i3 + 2] = radius * Math.cos(phi);
                        const color = starPalette[Math.floor(Math.random() * starPalette.length)].clone();
                        color.multiplyScalar(Math.random() * 0.7 + 0.3);
                        starColors[i3] = color.r; starColors[i3 + 1] = color.g; starColors[i3 + 2] = color.b;
                        starSizes[i] = Math.random() * 2.5 + 0.5;
                        starTwinkle[i] = Math.random() * Math.PI * 2;
                    }
                    starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
                    starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
                    starGeometry.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));
                    starGeometry.setAttribute('twinkle', new THREE.BufferAttribute(starTwinkle, 1));

                    const starMaterial = new THREE.ShaderMaterial({
                        uniforms: { uTime: { value: 0 }, uPixelRatio: { value: renderer.getPixelRatio() } },
                        vertexShader: `
                            uniform float uTime; uniform float uPixelRatio; attribute float size; attribute float twinkle; varying vec3 vColor; varying float vTwinkle;
                            void main() {
                                vColor = color; vTwinkle = sin(uTime * 2.5 + twinkle) * 0.5 + 0.5;
                                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                                gl_PointSize = size * uPixelRatio * (300.0 / -mvPosition.z);
                                gl_Position = projectionMatrix * mvPosition;
                            }
                        `,
                        fragmentShader: `
                            varying vec3 vColor; varying float vTwinkle;
                            void main() {
                                float dist = distance(gl_PointCoord, vec2(0.5));
                                if (dist > 0.5) discard;
                                float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
                                alpha *= (0.2 + vTwinkle * 0.8);
                                gl_FragColor = vec4(vColor, alpha);
                            }
                        `,
                        transparent: true, vertexColors: true, blending: THREE.AdditiveBlending, depthWrite: false
                    });
                    const stars = new THREE.Points(starGeometry, starMaterial);
                    scene.add(stars);

                    // Event Horizon (Glowing shell)
                    const eventHorizonMat = new THREE.ShaderMaterial({
                        uniforms: { uTime: { value: 0 }, uCameraPosition: { value: camera.position } },
                        vertexShader: `
                            varying vec3 vNormal; varying vec3 vPosition;
                            void main() { vNormal = normalize(normalMatrix * normal); vPosition = position; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }
                        `,
                        fragmentShader: `
                            uniform float uTime; uniform vec3 uCameraPosition; varying vec3 vNormal; varying vec3 vPosition;
                            void main() {
                                vec3 viewDirection = normalize(uCameraPosition - vPosition);
                                float fresnel = 1.0 - abs(dot(vNormal, viewDirection));
                                fresnel = pow(fresnel, 2.5);
                                vec3 glowColor = vec3(0.0, 0.8, 1.0); // Cyan glow for Singularity
                                float pulse = sin(uTime * 2.5) * 0.15 + 0.85;
                                gl_FragColor = vec4(glowColor * fresnel * pulse, fresnel * 0.6);
                            }
                        `,
                        transparent: true, blending: THREE.AdditiveBlending, side: THREE.BackSide
                    });
                    const eventHorizon = new THREE.Mesh(new THREE.SphereGeometry(CONFIG.blackHoleRadius * 1.05, 64, 32), eventHorizonMat);
                    scene.add(eventHorizon);

                    // Core Black Hole
                    const blackHoleMesh = new THREE.Mesh(new THREE.SphereGeometry(CONFIG.blackHoleRadius, 64, 32), new THREE.MeshBasicMaterial({ color: 0x000000 }));
                    blackHoleMesh.renderOrder = 0;
                    scene.add(blackHoleMesh);

                    // Accretion Disk
                    const diskMaterial = new THREE.ShaderMaterial({
                        uniforms: {
                            uTime: { value: 0.0 },
                            uColorHot: { value: new THREE.Color(0xffffff) },
                            uColorMid1: { value: new THREE.Color(0x00ffff) }, // Cyan
                            uColorMid2: { value: new THREE.Color(0x0088ff) }, // Blue
                            uColorMid3: { value: new THREE.Color(0x0044aa) }, // Deep Blue
                            uColorOuter: { value: new THREE.Color(0x001133) }, // Dark Blue
                            uNoiseScale: { value: CONFIG.noiseScale },
                            uFlowSpeed: { value: CONFIG.flowSpeed },
                            uDensity: { value: 1.3 }
                        },
                        vertexShader: `
                            varying vec2 vUv; varying float vRadius; varying float vAngle;
                            void main() { vUv = uv; vRadius = length(position.xy); vAngle = atan(position.y, position.x); gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }
                        `,
                        fragmentShader: `
                            uniform float uTime; uniform vec3 uColorHot; uniform vec3 uColorMid1; uniform vec3 uColorMid2; uniform vec3 uColorMid3; uniform vec3 uColorOuter;
                            uniform float uNoiseScale; uniform float uFlowSpeed; uniform float uDensity;
                            varying vec2 vUv; varying float vRadius; varying float vAngle;
                            
                            // Simplex Noise Shim
                            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
                            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
                            float snoise(vec3 v) {
                                const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                                const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                                vec3 i  = floor(v + dot(v, C.yyy) );
                                vec3 x0 = v - i + dot(i, C.xxx) ;
                                vec3 g = step(x0.yzx, x0.xyz);
                                vec3 l = 1.0 - g;
                                vec3 i1 = min( g.xyz, l.zxy );
                                vec3 i2 = max( g.xyz, l.zxy );
                                vec3 x1 = x0 - i1 + C.xxx;
                                vec3 x2 = x0 - i2 + C.yyy;
                                vec3 x3 = x0 - D.yyy;
                                i = mod289(i);
                                vec4 p = permute( permute( permute( i.z + vec4(0.0, i1.z, i2.z, 1.0 )) + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
                                float n_ = 0.142857142857;
                                vec3  ns = n_ * D.wyz - D.xzx;
                                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                                vec4 x_ = floor(j * ns.z);
                                vec4 y_ = floor(j - 7.0 * x_ );
                                vec4 x = x_ *ns.x + ns.yyyy;
                                vec4 y = y_ *ns.x + ns.yyyy;
                                vec4 h = 1.0 - abs(x) - abs(y);
                                vec4 b0 = vec4( x.xy, y.xy );
                                vec4 b1 = vec4( x.zw, y.zw );
                                vec4 s0 = floor(b0)*2.0 + 1.0;
                                vec4 s1 = floor(b1)*2.0 + 1.0;
                                vec4 sh = -step(h, vec4(0.0));
                                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
                                vec3 p0 = vec3(a0.xy,h.x);
                                vec3 p1 = vec3(a0.zw,h.y);
                                vec3 p2 = vec3(a1.xy,h.z);
                                vec3 p3 = vec3(a1.zw,h.w);
                                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                                p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                                m = m * m;
                                return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
                            }

                            void main() {
                                float normalizedRadius = smoothstep(${CONFIG.diskInnerRadius.toFixed(1)}, ${CONFIG.diskOuterRadius.toFixed(1)}, vRadius);
                                float spiral = vAngle * 3.0 - (1.0 / (normalizedRadius + 0.1)) * 2.0;
                                vec2 noiseUv = vec2(vUv.x + uTime * uFlowSpeed * (2.0 / (vRadius * 0.3 + 1.0)) + sin(spiral) * 0.1, vUv.y * 0.8 + cos(spiral) * 0.1);
                                float noiseVal = (snoise(vec3(noiseUv * uNoiseScale, uTime * 0.15)) * 0.45 + snoise(vec3(noiseUv * uNoiseScale * 3.0 + 0.8, uTime * 0.22)) * 0.35 + snoise(vec3(noiseUv * uNoiseScale * 6.0 + 1.5, uTime * 0.3)) * 0.2);
                                noiseVal = (noiseVal + 1.0) * 0.5;
                                
                                vec3 color = uColorOuter;
                                color = mix(color, uColorMid3, smoothstep(0.0, 0.25, normalizedRadius));
                                color = mix(color, uColorMid2, smoothstep(0.2, 0.55, normalizedRadius));
                                color = mix(color, uColorMid1, smoothstep(0.5, 0.75, normalizedRadius));
                                color = mix(color, uColorHot, smoothstep(0.7, 0.95, normalizedRadius));
                                color *= (0.5 + noiseVal * 1.0);
                                
                                float brightness = pow(1.0 - normalizedRadius, 1.0) * 3.5 + 0.5;
                                brightness *= (0.3 + noiseVal * 2.2);
                                float pulse = sin(uTime * 1.8 + normalizedRadius * 12.0 + vAngle * 2.0) * 0.15 + 0.85;
                                brightness *= pulse;
                                
                                float alpha = uDensity * (0.2 + noiseVal * 0.9);
                                alpha *= smoothstep(0.0, 0.15, normalizedRadius);
                                alpha *= (1.0 - smoothstep(0.85, 1.0, normalizedRadius));
                                gl_FragColor = vec4(color * brightness, clamp(alpha, 0.0, 1.0));
                            }
                        `,
                        transparent: true, side: THREE.DoubleSide, depthWrite: false, blending: THREE.AdditiveBlending
                    });
                    const accretionDisk = new THREE.Mesh(new THREE.RingGeometry(CONFIG.diskInnerRadius, CONFIG.diskOuterRadius, 256, 128), diskMaterial);
                    accretionDisk.rotation.x = CONFIG.diskTilt;
                    accretionDisk.renderOrder = 1;
                    scene.add(accretionDisk);


                    // --- ANIMATION LOOP ---
                    const clock = new THREE.Clock();
                    const blackHoleScreenPosVec3 = new THREE.Vector3();

                    // Dynamic Camera Variables
                    let targetCameraRadius = 8.5;
                    let currentCameraRadius = 8.5;
                    let targetOrbitSpeed = 0.2;
                    let currentOrbitSpeed = 0.2;
                    let cameraTheta = 0;
                    let cameraPhi = 1.0;
                    let verticalBobAmount = 0.5;

                    const animate3D = () => {
                        if (!document.body.contains(renderer.domElement)) {
                            renderer.dispose();
                            return; // Cleanup
                        }

                        requestAnimationFrame(animate3D);
                        const elapsedTime = clock.getElapsedTime();
                        const deltaTime = clock.getDelta();

                        // Smoothly interpolate parameters
                        currentCameraRadius += (targetCameraRadius - currentCameraRadius) * 2.0 * deltaTime;
                        currentOrbitSpeed += (targetOrbitSpeed - currentOrbitSpeed) * 1.5 * deltaTime;

                        diskMaterial.uniforms.uTime.value = elapsedTime;
                        starMaterial.uniforms.uTime.value = elapsedTime;
                        eventHorizonMat.uniforms.uTime.value = elapsedTime;
                        eventHorizonMat.uniforms.uCameraPosition.value.copy(camera.position);

                        // Advanced Camera Logic: Cinematic Orbit
                        const thetaSpeed = currentOrbitSpeed + 0.6; // Much Faster rotation
                        cameraTheta = elapsedTime * thetaSpeed;

                        // Wide Vertical Sweeps (Phi)
                        const bobFreq = 0.3 + (currentOrbitSpeed * 0.2);
                        // Phi oscillates between ~35deg and ~145deg (huge vertical change)
                        const targetPhi = 1.57 + Math.sin(elapsedTime * bobFreq) * 1.1;
                        cameraPhi += (targetPhi - cameraPhi) * 1.5 * deltaTime;

                        // Breathing Radius effect
                        const breathing = Math.sin(elapsedTime * 0.8) * 0.8;
                        const effectiveRadius = currentCameraRadius + breathing;

                        camera.position.x = effectiveRadius * Math.sin(cameraTheta) * Math.sin(cameraPhi);
                        camera.position.y = effectiveRadius * Math.cos(cameraPhi);
                        camera.position.z = effectiveRadius * Math.cos(cameraTheta) * Math.sin(cameraPhi);

                        camera.lookAt(0, 0, 0);



                        blackHoleScreenPosVec3.copy(blackHoleMesh.position).project(camera);
                        lensingPass.uniforms.blackHoleScreenPos.value.set(
                            (blackHoleScreenPosVec3.x + 1) / 2,
                            (blackHoleScreenPosVec3.y + 1) / 2
                        );

                        stars.rotation.y += deltaTime * 0.02;
                        accretionDisk.rotation.z += deltaTime * 0.05;

                        composer.render();
                    };
                    animate3D();

                    // Handle resize
                    const resizeObserver = new ResizeObserver(() => {
                        const width = window.innerWidth;
                        const height = window.innerHeight;
                        camera.aspect = width / height;
                        camera.updateProjectionMatrix();
                        renderer.setSize(width, height);
                        composer.setSize(width, height);
                        bloomPass.resolution.set(width, height);
                        lensingPass.uniforms.aspectRatio.value = width / height;
                    });
                    resizeObserver.observe(container);

                    // --- EXPOSE API ---
                    window.gravityEffects = {
                        setIntensity: (val) => {
                            // val is 1.0 to ~3.5
                            CONFIG.lensingStrength = 0.12 + (val * 0.1);
                            lensingPass.uniforms.lensingStrength.value = CONFIG.lensingStrength;

                            diskMaterial.uniforms.uFlowSpeed.value = 0.22 + (val * 0.5);
                            diskMaterial.uniforms.uNoiseScale.value = 2.5 + (val * 0.5);

                            // Adjust Camera Targets
                            targetOrbitSpeed = 0.2 + (val * 0.4);
                            targetCameraRadius = Math.max(3.5, 8.5 - (val * 1.2)); // Zoom in closer!

                            const intensityMult = 1 + (val * 0.2);
                            bloomPass.strength = 0.8 * intensityMult;
                        },
                        glitchBurst: () => {
                            lensingPass.uniforms.chromaticAberration.value = 0.05;
                            setTimeout(() => lensingPass.uniforms.chromaticAberration.value = 0.005, 100);

                            const g = document.createElement('div');
                            g.style.cssText = `position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(0,255,255,0.1);z-index:100;mix-blend-mode:overlay;`;
                            overlay.appendChild(g);
                            setTimeout(() => g.remove(), 60);
                        },
                        flash: (color = '#ffffff') => {
                            const f = document.createElement('div');
                            f.style.cssText = `position:absolute;top:0;left:0;width:100%;height:100%;background:${color};opacity:0;z-index:1000;pointer-events:none;`;
                            overlay.appendChild(f);
                            requestAnimationFrame(() => { f.style.opacity = '1'; setTimeout(() => { f.style.opacity = '0'; setTimeout(() => f.remove(), 200); }, 50); });
                        },
                        collapseReveal: () => {
                            // Intense singularity collapse
                            autoRotateSpeed = 5.0; // Violent spin
                            lensingPass.uniforms.lensingStrength.value = 2.0; // Extreme warping
                            blackHoleMesh.scale.set(0.1, 0.1, 0.1); // Core shrink
                            eventHorizon.scale.set(0.1, 0.1, 0.1);

                            // Suck in accretion disk visualization (by scaling texture noise or mesh)
                            diskMaterial.uniforms.uFlowSpeed.value = 5.0;

                            setTimeout(() => {
                                window.gravityEffects.flash('#ffffff');
                                overlay.style.background = theme.bgGradient;
                                renderer.domElement.style.opacity = '0';
                            }, 800);
                        }
                    };

                    // Signal ready if needed, or initialized state
                })();

                // Fallback API until Three.js loads (prevents errors if cutscene phase 0 triggers immediately)
                window.gravityEffects = {
                    setIntensity: () => { },
                    glitchBurst: () => { },
                    collapseReveal: () => { },
                    flash: () => { }
                };

                const loop = () => { };
                loop(); // Placeholder for the old loop setup, actual loop is in Three.js



            } else {
                // === STANDARD FOG VISUALS (for LOST etc) ===
                const fogContainer = document.createElement('div');
                fogContainer.className = 'fog-container';
                fogContainer.innerHTML = `<div class="fog-layer" style="background-image: url('${fogDataUrl}')"></div><div class="fog-layer" style="background-image: url('${fogDataUrl}')"></div>`;
                overlay.appendChild(fogContainer);
            }

            const content = document.createElement('div');
            content.id = 'text-cutscene-content';
            // Apply theme-specific text styling
            content.style.position = 'relative';
            content.style.width = '100%';
            content.style.textAlign = theme.textAlign || 'center';
            content.style.zIndex = '100'; // Above all visuals
            content.style.fontFamily = theme.fontFamily;
            content.style.fontSize = theme.fontSize;
            content.style.color = theme.textColor;
            content.style.textShadow = theme.textShadow;

            overlay.appendChild(content);
            document.body.appendChild(overlay);

            // 3. Create and Play Fog Ambience Sound
            let fogAmbience = null;

            // Generate fog ambience using Web Audio API
            const createFogAmbience = () => {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const duration = 30; // 30 seconds loop
                const sampleRate = audioContext.sampleRate;
                const buffer = audioContext.createBuffer(2, duration * sampleRate, sampleRate);

                // Generate multi-layered atmospheric fog sound
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = buffer.getChannelData(channel);
                    let brownLast = 0;

                    for (let i = 0; i < channelData.length; i++) {
                        const t = i / sampleRate;

                        // Layer 1: Deep brown noise (base rumble)
                        const white = Math.random() * 2 - 1;
                        const brown = (brownLast + (0.02 * white)) / 1.02;
                        brownLast = brown;

                        // Layer 2: Low-frequency oscillation (wind-like movement)
                        const windFreq = 0.1 + Math.sin(t * 0.05) * 0.05;
                        const wind = Math.sin(t * windFreq * Math.PI * 2) * 0.15;

                        // Layer 3: Subtle high-frequency shimmer
                        const shimmer = (Math.random() * 2 - 1) * 0.05 * Math.sin(t * 2);

                        // Layer 4: Very low sub-bass rumble
                        const subBass = Math.sin(t * 0.5 * Math.PI * 2) * 0.1;

                        // Mix all layers
                        channelData[i] = (brown * 0.4 + wind * 0.3 + shimmer * 0.2 + subBass * 0.1) * 0.35;
                    }
                }

                // Convert to data URL for Howler
                const offlineContext = new OfflineAudioContext(2, buffer.length, sampleRate);
                const source = offlineContext.createBufferSource();
                source.buffer = buffer;
                source.connect(offlineContext.destination);
                source.start();

                return offlineContext.startRendering().then(renderedBuffer => {
                    // Create Howl instance with the generated buffer
                    fogAmbience = new Howl({
                        src: [bufferToDataURL(renderedBuffer)],
                        format: ['wav'],
                        loop: true,
                        volume: 0.4,
                        onload: function () {
                            fogAmbience.play();
                            fogAmbience.fade(0, 0.4, 2000); // Fade in over 2 seconds
                        }
                    });
                });
            };

            // Helper to convert AudioBuffer to data URL
            const bufferToDataURL = (buffer) => {
                const length = buffer.length * buffer.numberOfChannels * 2;
                const arrayBuffer = new ArrayBuffer(44 + length);
                const view = new DataView(arrayBuffer);

                // WAV header
                const writeString = (offset, string) => {
                    for (let i = 0; i < string.length; i++) {
                        view.setUint8(offset + i, string.charCodeAt(i));
                    }
                };

                writeString(0, 'RIFF');
                view.setUint32(4, 36 + length, true);
                writeString(8, 'WAVE');
                writeString(12, 'fmt ');
                view.setUint32(16, 16, true);
                view.setUint16(20, 1, true);
                view.setUint16(22, buffer.numberOfChannels, true);
                view.setUint32(24, buffer.sampleRate, true);
                view.setUint32(28, buffer.sampleRate * 4, true);
                view.setUint16(32, buffer.numberOfChannels * 2, true);
                view.setUint16(34, 16, true);
                writeString(36, 'data');
                view.setUint32(40, length, true);

                // Write audio data
                let offset = 44;
                for (let i = 0; i < buffer.length; i++) {
                    for (let channel = 0; channel < buffer.numberOfChannels; channel++) {
                        const sample = Math.max(-1, Math.min(1, buffer.getChannelData(channel)[i]));
                        view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
                        offset += 2;
                    }
                }

                const blob = new Blob([arrayBuffer], { type: 'audio/wav' });
                return URL.createObjectURL(blob);
            };

            // Start fog ambience
            createFogAmbience();

            // 4. Animation Sequence
            // Fade to black
            if (isAeternitas) {
                const scene = document.getElementById('aeternitas-scene');
                // Start scene hidden
                if (scene) scene.style.opacity = '0';

                // Start with black background
                overlay.style.background = '#000000';
                // Slow transition for opacity (fade in) and background color
                overlay.style.transition = 'opacity 3s ease, background 3s ease';

                requestAnimationFrame(() => {
                    overlay.classList.add('active'); // Fade to black (opacity 0->1)

                    // After fade to black completes, fade in the scene and theme background
                    setTimeout(() => {
                        overlay.style.background = theme.bgGradient;
                        if (scene) {
                            // Ensure scene fades in smoothly
                            scene.style.opacity = '1';
                        }
                    }, 3500); // Wait 3.5s (3s fade + 0.5s pause)
                });
            } else if (isToll) {
                // Fade to black first, then reveal the bell scene.
                overlay.style.background = '#000000';
                overlay.style.transition = 'opacity 1.4s ease, background 1.4s ease';
                requestAnimationFrame(() => {
                    overlay.classList.add('active');
                    setTimeout(() => {
                        if (tollSceneEl) tollSceneEl.style.opacity = '1';
                    }, 1100);
                });
            } else {
                requestAnimationFrame(() => {
                    overlay.classList.add('active');
                });
            }

            const lines = getTextCutsceneLines(aura.id);
            let currentLineIndex = 0;

            const typeLine = (text) => {
                content.innerHTML = '';
                content.style.opacity = '1';

                let charIndex = 0;
                content.innerHTML = `<span class="text-bits"></span><span class="typewriter-cursor" style="background: ${theme.cursorColor}"></span>`;
                const textSpan = content.querySelector('.text-bits');

                // Create typewriter blip sound
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                // Different pitches for each theme
                const blipPitch = isAeternitas ? 600 : isAnotherRealm ? 1200 : isSingularity ? 400 : 900;
                const playBlip = () => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();

                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    // Another Realm has random frequency jumps for glitchy feel
                    if (isAnotherRealm) {
                        oscillator.frequency.value = blipPitch + (Math.random() * 400 - 200);
                        oscillator.type = 'square';
                    } else if (isSingularity) {
                        oscillator.frequency.value = blipPitch + (Math.random() * 20 - 10);
                        oscillator.type = 'sawtooth';
                    } else {
                        oscillator.frequency.value = blipPitch + (Math.random() * 50 - 25);
                        oscillator.type = isAeternitas ? 'triangle' : 'sine';
                    }

                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);

                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.05);
                };

                // Determine speed based on aura
                const typingSpeed = isAeternitas ? 25 : isAnotherRealm ? 30 : isSingularity ? 60 : isToll ? 40 : 80;
                const readTime = isAeternitas ? 400 : isAnotherRealm ? 800 : isSingularity ? 1500 : isToll ? 1200 : 2500;
                const transitTime = isAeternitas ? 150 : isAnotherRealm ? 200 : isSingularity ? 600 : isToll ? 350 : 1000;

                const typeInterval = setInterval(() => {
                    if (charIndex < text.length) {
                        textSpan.textContent += text.charAt(charIndex);
                        charIndex++;

                        // Play blip sound for non-space characters
                        if (text.charAt(charIndex - 1) !== ' ') {
                            playBlip();
                        }
                    } else {
                        clearInterval(typeInterval);
                        // Wait then fade out
                        setTimeout(() => {
                            content.style.opacity = '0';
                            setTimeout(() => {
                                nextLine();
                            }, transitTime);
                        }, readTime);
                    }
                }, typingSpeed);
            };

            // Scene transition phases for Aeternitas with CAMERA MOVEMENTS + INTENSE EFFECTS
            const transitionPhases = isAeternitas ? [
                {
                    line: 0, action: () => {
                        // Phase 1: Slow zoom in begins + first rumble
                        const scene = document.getElementById('aeternitas-scene');
                        if (scene) {
                            scene.style.transform = 'scale(1)';
                            setTimeout(() => {
                                scene.style.transform = 'scale(1.1)';
                            }, 50);
                        }
                        // Subtle wind starts
                        if (window.aeternitasEffects) {
                            window.aeternitasEffects.setWind(0.5);
                        }
                    }
                },
                {
                    line: 2, action: () => {
                        // Phase 2: Pan left + first shake!
                        const scene = document.getElementById('aeternitas-scene');
                        if (scene) {
                            scene.style.transform = 'scale(1.15) translateX(-30px)';
                        }
                        if (window.aeternitasEffects) {
                            window.aeternitasEffects.setShake(10, 5);
                            window.aeternitasEffects.setIntensity(1.2);
                        }
                    }
                },
                {
                    line: 4, action: () => {
                        // Phase 3: Pan right, TIME DISTORTION BEGINS
                        const scene = document.getElementById('aeternitas-scene');
                        if (scene) {
                            scene.style.transform = 'scale(1.2) translateX(30px) rotate(1deg)';
                        }
                        const hourglass = document.getElementById('aeternitas-hourglass');
                        if (hourglass) {
                            const svg = hourglass.querySelector('svg');
                            if (svg) {
                                svg.style.width = '280px';
                                svg.style.height = '420px';
                                svg.style.opacity = '0.3';
                            }
                        }
                        if (window.aeternitasEffects) {
                            window.aeternitasEffects.setTimeWarp(1.5); // Some particles go backwards!
                            window.aeternitasEffects.setWind(1);
                            window.aeternitasEffects.flash();
                        }
                    }
                },
                {
                    line: 6, action: () => {
                        // Phase 4: Recenter + BIG SHAKE
                        const scene = document.getElementById('aeternitas-scene');
                        if (scene) {
                            scene.style.transform = 'scale(1.1) translateX(0) rotate(0deg)';
                        }
                        overlay.style.transition = 'background 1.5s ease';
                        overlay.style.background = 'radial-gradient(circle at center, #3d2e14 0%, #1a1408 50%, #000000 100%)';
                        const canvas = document.getElementById('aeternitas-sand-canvas');
                        if (canvas) canvas.style.opacity = '0.8';
                        if (window.aeternitasEffects) {
                            window.aeternitasEffects.setShake(20, 15);
                            window.aeternitasEffects.setIntensity(1.4);
                            window.aeternitasEffects.flash();
                        }
                    }
                },
                {
                    line: 8, action: () => {
                        // Phase 5: Tilt + time reversal!
                        const scene = document.getElementById('aeternitas-scene');
                        if (scene) {
                            scene.style.transform = 'scale(1.15) perspective(1000px) rotateX(3deg)';
                        }
                        content.style.fontSize = '30px';
                        if (window.aeternitasEffects) {
                            window.aeternitasEffects.setTimeWarp(2); // Strong time distortion
                            window.aeternitasEffects.setWind(-1.5); // Wind reverses!
                        }
                    }
                },
                {
                    line: 10, action: () => {
                        // Phase 6: DRAMATIC SURGE
                        const scene = document.getElementById('aeternitas-scene');
                        if (scene) {
                            scene.style.transform = 'scale(1.3) perspective(1000px) rotateX(0deg)';
                        }
                        const hourglass = document.getElementById('aeternitas-hourglass');
                        if (hourglass) {
                            hourglass.style.opacity = '0.5';
                            const svg = hourglass.querySelector('svg');
                            if (svg) {
                                svg.style.filter = 'drop-shadow(0 0 50px #c9a227) drop-shadow(0 0 100px #d4af37)';
                            }
                        }
                        content.style.fontSize = '34px';
                        if (window.aeternitasEffects) {
                            window.aeternitasEffects.setShake(30, 20);
                            window.aeternitasEffects.setIntensity(1.6);
                            window.aeternitasEffects.flash();
                            window.aeternitasEffects.flash();
                        }
                    }
                },
                {
                    line: 12, action: () => {
                        // Phase 7: MAXIMUM CHAOS - climax approaching
                        const scene = document.getElementById('aeternitas-scene');
                        if (scene) {
                            scene.style.transform = 'scale(1.5)';
                        }
                        overlay.style.background = 'radial-gradient(circle at center, #4a3a1a 0%, #2a1f0a 40%, #000000 100%)';
                        const canvas = document.getElementById('aeternitas-sand-canvas');
                        if (canvas) canvas.style.opacity = '1';
                        content.style.fontSize = '38px';
                        content.style.textShadow = '0 0 30px rgba(201, 162, 39, 1), 0 0 60px rgba(201, 162, 39, 0.6)';
                        if (window.aeternitasEffects) {
                            window.aeternitasEffects.setTimeWarp(3); // Extreme distortion
                            window.aeternitasEffects.setIntensity(2); // Particle streaks!
                            window.aeternitasEffects.setWind(3);
                            window.aeternitasEffects.setShake(40, 30);
                            window.aeternitasEffects.flash();
                        }
                    }
                },
                {
                    line: 14, action: () => {
                        // Phase 8: Calm before the storm
                        const scene = document.getElementById('aeternitas-scene');
                        if (scene) {
                            scene.style.transform = 'scale(1.2)';
                        }
                        const hourglass = document.getElementById('aeternitas-hourglass');
                        if (hourglass) {
                            hourglass.style.animation = 'hourglass-pulse-fast 1s ease-in-out infinite';
                            hourglass.style.opacity = '0.7';
                        }
                        if (window.aeternitasEffects) {
                            window.aeternitasEffects.setTimeWarp(1); // Time normalizes
                            window.aeternitasEffects.setIntensity(1.2);
                            window.aeternitasEffects.setWind(0);
                        }
                    }
                },
                {
                    line: 16, action: () => {
                        // Final phase: The name reveal - everything converges
                        const scene = document.getElementById('aeternitas-scene');
                        if (scene) {
                            scene.style.transition = 'all 1.5s cubic-bezier(0.4, 0, 0.2, 1)';
                            scene.style.transform = 'scale(1)';
                        }
                        content.style.fontSize = '42px';
                        content.style.textShadow = '0 0 40px rgba(201, 162, 39, 1), 0 0 80px rgba(201, 162, 39, 0.8), 0 0 120px rgba(201, 162, 39, 0.5)';
                        if (window.aeternitasEffects) {
                            window.aeternitasEffects.setShake(50, 40); // One final big shake
                            window.aeternitasEffects.flash();
                            window.aeternitasEffects.flash();
                            window.aeternitasEffects.flash();
                            // Then calm
                            setTimeout(() => {
                                if (window.aeternitasEffects) {
                                    window.aeternitasEffects.setIntensity(1);
                                    window.aeternitasEffects.setTimeWarp(1);
                                }
                            }, 500);
                        }
                    }
                }
            ] : isAnotherRealm ? [
                // === ANOTHER REALM: FAST CHAOTIC TRANSITIONS - EVERY LINE! ===
                {
                    line: 0, action: () => {
                        // "WHAT-" - IMMEDIATE chaos
                        if (window.realmEffects) {
                            window.realmEffects.shake(30, 20);
                            window.realmEffects.flash('#ff00ff');
                            window.realmEffects.setGlitch(0.5);
                            window.realmEffects.setTear(0.3);
                        }
                    }
                },
                {
                    line: 1, action: () => {
                        // "REALITY IS BREAKING"
                        if (window.realmEffects) {
                            window.realmEffects.invert();
                            window.realmEffects.shake(50, 40);
                            window.realmEffects.setRifts(0.3);
                            window.realmEffects.glitchBurst();
                        }
                    }
                },
                {
                    line: 2, action: () => {
                        // "CAN'T-"
                        if (window.realmEffects) {
                            window.realmEffects.flash('#00ffff');
                            window.realmEffects.setTear(0.5);
                            window.realmEffects.setStatic(0.3);
                            window.realmEffects.shake(40, 30);
                        }
                    }
                },
                {
                    line: 3, action: () => {
                        // "EVERYTHING IS-"
                        if (window.realmEffects) {
                            window.realmEffects.invert();
                            window.realmEffects.glitchBurst();
                            window.realmEffects.setGlitch(0.8);
                            window.realmEffects.shake(60, 50);
                        }
                    }
                },
                {
                    line: 4, action: () => {
                        // "TOO FAST"
                        if (window.realmEffects) {
                            window.realmEffects.flash('#ffffff');
                            window.realmEffects.setRifts(0.5);
                            window.realmEffects.setTear(0.7);
                            window.realmEffects.shake(70, 60);
                        }
                        content.style.fontSize = '32px';
                    }
                },
                {
                    line: 5, action: () => {
                        // "COLORS EVERYWHERE"
                        if (window.realmEffects) {
                            window.realmEffects.invert();
                            window.realmEffects.flash('#00ff88');
                            window.realmEffects.glitchBurst();
                            window.realmEffects.setStatic(0.5);
                        }
                        overlay.style.background = 'radial-gradient(circle, #ff00ff 0%, #00ffff 50%, #000 100%)';
                        setTimeout(() => {
                            overlay.style.background = theme.bgGradient;
                        }, 200);
                    }
                },
                {
                    line: 6, action: () => {
                        // "WHICH WAY IS-"
                        if (window.realmEffects) {
                            window.realmEffects.shake(80, 70);
                            window.realmEffects.setGlitch(1);
                            window.realmEffects.setRifts(0.7);
                            window.realmEffects.flash('#ff00ff');
                        }
                    }
                },
                {
                    line: 7, action: () => {
                        // "I'M BEING PULLED"
                        if (window.realmEffects) {
                            window.realmEffects.invert();
                            window.realmEffects.glitchBurst();
                            window.realmEffects.setTear(0.9);
                            window.realmEffects.shake(90, 80);
                        }
                        content.style.fontSize = '36px';
                    }
                },
                {
                    line: 8, action: () => {
                        // "DIMENSIONS COLLIDING"
                        if (window.realmEffects) {
                            window.realmEffects.flash('#ffffff');
                            window.realmEffects.flash('#00ffff');
                            window.realmEffects.setStatic(0.7);
                            window.realmEffects.setRifts(0.9);
                            window.realmEffects.shake(100, 90);
                        }
                    }
                },
                {
                    line: 9, action: () => {
                        // "THIS ISN'T-"
                        if (window.realmEffects) {
                            window.realmEffects.invert();
                            window.realmEffects.invert();
                            window.realmEffects.glitchBurst();
                            window.realmEffects.setGlitch(1.5);
                        }
                    }
                },
                {
                    line: 10, action: () => {
                        // "I SEE EVERYTHING"
                        if (window.realmEffects) {
                            window.realmEffects.flash('#ffffff');
                            window.realmEffects.setTear(1);
                            window.realmEffects.setRifts(1);
                            window.realmEffects.shake(120, 100);
                        }
                        content.style.fontSize = '40px';
                        content.style.textShadow = '0 0 30px #00ffff, 0 0 60px #ff00ff';
                    }
                },
                {
                    line: 11, action: () => {
                        // "I SEE NOTHING" - everything goes dark briefly
                        if (window.realmEffects) {
                            window.realmEffects.setStatic(1);
                            window.realmEffects.setGlitch(2);
                        }
                        overlay.style.background = '#000';
                        content.style.color = '#fff';
                        setTimeout(() => {
                            overlay.style.background = theme.bgGradient;
                            content.style.color = theme.textColor;
                        }, 300);
                    }
                },
                {
                    line: 12, action: () => {
                        // FINAL: "ANOTHER REALM" - MAXIMUM CHAOS then calm
                        if (window.realmEffects) {
                            // Rapid fire effects
                            for (let i = 0; i < 5; i++) {
                                setTimeout(() => {
                                    window.realmEffects?.flash('#ffffff');
                                    window.realmEffects?.invert();
                                    window.realmEffects?.glitchBurst();
                                    window.realmEffects?.shake(150, 120);
                                }, i * 50);
                            }
                            // Then sudden calm
                            setTimeout(() => {
                                if (window.realmEffects) {
                                    window.realmEffects.setGlitch(0);
                                    window.realmEffects.setTear(0);
                                    window.realmEffects.setStatic(0);
                                    window.realmEffects.setRifts(0);
                                }
                            }, 400);
                        }
                        content.style.fontSize = '48px';
                        content.style.textShadow = '0 0 50px #00ffff, 0 0 100px #ff00ff, 0 0 150px #fff';
                    }
                }
            ] : isSingularity ? [
                // === SINGULARITY: SIMPLIFIED INTENSE PROGRESSION ===
                {
                    line: 0, action: () => {
                        if (window.gravityEffects) {
                            window.gravityEffects.setIntensity(1.0);
                            window.gravityEffects.flash('#00ffff');
                        }
                    }
                },
                {
                    line: 1, action: () => {
                        if (window.gravityEffects) {
                            window.gravityEffects.setIntensity(1.5);
                            window.gravityEffects.glitchBurst();
                        }
                    }
                },
                {
                    line: 2, action: () => {
                        if (window.gravityEffects) {
                            window.gravityEffects.setIntensity(2.2);
                            window.gravityEffects.flash('#ffffff');
                        }
                        content.style.fontSize = '34px';
                    }
                },
                {
                    line: 3, action: () => {
                        if (window.gravityEffects) {
                            window.gravityEffects.setIntensity(3.5);
                        }
                        overlay.style.background = '#000';
                        content.style.fontSize = '40px';
                    }
                },
                {
                    line: 4, action: () => {
                        if (window.gravityEffects) {
                            window.gravityEffects.collapseReveal();
                        }
                        content.style.fontSize = '52px';
                        content.style.textShadow = '0 0 60px #00ffff, 0 0 120px #fff';
                    }
                }
            ] : [];

            const nextLine = () => {
                if (currentLineIndex < lines.length) {
                    // Trigger scene transitions for special themes
                    if (isAeternitas || isAnotherRealm || isSingularity) {
                        const phase = transitionPhases.find(p => p.line === currentLineIndex);
                        if (phase) phase.action();

                        // Add text entrance animation
                        content.style.transform = (isAnotherRealm || isSingularity) ? 'scale(0.8) translateY(20px)' : 'translateY(20px)';
                        content.style.opacity = '0';
                        setTimeout(() => {
                            content.style.transition = 'transform 0.8s ease-out, opacity 0.8s ease-out';
                            content.style.transform = (isAnotherRealm || isSingularity) ? 'scale(1) translateY(0)' : 'translateY(0)';
                            content.style.opacity = '1';
                        }, 100);
                    }

                    typeLine(lines[currentLineIndex]);
                    currentLineIndex++;
                } else {
                    // End cutscene
                    endCutscene();
                }
            };

            const endCutscene = () => {
                // Restore Game UI
                const uiElements = ['.game-info', '.admin-btn', '.left-sidebar', '.stats-panel', '.inventory-btn', '.storage-btn', '.items-btn', '#menu-btn', '.main-container'];
                uiElements.forEach(selector => {
                    const el = document.querySelector(selector);
                    if (el) el.style.opacity = '1';
                    if (el) el.style.pointerEvents = 'auto';
                });

                // Cleanup text cutscene specific animations
                if (overlay.dataset.sandAnimation) {
                    cancelAnimationFrame(parseInt(overlay.dataset.sandAnimation));
                    window.aeternitasEffects = null;
                }
                if (overlay.dataset.realmAnimation) {
                    cancelAnimationFrame(parseInt(overlay.dataset.realmAnimation));
                    window.realmEffects = null;
                }
                if (overlay.dataset.gravityAnimation) {
                    cancelAnimationFrame(parseInt(overlay.dataset.gravityAnimation));
                    window.gravityEffects = null;
                }
                if (tollBellTriggerTimeout) {
                    clearTimeout(tollBellTriggerTimeout);
                    tollBellTriggerTimeout = null;
                }
                stopTollBellAudio(true);

                // Fade out fog ambience
                if (fogAmbience) {
                    fogAmbience.fade(0.4, 0, 2000);
                    setTimeout(() => {
                        fogAmbience.stop();
                        fogAmbience.unload();
                    }, 2000);
                }

                // Check if this is a 1B+ aura for enhanced ending
                const is1BillionPlus = (aura.chance || 1) >= 999999998;

                if (is1BillionPlus) {
                    // Prevent overlapping effects - clean up any existing ones
                    if (is1BEffectPlaying) {
                        document.querySelectorAll('[data-1b-effect]').forEach(el => el.remove());
                        document.body.style.filter = '';
                        document.body.style.transform = '';
                        document.body.style.animation = '';
                        document.body.style.transition = '';
                    }
                    is1BEffectPlaying = true;

                    // Remove text overlay first
                    overlay.style.opacity = '0';
                    setTimeout(() => {
                        overlay.remove();

                        // Play 1B transcend audio
                        const transcendAudio = new Audio('cutscenes/1bil_trancend.mp3.mpeg');
                        transcendAudio.volume = (userSettings.audio.sfx / 100) * 0.7 || 0.7;
                        transcendAudio.play().catch(console.error);

                        // Apply EXTREME Deep Fried Effect
                        const body = document.body;
                        body.style.transition = 'filter 0.05s ease-out, transform 0.05s ease-out';
                        body.style.filter = 'grayscale(35%) contrast(920%) brightness(165%) saturate(620%) hue-rotate(170deg) drop-shadow(0 0 30px rgba(255,0,255,0.85))';
                        body.style.transform = 'scale(1.055) rotate(0.6deg)';
                        body.style.animation = 'body-distort 2s ease-in-out infinite';

                        const { prismLayer, riftLayer } = createTranscendentAtmosphereLayers('data-1b-effect');
                        prismLayer.style.transition = 'opacity 4s ease-in';
                        prismLayer.style.opacity = '0.9';
                        riftLayer.style.transition = 'opacity 4s ease-in';
                        riftLayer.style.opacity = '0.55';

                        // Create chromatic flash overlay
                        const flashEl = document.createElement('div');
                        flashEl.setAttribute('data-1b-effect', 'true');
                        flashEl.style.cssText = `
                            position: fixed;
                            top: 0;
                            left: 0;
                            width: 100%;
                            height: 100%;
                            background: radial-gradient(circle at 50% 45%, rgba(255,255,255,0.98) 0%, rgba(194,132,255,0.78) 24%, rgba(84,255,255,0.58) 48%, rgba(255,170,70,0.45) 72%, rgba(5,0,20,0.92) 100%);
                            opacity: 0;
                            z-index: 10000;
                            pointer-events: none;
                            mix-blend-mode: screen;
                            animation: reality-shatter 8s ease-in-out;
                        `;
                        document.body.appendChild(flashEl);

                        flashEl.offsetHeight;
                        flashEl.style.transition = 'opacity 4s ease-in';
                        flashEl.style.opacity = '1';

                        // HUGE EXPLOSION at 5 seconds
                        setTimeout(() => {
                            // Create explosion flash
                            const explosionFlash = document.createElement('div');
                            explosionFlash.setAttribute('data-1b-effect', 'true');
                            explosionFlash.style.cssText = `
                                position: fixed;
                                top: 0;
                                left: 0;
                                width: 100%;
                                height: 100%;
                                background: radial-gradient(circle, #ffffff 0%, #ffff00 20%, #ff6600 40%, #ff0000 60%, transparent 80%);
                                opacity: 0;
                                z-index: 10001;
                                pointer-events: none;
                                mix-blend-mode: screen;
                            `;
                            document.body.appendChild(explosionFlash);

                            // Intense screen shake
                            body.style.animation = 'explosion-shake 0.5s ease-out';

                            // Flash in explosion
                            explosionFlash.offsetHeight;
                            explosionFlash.style.transition = 'opacity 0.1s ease-out';
                            explosionFlash.style.opacity = '1';

                            // Intensify body filter momentarily
                            body.style.filter = 'grayscale(0%) contrast(1000%) brightness(200%) saturate(800%) hue-rotate(0deg) drop-shadow(0 0 50px rgba(255,255,0,1))';

                            // Fade out explosion
                            // After explosion flash, begin slow fade out
                            setTimeout(() => {
                                // Slow fade out everything
                                explosionFlash.style.transition = 'opacity 3s ease-out';
                                explosionFlash.style.opacity = '0';

                                flashEl.style.transition = 'opacity 3s ease-out';
                                flashEl.style.opacity = '0';
                                flashEl.style.animation = '';
                                prismLayer.style.transition = 'opacity 3s ease-out';
                                prismLayer.style.opacity = '0';
                                riftLayer.style.transition = 'opacity 3s ease-out';
                                riftLayer.style.opacity = '0';

                                body.style.animation = '';
                                body.style.transition = 'filter 3s ease-out, transform 3s ease-out';
                                body.style.filter = '';
                                body.style.transform = '';

                                // Cleanup after slow fade
                                setTimeout(() => {
                                    explosionFlash.remove();
                                    flashEl.remove();
                                    prismLayer.remove();
                                    riftLayer.remove();
                                    body.style.transition = '';
                                    is1BEffectPlaying = false; // Reset flag

                                    wrappedOnComplete();
                                }, 3000);
                            }, 500); // Hold explosion for 0.5s then slow fade
                        }, 5000);
                    }, 2000);
                } else {
                    // Standard ending
                    overlay.style.opacity = '0';
                    setTimeout(() => {
                        overlay.remove();
                        wrappedOnComplete();
                    }, 2000);
                }
            };

            // Start typing after fade in
            // For Aeternitas, wait longer for the slow fade-in (3.5s delay + fade time)
            const startDelay = isAeternitas ? 5000 : isToll ? 3300 : 2500;
            setTimeout(() => {
                nextLine();
            }, startDelay);

        }

    </script>
    <script>
        // --- Achievements UI Logic (Redesign) ---
        function toggleAchievementsPanel() {
            const panel = document.getElementById('achievements-panel');
            const menu = document.getElementById('menu-panel');
            const rollOverlay = document.getElementById('roll-overlay');

            if (menu && menu.classList.contains('active')) {
                menu.classList.remove('active');
            }

            if (!panel.classList.contains('visible')) {
                panel.style.display = 'flex'; // Ensure flex
                // Force reflow
                panel.offsetHeight;
                panel.classList.add('visible');
                populateAchievements(); // Refresh list
                // Hide roll overlay when panel is open
                if (rollOverlay) rollOverlay.style.visibility = 'hidden';
            } else {
                panel.classList.remove('visible');
                setTimeout(() => {
                    if (!panel.classList.contains('visible')) panel.style.display = 'none';
                }, 300);
                // Show roll overlay when panel is closed
                if (rollOverlay) rollOverlay.style.visibility = 'visible';
            }
        }

        let currentSelectedAchievement = null;

        function populateAchievements(filter = '') {
            const listContainer = document.getElementById('achievements-list');
            if (!listContainer) return;

            listContainer.innerHTML = ''; // Clear

            if (typeof ACHIEVEMENTS === 'undefined') return;

            const searchTerm = document.getElementById('ach-search').value.toLowerCase();
            let firstId = null;

            ACHIEVEMENTS.forEach(ach => {
                // Search filter
                if (searchTerm && !ach.name.toLowerCase().includes(searchTerm) && !ach.description.toLowerCase().includes(searchTerm)) {
                    return;
                }

                const isCompleted = playerAchievements.completed[ach.id];
                const item = document.createElement('div');
                item.className = `ach-list-item ${isCompleted ? 'completed' : ''}`;
                item.onclick = () => {
                    document.querySelectorAll('.ach-list-item').forEach(el => el.classList.remove('active'));
                    item.classList.add('active');
                    selectAchievement(ach.id);
                };

                if (!firstId) firstId = ach.id;
                if (currentSelectedAchievement === ach.id) item.classList.add('active');

                // Progress Calculation
                let progress = 0;
                let max = ach.requirement.value;
                let current = 0;

                if (isCompleted) {
                    current = max;
                } else {
                    switch (ach.requirement.type) {
                        case 'rolls': current = playerStats.totalRolls; break;
                        case 'playtime': current = playerAchievements.playtimeSeconds; break;
                        case 'potions_used': current = playerStats.potionsUsed; break;
                        case 'breakthroughs': current = playerAchievements.breakthroughCount; break;
                        case 'find_rarity': current = playerAchievements.highestRarityFound; break; // This gets weird for rarity 1/X
                        default: current = 0;
                    }
                }

                // Logic for rarity (value is probability, not count)
                if (ach.requirement.type === 'find_rarity') {
                    // Start progress at 0, if found >= val, then 1/1?
                    // Rarity isn't a progress bar usually.
                    if (current >= max) current = max;
                    else current = 0; // Binary
                    // Maybe display as "Found / Goal"?
                }

                if (current > max && typeof max === 'number') current = max;

                // Format numbers
                const fmtCurrent = typeof current === 'number' ? current.toLocaleString() : current;
                const fmtMax = typeof max === 'number' ? max.toLocaleString() : max;
                let percent = 0;
                if (typeof max === 'number' && typeof current === 'number' && max > 0) {
                    percent = Math.min(100, (current / max) * 100);
                }
                if (isCompleted) percent = 100;

                const checkClass = isCompleted ? 'ach-check-box checked' : 'ach-check-box';

                item.innerHTML = `
                    <div class="ach-item-content">
                        <div class="ach-item-title">${ach.name}</div>
                        <div class="ach-item-desc">${ach.description}</div>
                        <div class="ach-progress-container">
                            <div class="ach-progress-bar" style="width: ${percent}%"></div>
                            <div class="ach-progress-text">${fmtCurrent} / ${fmtMax}</div>
                        </div>
                    </div>
                    <div class="${checkClass}"></div>
                `;

                listContainer.appendChild(item);
            });

            // Auto Select first if none selected
            if (!currentSelectedAchievement && firstId) {
                selectAchievement(firstId);
                // Also highlight first item visually
                if (listContainer.firstChild) listContainer.firstChild.classList.add('active');
            }
        }

        function selectAchievement(id) {
            currentSelectedAchievement = id;
            const ach = ACHIEVEMENTS.find(a => a.id === id);
            if (!ach) return;

            // Update Details
            document.getElementById('ach-detail-title').textContent = ach.name;
            document.getElementById('ach-detail-desc').textContent = ach.description;

            // Rewards
            const rewardsContainer = document.getElementById('ach-detail-rewards');
            rewardsContainer.innerHTML = '';

            if (ach.rewards) {
                const entries = [];
                if (ach.rewards.coins) entries.push(`Coins [x${ach.rewards.coins.toLocaleString()}]`);
                if (ach.rewards.voidCoins) entries.push(`Void Coins [x${ach.rewards.voidCoins}]`);
                if (ach.rewards.potionChest) entries.push(`Potion Chest [x${ach.rewards.potionChest}]`);
                if (ach.rewards.rarePotionChest) entries.push(`Rare Potion Chest [x${ach.rewards.rarePotionChest}]`);
                if (ach.rewards.megaPotionChest) entries.push(`Mega Potion Chest [x${ach.rewards.megaPotionChest}]`);
                if (ach.rewards.runeChest) entries.push(`Rune Chest [x${ach.rewards.runeChest}]`);
                if (ach.rewards.buff) entries.push(`Buff: ${ach.rewards.buff}`);
                if (ach.rewards.potions) {
                    for (const [pid, count] of Object.entries(ach.rewards.potions)) {
                        entries.push(`${pid.replace(/_/g, ' ')} [x${count}]`);
                    }
                }
                if (ach.title) entries.push(`Title: "${ach.title}"`);

                // If no rewards but title (already covered)
                // If totally empty?
                if (entries.length === 0) entries.push("No specific reward");

                entries.forEach(text => {
                    const div = document.createElement('div');
                    div.className = 'ach-reward-item';
                    div.innerHTML = `
                        <div style="position:relative; z-index:1; text-transform: capitalize;">${text}</div>
                        <div class="ach-reward-bracket-sm"></div>
                    `;
                    rewardsContainer.appendChild(div);
                });
            }

            // Status
            const statusBtn = document.getElementById('ach-detail-status');
            const isCompleted = playerAchievements.completed[id];
            if (isCompleted) {
                statusBtn.innerHTML = '<div class="corner-brackets"></div>CLAIMED';
                statusBtn.style.color = '#2ecc71';
                statusBtn.style.background = 'rgba(46, 204, 113, 0.1)';
            } else {
                statusBtn.innerHTML = '<div class="corner-brackets"></div>LOCKED';
                statusBtn.style.color = '#e74c3c';
                statusBtn.style.background = 'rgba(231, 76, 60, 0.1)';
            }
        }

        // Search Listener
        const searchInput = document.getElementById('ach-search');
        if (searchInput) {
            searchInput.addEventListener('input', () => populateAchievements());
        }
    </script>
    <!-- Chest Opening Overlay -->
    <div id="chest-overlay" class="chest-overlay">
        <div id="chest-visual" class="chest-visual">BOX</div>
        <div id="chest-loot" class="chest-loot"></div>
    </div>

    <style>
        /* Chest Animations */
        @keyframes shake {
            0% {
                transform: translate(1px, 1px) rotate(0deg);
            }

            10% {
                transform: translate(-1px, -2px) rotate(-1deg);
            }

            20% {
                transform: translate(-3px, 0px) rotate(1deg);
            }

            30% {
                transform: translate(3px, 2px) rotate(0deg);
            }

            40% {
                transform: translate(1px, -1px) rotate(1deg);
            }

            50% {
                transform: translate(-1px, 2px) rotate(-1deg);
            }

            60% {
                transform: translate(-3px, 1px) rotate(0deg);
            }

            70% {
                transform: translate(3px, 1px) rotate(-1deg);
            }

            80% {
                transform: translate(-1px, -1px) rotate(1deg);
            }

            90% {
                transform: translate(1px, 2px) rotate(0deg);
            }

            100% {
                transform: translate(1px, -2px) rotate(-1deg);
            }
        }

        .chest-shake {
            animation: shake 0.5s;
            animation-iteration-count: infinite;
        }

        .chest-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 10000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .chest-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        .chest-visual {
            font-size: 100px;
            margin-bottom: 20px;
            transition: transform 0.5s;
            cursor: pointer;
        }

        .chest-loot {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 8px;
            justify-content: center;
            max-width: 90vw;
            max-height: 70vh;
            overflow-y: auto;
            padding: 10px;
        }

        .loot-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 8px;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 80px;
            opacity: 0;
            transform: translateY(10px);
            animation: loot-pop 0.3s forwards;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .loot-item img {
            width: 30px;
            height: 30px;
            margin-bottom: 4px;
        }

        .loot-name {
            font-size: 11px;
            text-align: center;
            color: #fff;
            margin-bottom: 2px;
            line-height: 1.2;
        }

        .loot-count {
            font-size: 11px;
            color: #aaa;
            font-weight: bold;
        }

        @keyframes loot-pop {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .chest-back-btn {
            margin-top: 30px;
            padding: 10px 30px;
            background: #e74c3c;
            border: none;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            display: none;
            /* Hidden until loot shown */
            animation: fadeIn 1s forwards;
        }
    </style>

    <script>
        // --- Chests Logic ---
        function appendWorkshopChestAndMaterials(list, searchQuery = '') {
            if (!list) return;
            // 1. Chests
            Object.entries(playerInventory.chests || {}).forEach(([id, count]) => {
                if (count <= 0) return;
                const type = CHEST_TYPES[id];
                if (!type) return;
                if (searchQuery) {
                    const term = searchQuery.toLowerCase();
                    const haystack = `${type.name} ${type.description}`.toLowerCase();
                    if (!haystack.includes(term)) return;
                }

                const item = document.createElement('div');
                item.classList.add('workshop-list-item');
                item.innerHTML = `
                     <div class="item-tier" style="background: ${type.color}">CHEST</div>
                     <div class="item-name" style="color: ${type.color}">${type.name}</div>
                     <div class="item-desc">${type.description}</div>
                     <div class="item-count">x${count}</div>
                 `;
                item.onclick = () => selectChestAction(id);
                list.appendChild(item);
            });

            // 2. Materials
            Object.entries(playerInventory.materials || {}).forEach(([name, count]) => {
                if (count <= 0) return;
                if (searchQuery && !name.toLowerCase().includes(searchQuery.toLowerCase())) return;
                const item = document.createElement('div');
                item.classList.add('workshop-list-item');
                item.innerHTML = `
                     <div class="item-tier">MAT</div>
                     <div class="item-name">${name}</div>
                     <div class="item-desc">Crafting material.</div>
                     <div class="item-count">x${count}</div>
                 `;
                list.appendChild(item);
            });
        }

        let selectedChestId = null;

        function selectChestAction(id) {
            console.log('Selecting Chest:', id);
            selectedChestId = id;
            selectedGear = null;
            if (typeof selectedPotion !== 'undefined') selectedPotion = null;

            const type = CHEST_TYPES[id];

            // Update Preview
            const preview = document.getElementById('workshop-preview');
            if (preview) {
                preview.innerHTML = `
                        <div style="text-align: center; padding: 20px;">
                            <div class="item-tier" style="margin-bottom: 10px; background: ${type.color}">CHEST</div>
                            <div style="font-size: 64px; margin-bottom: 20px; filter: drop-shadow(0 0 10px ${type.color}44);">${type.icon}</div>
                            <div style="font-size: 22px; font-weight: 700; margin-bottom: 10px; color: ${type.color}">${type.name}</div>
                            <div style="font-size: 13px; color: rgba(255,255,255,0.6); margin-bottom: 15px; line-height: 1.4;">${type.description}</div>
                            <div style="font-size: 11px; color: #aaa; background: rgba(255,255,255,0.05); padding: 5px 10px; border-radius: 20px; display:inline-block;">Contains ${id === 'mega_potion_chest' ? '3-5' : (id === 'rare_potion_chest' ? '2-3' : '1-2')} random potions</div>
                        </div>
                    `;
            }

            // Update Action Button with quantity options
            const craftBtn = document.getElementById('craft-btn');
            const chestCount = playerInventory.chests[id] || 0;
            if (craftBtn) {
                craftBtn.textContent = 'Open x1';
                craftBtn.disabled = chestCount <= 0;
                craftBtn.onclick = () => openChest(id, 1);
            }

            // Add quantity buttons container after preview
            let quantityBtns = document.getElementById('chest-quantity-btns');
            if (!quantityBtns) {
                quantityBtns = document.createElement('div');
                quantityBtns.id = 'chest-quantity-btns';
                quantityBtns.style.cssText = 'display: flex; gap: 10px; justify-content: center; margin-top: 15px; flex-wrap: wrap;';
                preview.appendChild(quantityBtns);
            }

            quantityBtns.innerHTML = `
                <button class="chest-qty-btn" onclick="openChest('${id}', 1)" ${chestCount < 1 ? 'disabled' : ''} style="
                    padding: 10px 20px; background: linear-gradient(135deg, ${type.color}44, ${type.color}88); 
                    border: 1px solid ${type.color}; border-radius: 8px; color: #fff; cursor: pointer; 
                    font-weight: 600; font-size: 14px; transition: all 0.2s;
                    ${chestCount < 1 ? 'opacity: 0.4; cursor: not-allowed;' : ''}
                ">Open x1</button>
                <button class="chest-qty-btn" onclick="openChest('${id}', 5)" ${chestCount < 5 ? 'disabled' : ''} style="
                    padding: 10px 20px; background: linear-gradient(135deg, ${type.color}66, ${type.color}aa); 
                    border: 1px solid ${type.color}; border-radius: 8px; color: #fff; cursor: pointer; 
                    font-weight: 600; font-size: 14px; transition: all 0.2s;
                    ${chestCount < 5 ? 'opacity: 0.4; cursor: not-allowed;' : ''}
                ">Open x5</button>
                <button class="chest-qty-btn" onclick="openChest('${id}', 10)" ${chestCount < 10 ? 'disabled' : ''} style="
                    padding: 10px 20px; background: linear-gradient(135deg, ${type.color}88, ${type.color}cc); 
                    border: 1px solid ${type.color}; border-radius: 8px; color: #fff; cursor: pointer; 
                    font-weight: 600; font-size: 14px; transition: all 0.2s;
                    ${chestCount < 10 ? 'opacity: 0.4; cursor: not-allowed;' : ''}
                ">Open x10</button>
            `;

            // Update Materials List with Percentages
            const materialsList = document.getElementById('workshop-materials');
            if (materialsList) {
                const totalWeight = type.lootTable.reduce((acc, item) => acc + item.weight, 0);

                materialsList.innerHTML = `<div style="padding: 10px; border-bottom: 1px solid rgba(255,255,255,0.05); text-align:center; color: #ffd700; font-size: 13px; font-weight: 600;">Loot Chances</div>` +
                    `<div style="padding: 10px; max-height: 250px; overflow-y: auto;">` +
                    type.lootTable.map(l => {
                        const p = POTIONS.find(x => x.id === l.id);
                        const chance = ((l.weight / totalWeight) * 100).toFixed(1);
                        const color = p ? getTierColor(p.rarity) : '#fff';
                        return `<div style="font-size:12px; margin-bottom:8px; display: flex; justify-content: space-between; align-items: center; background: rgba(255,255,255,0.03); padding: 6px 10px; border-radius: 4px;">
                            <span style="color:${color}; font-weight: 500;">${p ? p.name : l.id}</span>
                            <span style="color:rgba(255,255,255,0.5); font-weight: 700; font-family: monospace;">${chance}%</span>
                         </div>`;
                    }).join('') + `</div>`;
            }
        }

        function performWorkshopAction() {
            console.log('Central Workshop Action Triggered', { selectedChestId, selectedPotion, selectedGear });
            if (typeof selectedChestId !== 'undefined' && selectedChestId) {
                openChest(selectedChestId);
            } else if (typeof selectedPotion !== 'undefined' && selectedPotion) {
                if (typeof craftPotion === 'function') craftPotion();
            } else if (selectedGear) {
                if (typeof craftGear === 'function') craftGear();
            }
        }

        // Open Chest Function - supports opening multiple at once
        function openChest(chestId, quantity = 1) {
            console.log('openChest called with ID:', chestId, 'Quantity:', quantity);
            const chestData = CHEST_TYPES[chestId];
            if (!chestData) {
                console.error('Chest data NOT FOUND for ID:', chestId);
                return;
            }

            const available = playerInventory.chests[chestId] || 0;
            if (available <= 0) {
                console.warn('No chests of this type in inventory:', chestId);
                showNotification("No chests remaining!", "#e74c3c");
                return;
            }

            // Clamp quantity to available chests (max 10)
            const openCount = Math.min(quantity, available, 10);

            // Deduct Chests
            playerInventory.chests[chestId] -= openCount;
            populateWorkshopItems(); // Refresh count
            selectChestAction(chestId); // Refresh buttons

            // Calculate Loot for ALL chests being opened
            const loot = [];
            const lootSummary = {}; // Track duplicates for summary display (now tracks quantities properly)

            for (let c = 0; c < openCount; c++) {
                // Each chest gives 1 roll from the loot table (quantity is per item)
                // The loot table items now have their own quantity field

                // Weighted Random Selection
                const table = chestData.lootTable;
                const totalWeight = table.reduce((acc, item) => acc + item.weight, 0);
                let random = Math.random() * totalWeight;

                for (const item of table) {
                    if (random < item.weight) {
                        // Get the quantity for this drop (default to 1 if not specified)
                        const dropQuantity = item.quantity || 1;

                        // Add to loot array (for display purposes)
                        loot.push({ id: item.id, quantity: dropQuantity });

                        // Track in summary (accumulate quantities)
                        lootSummary[item.id] = (lootSummary[item.id] || 0) + dropQuantity;
                        break;
                    }
                    random -= item.weight;
                }
            }

            // Start Animation
            const overlay = document.getElementById('chest-overlay');
            const visual = document.getElementById('chest-visual');
            const lootContainer = document.getElementById('chest-loot');

            if (!overlay || !visual || !lootContainer) {
                console.error('Chest Overlay elements MISSING!', { overlay, visual, lootContainer });
                showNotification("Animation error! Loot added to inventory.", "#ff6b6b");
                // Fallback: just add loot quietly using the quantity
                Object.entries(lootSummary).forEach(([potionId, count]) => {
                    playerInventory.potions[potionId] = (playerInventory.potions[potionId] || 0) + count;
                });
                saveGame();
                return;
            }

            overlay.classList.add('active');
            visual.style.display = 'none'; // Skip straight to loot
            lootContainer.innerHTML = ''; // Clear old loot

            // Calculate total potions received for notification
            const totalPotions = Object.values(lootSummary).reduce((acc, count) => acc + count, 0);

            // Display Loot (grouped by type for multi-open)
            Object.entries(lootSummary).forEach(([potionId, count], index) => {
                const potion = POTIONS.find(p => p.id === potionId) || { name: potionId, rarity: 'Common' };
                // Add to inventory with proper quantity
                playerInventory.potions[potionId] = (playerInventory.potions[potionId] || 0) + count;

                const el = document.createElement('div');
                el.className = 'loot-item';
                el.style.animationDelay = `${index * 0.05}s`; // Faster stagger
                el.innerHTML = `
                     <div style="font-size: 18px;">Flask</div>
                     <div class="loot-name" style="color: ${getTierColor(potion.rarity)}">${potion.name}</div>
                     <div class="loot-count" style="background: ${getTierColor(potion.rarity)}22; padding: 2px 6px; border-radius: 8px;">x${count}</div>
                 `;
                lootContainer.appendChild(el);
            });

            // Show Close Button
            let btn = document.getElementById('chest-close-btn');
            if (!btn) {
                btn = document.createElement('button');
                btn.id = 'chest-close-btn';
                btn.className = 'chest-back-btn';
                btn.textContent = 'Collect All';
                btn.onclick = closeChestOverlay;
                overlay.appendChild(btn);
            }
            btn.style.display = 'block';

            showNotification(`Opened ${openCount}x ${chestData.name}! Got ${totalPotions} potions!`, chestData.color);
            saveGame();
            if (typeof updatePotionInventoryDisplay === 'function') updatePotionInventoryDisplay();
        }

        function closeChestOverlay() {
            const overlay = document.getElementById('chest-overlay');
            const visual = document.getElementById('chest-visual');
            const btn = document.getElementById('chest-close-btn');

            overlay.classList.remove('active');

            // Reset state for next time
            setTimeout(() => {
                visual.style.display = 'block';
                visual.style.transform = 'scale(1)';
                visual.textContent = 'BOX';
                if (btn) btn.style.display = 'none';
                document.getElementById('chest-loot').innerHTML = '';
            }, 300);
        }

    </script>
</body>

</html>
